<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>MAGRATHEA/PATHFINDER: magrathea::Vectorizer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MAGRATHEA/PATHFINDER
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemagrathea.html">magrathea</a></li><li class="navelem"><a class="el" href="classmagrathea_1_1Vectorizer.html">Vectorizer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classmagrathea_1_1Vectorizer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">magrathea::Vectorizer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Helper base class for generic vectorization.  
 <a href="classmagrathea_1_1Vectorizer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="vectorizer_8h_source.html">vectorizer.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for magrathea::Vectorizer:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classmagrathea_1_1Vectorizer.png" usemap="#magrathea::Vectorizer_map" alt=""/>
  <map id="magrathea::Vectorizer_map" name="magrathea::Vectorizer_map">
<area href="classmagrathea_1_1StaticVectorizer.html" title="Helper class for generic constant size vectorization." alt="magrathea::StaticVectorizer&lt; Kind, Size, Crtp, Type, Parameters &gt;" shape="rect" coords="0,56,461,80"/>
<area href="exceptionmagrathea_1_1Vectorized.html" title="Basic vectorized container." alt="magrathea::Vectorized&lt; Type, Size &gt;" shape="rect" coords="471,56,932,80"/>
<area href="classmagrathea_1_1StaticVectorizer.html" alt="magrathea::StaticVectorizer&lt; Kind, Size, Crtp, Type, Parameters...&gt;" shape="rect" coords="942,56,1403,80"/>
<area href="classmagrathea_1_1StaticVectorizer.html" alt="magrathea::StaticVectorizer&lt; unsigned int, Size, NArray, Type, Parameters...&gt;" shape="rect" coords="1413,56,1874,80"/>
<area href="classmagrathea_1_1StaticVectorizer.html" alt="magrathea::StaticVectorizer&lt; unsigned int, Size, StaticVector, Type, Size &gt;" shape="rect" coords="1884,56,2345,80"/>
<area href="classmagrathea_1_1AbstractNArray.html" title="Abstract base class of n-dimensional mathematical arrays." alt="magrathea::AbstractNArray&lt; Kind, Size, Crtp, Type, Parameters &gt;" shape="rect" coords="942,112,1403,136"/>
<area href="classmagrathea_1_1AbstractNArray.html" alt="magrathea::AbstractNArray&lt; unsigned int, Size, NArray, Type, Size &gt;" shape="rect" coords="1413,112,1874,136"/>
<area href="exceptionmagrathea_1_1StaticVector.html" title="Basic vectorized constant size container." alt="magrathea::StaticVector&lt; Type, Size &gt;" shape="rect" coords="1884,112,2345,136"/>
<area href="exceptionmagrathea_1_1NArray.html" title="Basic n-dimensional mathematical array." alt="magrathea::NArray&lt; Type, Size &gt;" shape="rect" coords="1413,168,1874,192"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Vectorization</div></td></tr>
<tr class="memitem:a83ebb071ab30dce7af155d3c0e597fb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmagrathea_1_1Vectorizer.html">Vectorizer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#a83ebb071ab30dce7af155d3c0e597fb9">operator[]</a> (const unsigned int i)</td></tr>
<tr class="memdesc:a83ebb071ab30dce7af155d3c0e597fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the element.  <a href="#a83ebb071ab30dce7af155d3c0e597fb9"></a><br/></td></tr>
<tr class="separator:a83ebb071ab30dce7af155d3c0e597fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa058daf8b240bb587b80888ab88340c7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmagrathea_1_1Vectorizer.html">Vectorizer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#aa058daf8b240bb587b80888ab88340c7">operator[]</a> (const unsigned int i) const </td></tr>
<tr class="memdesc:aa058daf8b240bb587b80888ab88340c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Immutable direct access to the element.  <a href="#aa058daf8b240bb587b80888ab88340c7"></a><br/></td></tr>
<tr class="separator:aa058daf8b240bb587b80888ab88340c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3c5369c91276766e0197fa33ae4951"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmagrathea_1_1Vectorizer.html">Vectorizer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#afe3c5369c91276766e0197fa33ae4951">resize</a> (const unsigned int n)</td></tr>
<tr class="memdesc:afe3c5369c91276766e0197fa33ae4951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the container.  <a href="#afe3c5369c91276766e0197fa33ae4951"></a><br/></td></tr>
<tr class="separator:afe3c5369c91276766e0197fa33ae4951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b54f2b5f17c2054f99e03c7c4614558"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#a3b54f2b5f17c2054f99e03c7c4614558">size</a> () const </td></tr>
<tr class="memdesc:a3b54f2b5f17c2054f99e03c7c4614558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the container.  <a href="#a3b54f2b5f17c2054f99e03c7c4614558"></a><br/></td></tr>
<tr class="separator:a3b54f2b5f17c2054f99e03c7c4614558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e30cc7971bfbcf7b21f993b56c0644e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#a2e30cc7971bfbcf7b21f993b56c0644e">constant</a> () const </td></tr>
<tr class="memdesc:a2e30cc7971bfbcf7b21f993b56c0644e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether the container has a constant size.  <a href="#a2e30cc7971bfbcf7b21f993b56c0644e"></a><br/></td></tr>
<tr class="separator:a2e30cc7971bfbcf7b21f993b56c0644e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5100fafcacd2c835380dbe0403422ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#ab5100fafcacd2c835380dbe0403422ec">boolean</a> () const </td></tr>
<tr class="memdesc:ab5100fafcacd2c835380dbe0403422ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether the container has a boolean type.  <a href="#ab5100fafcacd2c835380dbe0403422ec"></a><br/></td></tr>
<tr class="separator:ab5100fafcacd2c835380dbe0403422ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7815b5c9e9ff56064306e7d07dae5bb7"><td class="memItemLeft" align="right" valign="top">std::array&lt; unsigned int, 0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#a7815b5c9e9ff56064306e7d07dae5bb7">parameters</a> () const </td></tr>
<tr class="memdesc:a7815b5c9e9ff56064306e7d07dae5bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the template parameters.  <a href="#a7815b5c9e9ff56064306e7d07dae5bb7"></a><br/></td></tr>
<tr class="separator:a7815b5c9e9ff56064306e7d07dae5bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46ebf417fa856107cb9b84db9939f76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#af46ebf417fa856107cb9b84db9939f76">type</a> () const </td></tr>
<tr class="memdesc:af46ebf417fa856107cb9b84db9939f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the data type.  <a href="#af46ebf417fa856107cb9b84db9939f76"></a><br/></td></tr>
<tr class="separator:af46ebf417fa856107cb9b84db9939f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Check</div></td></tr>
<tr class="memitem:a9c5d14ef63c3245c6e3ba161e5efdf95"><td class="memTemplParams" colspan="2">template&lt;bool Exception = true, class FirstType , class SecondType , class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, FirstType&gt;::value) || (!std::is_base_of&lt;Vectorizer, SecondType&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:a9c5d14ef63c3245c6e3ba161e5efdf95"><td class="memTemplItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#a9c5d14ef63c3245c6e3ba161e5efdf95">check</a> (const FirstType &amp;, const SecondType &amp;)</td></tr>
<tr class="memdesc:a9c5d14ef63c3245c6e3ba161e5efdf95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check compatibility with at least one non-vectorized type.  <a href="#a9c5d14ef63c3245c6e3ba161e5efdf95"></a><br/></td></tr>
<tr class="separator:a9c5d14ef63c3245c6e3ba161e5efdf95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a8845625441b2b7ca940542c5a42ea"><td class="memTemplParams" colspan="2">template&lt;bool Exception = true, class FirstType , class SecondType , class  = typename std::enable_if&lt;(std::is_base_of&lt;Vectorizer, FirstType&gt;::value) &amp;&amp; (std::is_base_of&lt;Vectorizer, SecondType&gt;::value)&gt;::type, class  = typename std::enable_if&lt;(FirstType::constant()) &amp;&amp; (SecondType::constant())&gt;::type&gt; </td></tr>
<tr class="memitem:a46a8845625441b2b7ca940542c5a42ea"><td class="memTemplItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#a46a8845625441b2b7ca940542c5a42ea">check</a> (const FirstType &amp;, const SecondType &amp;)</td></tr>
<tr class="separator:a46a8845625441b2b7ca940542c5a42ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cbb51491c2e83e5cedeced2d5945cde"><td class="memTemplParams" colspan="2">template&lt;bool Exception = true, class FirstType , class SecondType , class  = typename std::enable_if&lt;(std::is_base_of&lt;Vectorizer, FirstType&gt;::value) &amp;&amp; (std::is_base_of&lt;Vectorizer, SecondType&gt;::value)&gt;::type, class  = typename std::enable_if&lt;(!FirstType::constant()) || (!SecondType::constant())&gt;::type, class  = void&gt; </td></tr>
<tr class="memitem:a8cbb51491c2e83e5cedeced2d5945cde"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#a8cbb51491c2e83e5cedeced2d5945cde">check</a> (const FirstType &amp;first, const SecondType &amp;second)</td></tr>
<tr class="separator:a8cbb51491c2e83e5cedeced2d5945cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Getters</div></td></tr>
<tr class="memitem:a8d9b9d79268199cbac2906cffd22c0d4"><td class="memTemplParams" colspan="2">template&lt;typename IntegralType , IntegralType Value, typename DummyType  = unsigned int, class  = typename std::enable_if&lt;(std::is_integral&lt;IntegralType&gt;::value) &amp;&amp; (std::is_convertible&lt;DummyType, unsigned int&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:a8d9b9d79268199cbac2906cffd22c0d4"><td class="memTemplItemLeft" align="right" valign="top">static constexpr IntegralType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#a8d9b9d79268199cbac2906cffd22c0d4">get</a> (const std::integral_constant&lt; IntegralType, Value &gt;, const DummyType=DummyType())</td></tr>
<tr class="memdesc:a8d9b9d79268199cbac2906cffd22c0d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integral constant getter.  <a href="#a8d9b9d79268199cbac2906cffd22c0d4"></a><br/></td></tr>
<tr class="separator:a8d9b9d79268199cbac2906cffd22c0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a89b7c95b5067316ad946aaab3d5686"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename DummyType  = unsigned int, class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, DataType&gt;::value) &amp;&amp; (std::is_convertible&lt;DummyType, unsigned int&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:a7a89b7c95b5067316ad946aaab3d5686"><td class="memTemplItemLeft" align="right" valign="top">static DataType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#a7a89b7c95b5067316ad946aaab3d5686">get</a> (DataType &amp;source, const DummyType=DummyType())</td></tr>
<tr class="memdesc:a7a89b7c95b5067316ad946aaab3d5686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-vectorized getter.  <a href="#a7a89b7c95b5067316ad946aaab3d5686"></a><br/></td></tr>
<tr class="separator:a7a89b7c95b5067316ad946aaab3d5686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a63af59c59b04cbbe01a3447a7ac552"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename DummyType  = unsigned int, class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, DataType&gt;::value) &amp;&amp; (std::is_convertible&lt;DummyType, unsigned int&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:a9a63af59c59b04cbbe01a3447a7ac552"><td class="memTemplItemLeft" align="right" valign="top">static const DataType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#a9a63af59c59b04cbbe01a3447a7ac552">get</a> (const DataType &amp;source, const DummyType=DummyType())</td></tr>
<tr class="memdesc:a9a63af59c59b04cbbe01a3447a7ac552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Immutable non-vectorized getter.  <a href="#a9a63af59c59b04cbbe01a3447a7ac552"></a><br/></td></tr>
<tr class="separator:a9a63af59c59b04cbbe01a3447a7ac552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af077b83bc7bc9d07e59895cf3df6641e"><td class="memTemplParams" colspan="2">template&lt;class VectorizedType , class  = typename std::enable_if&lt;std::is_base_of&lt;Vectorizer, VectorizedType&gt;::value&gt;::type, typename DataType  = typename std::remove_reference&lt;decltype(VectorizedType::type())&gt;::type&gt; </td></tr>
<tr class="memitem:af077b83bc7bc9d07e59895cf3df6641e"><td class="memTemplItemLeft" align="right" valign="top">static DataType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#af077b83bc7bc9d07e59895cf3df6641e">get</a> (VectorizedType &amp;source, const unsigned int i)</td></tr>
<tr class="memdesc:af077b83bc7bc9d07e59895cf3df6641e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector element getter.  <a href="#af077b83bc7bc9d07e59895cf3df6641e"></a><br/></td></tr>
<tr class="separator:af077b83bc7bc9d07e59895cf3df6641e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3ae98c035c1f3004ee2f88f6179066"><td class="memTemplParams" colspan="2">template&lt;class VectorizedType , class  = typename std::enable_if&lt;std::is_base_of&lt;Vectorizer, VectorizedType&gt;::value&gt;::type, typename DataType  = typename std::remove_reference&lt;decltype(VectorizedType::type())&gt;::type&gt; </td></tr>
<tr class="memitem:a3a3ae98c035c1f3004ee2f88f6179066"><td class="memTemplItemLeft" align="right" valign="top">static const DataType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#a3a3ae98c035c1f3004ee2f88f6179066">get</a> (const VectorizedType &amp;source, const unsigned int i)</td></tr>
<tr class="memdesc:a3a3ae98c035c1f3004ee2f88f6179066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Immutable vector element getter.  <a href="#a3a3ae98c035c1f3004ee2f88f6179066"></a><br/></td></tr>
<tr class="separator:a3a3ae98c035c1f3004ee2f88f6179066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Setters</div></td></tr>
<tr class="memitem:a67836bbf5aced8fee531fd2caf839f15"><td class="memTemplParams" colspan="2">template&lt;class VectorizedType , class  = typename std::enable_if&lt;std::is_base_of&lt;Vectorizer, VectorizedType&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a67836bbf5aced8fee531fd2caf839f15"><td class="memTemplItemLeft" align="right" valign="top">static VectorizedType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#a67836bbf5aced8fee531fd2caf839f15">set</a> (VectorizedType &amp;destination)</td></tr>
<tr class="memdesc:a67836bbf5aced8fee531fd2caf839f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty setter.  <a href="#a67836bbf5aced8fee531fd2caf839f15"></a><br/></td></tr>
<tr class="separator:a67836bbf5aced8fee531fd2caf839f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa586478d9b24b19586ff1d6dfdff5b68"><td class="memTemplParams" colspan="2">template&lt;class VectorizedType , class  = typename std::enable_if&lt;std::is_base_of&lt;Vectorizer, VectorizedType&gt;::value&gt;::type, class GenericType &gt; </td></tr>
<tr class="memitem:aa586478d9b24b19586ff1d6dfdff5b68"><td class="memTemplItemLeft" align="right" valign="top">static VectorizedType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#aa586478d9b24b19586ff1d6dfdff5b68">set</a> (VectorizedType &amp;destination, const GenericType &amp;source)</td></tr>
<tr class="memdesc:aa586478d9b24b19586ff1d6dfdff5b68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy setter.  <a href="#aa586478d9b24b19586ff1d6dfdff5b68"></a><br/></td></tr>
<tr class="separator:aa586478d9b24b19586ff1d6dfdff5b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab181cd6d6a7afb777ebab551cc36bc33"><td class="memTemplParams" colspan="2">template&lt;class VectorizedType , class  = typename std::enable_if&lt;std::is_base_of&lt;Vectorizer, VectorizedType&gt;::value&gt;::type, class GenericType , class First , class Second , class... Others, class  = typename std::enable_if&lt;(sizeof...(Others) != 0) &amp;&amp; (sizeof...(Others) != 1)&gt;::type&gt; </td></tr>
<tr class="memitem:ab181cd6d6a7afb777ebab551cc36bc33"><td class="memTemplItemLeft" align="right" valign="top">static VectorizedType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#ab181cd6d6a7afb777ebab551cc36bc33">set</a> (VectorizedType &amp;destination, const GenericType &amp;source, const First &amp;first, const Second &amp;second, const Others &amp;...others)</td></tr>
<tr class="memdesc:ab181cd6d6a7afb777ebab551cc36bc33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variadic setter.  <a href="#ab181cd6d6a7afb777ebab551cc36bc33"></a><br/></td></tr>
<tr class="separator:ab181cd6d6a7afb777ebab551cc36bc33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acccf60d696c7fdba17a8ff7bf0efa5de"><td class="memTemplParams" colspan="2">template&lt;class VectorizedType , class  = typename std::enable_if&lt;std::is_base_of&lt;Vectorizer, VectorizedType&gt;::value&gt;::type, class GenericType , typename SizeType  = std::true_type, class  = typename std::enable_if&lt;(std::is_same&lt;SizeType, std::true_type&gt;::value) || (std::is_convertible&lt;SizeType, unsigned int&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:acccf60d696c7fdba17a8ff7bf0efa5de"><td class="memTemplItemLeft" align="right" valign="top">static VectorizedType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#acccf60d696c7fdba17a8ff7bf0efa5de">set</a> (VectorizedType &amp;destination, const GenericType &amp;source, const unsigned int pos, const SizeType num=SizeType())</td></tr>
<tr class="memdesc:acccf60d696c7fdba17a8ff7bf0efa5de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial setter.  <a href="#acccf60d696c7fdba17a8ff7bf0efa5de"></a><br/></td></tr>
<tr class="separator:acccf60d696c7fdba17a8ff7bf0efa5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3453b370f7c850f2ab17f20d0d3fb33"><td class="memTemplParams" colspan="2">template&lt;class VectorizedType , class  = typename std::enable_if&lt;std::is_base_of&lt;Vectorizer, VectorizedType&gt;::value&gt;::type, typename DataType  = typename std::remove_reference&lt;decltype(VectorizedType::type())&gt;::type, typename SizeType  = std::true_type, class  = typename std::enable_if&lt;(std::is_convertible&lt;DataType, typename std::remove_reference&lt;decltype(std::declval&lt;VectorizedType&gt;()[0])&gt;::type&gt;::value) &amp;&amp; ((std::is_same&lt;SizeType, std::true_type&gt;::value) || (std::is_convertible&lt;SizeType, unsigned int&gt;::value))&gt;::type&gt; </td></tr>
<tr class="memitem:af3453b370f7c850f2ab17f20d0d3fb33"><td class="memTemplItemLeft" align="right" valign="top">static VectorizedType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#af3453b370f7c850f2ab17f20d0d3fb33">set</a> (VectorizedType &amp;destination, const std::initializer_list&lt; DataType &gt; &amp;source, const unsigned int pos=0, const SizeType num=SizeType())</td></tr>
<tr class="memdesc:af3453b370f7c850f2ab17f20d0d3fb33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial list setter.  <a href="#af3453b370f7c850f2ab17f20d0d3fb33"></a><br/></td></tr>
<tr class="separator:af3453b370f7c850f2ab17f20d0d3fb33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0dd17adf7a9cc87583510b0ed84cde8"><td class="memTemplParams" colspan="2">template&lt;class VectorizedType , class  = typename std::enable_if&lt;std::is_base_of&lt;Vectorizer, VectorizedType&gt;::value&gt;::type, typename IteratorType , typename SizeType  = std::true_type, class  = typename std::enable_if&lt;(std::is_same&lt;SizeType, std::true_type&gt;::value) || (std::is_convertible&lt;SizeType, unsigned int&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:ac0dd17adf7a9cc87583510b0ed84cde8"><td class="memTemplItemLeft" align="right" valign="top">static VectorizedType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#ac0dd17adf7a9cc87583510b0ed84cde8">set</a> (VectorizedType &amp;destination, const IteratorType &amp;first, const IteratorType &amp;last, const unsigned int pos=0, const SizeType num=SizeType(), typename std::iterator_traits&lt; IteratorType &gt;::iterator_category *=nullptr)</td></tr>
<tr class="memdesc:ac0dd17adf7a9cc87583510b0ed84cde8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial range setter.  <a href="#ac0dd17adf7a9cc87583510b0ed84cde8"></a><br/></td></tr>
<tr class="separator:ac0dd17adf7a9cc87583510b0ed84cde8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea3e9a7f164f31f1f8f9b7ab3abe12c"><td class="memTemplParams" colspan="2">template&lt;class VectorizedType , class  = typename std::enable_if&lt;std::is_base_of&lt;Vectorizer, VectorizedType&gt;::value&gt;::type, class GenericType , class MaskType , typename DummyType  = unsigned int, class  = typename std::enable_if&lt;(std::is_base_of&lt;Vectorizer, MaskType&gt;::value) &amp;&amp; (std::is_convertible&lt;DummyType, unsigned int&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:a5ea3e9a7f164f31f1f8f9b7ab3abe12c"><td class="memTemplItemLeft" align="right" valign="top">static VectorizedType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#a5ea3e9a7f164f31f1f8f9b7ab3abe12c">set</a> (VectorizedType &amp;destination, const GenericType &amp;source, const MaskType &amp;mask, const DummyType=DummyType())</td></tr>
<tr class="memdesc:a5ea3e9a7f164f31f1f8f9b7ab3abe12c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Masked setter.  <a href="#a5ea3e9a7f164f31f1f8f9b7ab3abe12c"></a><br/></td></tr>
<tr class="separator:a5ea3e9a7f164f31f1f8f9b7ab3abe12c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc7d73a284fc36d87653df867ef6e00"><td class="memTemplParams" colspan="2">template&lt;class VectorizedType , class  = typename std::enable_if&lt;std::is_base_of&lt;Vectorizer, VectorizedType&gt;::value&gt;::type, typename DataType  = typename std::remove_reference&lt;decltype(VectorizedType::type())&gt;::type, class MaskType , typename DummyType  = unsigned int, class  = typename std::enable_if&lt;(std::is_base_of&lt;Vectorizer, MaskType&gt;::value) &amp;&amp; (std::is_convertible&lt;DummyType, unsigned int&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:aacc7d73a284fc36d87653df867ef6e00"><td class="memTemplItemLeft" align="right" valign="top">static VectorizedType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#aacc7d73a284fc36d87653df867ef6e00">set</a> (VectorizedType &amp;destination, const std::initializer_list&lt; DataType &gt; &amp;source, const MaskType &amp;mask, const DummyType=DummyType())</td></tr>
<tr class="memdesc:aacc7d73a284fc36d87653df867ef6e00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Masked list setter.  <a href="#aacc7d73a284fc36d87653df867ef6e00"></a><br/></td></tr>
<tr class="separator:aacc7d73a284fc36d87653df867ef6e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6c5228f8e7f3bba38d57886a4ef51a"><td class="memTemplParams" colspan="2">template&lt;class VectorizedType , class  = typename std::enable_if&lt;std::is_base_of&lt;Vectorizer, VectorizedType&gt;::value&gt;::type, typename IteratorType , class MaskType , typename DummyType  = unsigned int, class  = typename std::enable_if&lt;(std::is_base_of&lt;Vectorizer, MaskType&gt;::value) &amp;&amp; (std::is_convertible&lt;DummyType, unsigned int&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:a0f6c5228f8e7f3bba38d57886a4ef51a"><td class="memTemplItemLeft" align="right" valign="top">static VectorizedType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#a0f6c5228f8e7f3bba38d57886a4ef51a">set</a> (VectorizedType &amp;destination, const IteratorType &amp;first, const IteratorType &amp;last, const MaskType &amp;mask, const DummyType=DummyType(), typename std::iterator_traits&lt; IteratorType &gt;::iterator_category *=nullptr)</td></tr>
<tr class="memdesc:a0f6c5228f8e7f3bba38d57886a4ef51a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Masked range setter.  <a href="#a0f6c5228f8e7f3bba38d57886a4ef51a"></a><br/></td></tr>
<tr class="separator:a0f6c5228f8e7f3bba38d57886a4ef51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Test</div></td></tr>
<tr class="memitem:a302758cf072c56ea44519a41c2b70171"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#a302758cf072c56ea44519a41c2b70171">example</a> ()</td></tr>
<tr class="memdesc:a302758cf072c56ea44519a41c2b70171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Example function.  <a href="#a302758cf072c56ea44519a41c2b70171"></a><br/></td></tr>
<tr class="separator:a302758cf072c56ea44519a41c2b70171"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Protected lifecycle</div></td></tr>
<tr class="memitem:ab42248d231900ce89e17405a9e751535"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#ab42248d231900ce89e17405a9e751535">~Vectorizer</a> ()</td></tr>
<tr class="memdesc:ab42248d231900ce89e17405a9e751535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protected destructor.  <a href="#ab42248d231900ce89e17405a9e751535"></a><br/></td></tr>
<tr class="separator:ab42248d231900ce89e17405a9e751535"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Helper base class for generic vectorization. </p>
<p>Provides global functions for vectorization implementation. <a class="el" href="classmagrathea_1_1Vectorizer.html" title="Helper base class for generic vectorization.">Vectorizer</a> helpers (like <a class="el" href="classmagrathea_1_1StaticVectorizer.html" title="Helper class for generic constant size vectorization.">StaticVectorizer</a> or DynamicVectorizer) are derived from this class and have to implement the following functions required by CRTP : </p>
<ul>
<li>
<code>operator[]</code> </li>
<li>
<code><a class="el" href="classmagrathea_1_1Vectorizer.html#afe3c5369c91276766e0197fa33ae4951" title="Resize the container.">resize()</a></code> </li>
<li>
<code><a class="el" href="classmagrathea_1_1Vectorizer.html#a3b54f2b5f17c2054f99e03c7c4614558" title="Get the size of the container.">size()</a></code> </li>
<li>
<code><a class="el" href="classmagrathea_1_1Vectorizer.html#a2e30cc7971bfbcf7b21f993b56c0644e" title="Get whether the container has a constant size.">constant()</a></code> </li>
<li>
<code><a class="el" href="classmagrathea_1_1Vectorizer.html#ab5100fafcacd2c835380dbe0403422ec" title="Get whether the container has a boolean type.">boolean()</a></code> </li>
<li>
<code><a class="el" href="classmagrathea_1_1Vectorizer.html#a7815b5c9e9ff56064306e7d07dae5bb7" title="Get the template parameters.">parameters()</a></code> </li>
<li>
<code><a class="el" href="classmagrathea_1_1Vectorizer.html#af46ebf417fa856107cb9b84db9939f76" title="Get the data type.">type()</a></code> </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ab42248d231900ce89e17405a9e751535"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">magrathea::Vectorizer::~Vectorizer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Protected destructor. </p>
<p>Does nothing. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ab5100fafcacd2c835380dbe0403422ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::Vectorizer::boolean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get whether the container has a boolean type. </p>
<p>Returns true if the container has a boolean type size, false otherwise. This function is required by the vectorization mechanism. </p>
<dl class="section return"><dt>Returns</dt><dd>Copy of true if the container has a boolean type. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>This function should be overloaded by derived classes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9c5d14ef63c3245c6e3ba161e5efdf95"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Exception, class FirstType , class SecondType , class , class , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::Vectorizer::check </td>
          <td>(</td>
          <td class="paramtype">const FirstType &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SecondType &amp;&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check compatibility with at least one non-vectorized type. </p>
<p>Check compatibility between two vectorized types.</p>
<p>Check compatibility between two static vectorized types.</p>
<p>Checks whether the two provided vectorizer have compatible properties. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Exception</td><td>Throw exception or assertion on error. </td></tr>
    <tr><td class="paramname">FirstType</td><td>(First type.) </td></tr>
    <tr><td class="paramname">SecondType</td><td>(Second type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True whether the two types are compatible, false otherwise.</dd></dl>
<p>Checks whether the two provided vectorizer have compatible properties. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Exception</td><td>Throw exception or assertion on error. </td></tr>
    <tr><td class="paramname">FirstType</td><td>(First type.) </td></tr>
    <tr><td class="paramname">SecondType</td><td>(Second type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>First argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">second</td><td>Second argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True whether the two types are compatible, false otherwise. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td><a class="el" href="classmagrathea_1_1Vectorizer.html" title="Helper base class for generic vectorization.">Vectorizer</a> sizes are not equal. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a46a8845625441b2b7ca940542c5a42ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Exception = true, class FirstType , class SecondType , class  = typename std::enable_if&lt;(std::is_base_of&lt;Vectorizer, FirstType&gt;::value) &amp;&amp; (std::is_base_of&lt;Vectorizer, SecondType&gt;::value)&gt;::type, class  = typename std::enable_if&lt;(FirstType::constant()) &amp;&amp; (SecondType::constant())&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr bool magrathea::Vectorizer::check </td>
          <td>(</td>
          <td class="paramtype">const FirstType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SecondType &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8cbb51491c2e83e5cedeced2d5945cde"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Exception = true, class FirstType , class SecondType , class  = typename std::enable_if&lt;(std::is_base_of&lt;Vectorizer, FirstType&gt;::value) &amp;&amp; (std::is_base_of&lt;Vectorizer, SecondType&gt;::value)&gt;::type, class  = typename std::enable_if&lt;(!FirstType::constant()) || (!SecondType::constant())&gt;::type, class  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool magrathea::Vectorizer::check </td>
          <td>(</td>
          <td class="paramtype">const FirstType &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SecondType &amp;&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2e30cc7971bfbcf7b21f993b56c0644e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::Vectorizer::constant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get whether the container has a constant size. </p>
<p>Returns true if the container has a constant size, false otherwise. This function is required by the vectorization mechanism. </p>
<dl class="section return"><dt>Returns</dt><dd>Copy of true if the container has a constant size. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>This function should be overloaded by derived classes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a302758cf072c56ea44519a41c2b70171"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int magrathea::Vectorizer::example </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Example function. </p>
<p>Tests and demonstrates the use of <a class="el" href="classmagrathea_1_1Vectorizer.html" title="Helper base class for generic vectorization.">Vectorizer</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if no error. </dd></dl>

</div>
</div>
<a class="anchor" id="a8d9b9d79268199cbac2906cffd22c0d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntegralType , IntegralType Value, typename DummyType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr IntegralType magrathea::Vectorizer::get </td>
          <td>(</td>
          <td class="paramtype">const std::integral_constant&lt; IntegralType, Value &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DummyType&#160;</td>
          <td class="paramname"> = <code>DummyType()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integral constant getter. </p>
<p>Returns the value of the provided integral constant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntegralType</td><td>(Integral type.) </td></tr>
    <tr><td class="paramname">DummyType</td><td>(Dummy parameter type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of the integral constant. </dd></dl>

</div>
</div>
<a class="anchor" id="a7a89b7c95b5067316ad946aaab3d5686"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename DummyType, class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DataType &amp; magrathea::Vectorizer::get </td>
          <td>(</td>
          <td class="paramtype">DataType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DummyType&#160;</td>
          <td class="paramname"> = <code>DummyType()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-vectorized getter. </p>
<p>Returns a reference to the provided non-vectorized source. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataType</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">DummyType</td><td>(Dummy parameter type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>Argument to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the argument. </dd></dl>

</div>
</div>
<a class="anchor" id="a9a63af59c59b04cbbe01a3447a7ac552"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename DummyType, class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DataType &amp; magrathea::Vectorizer::get </td>
          <td>(</td>
          <td class="paramtype">const DataType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DummyType&#160;</td>
          <td class="paramname"> = <code>DummyType()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Immutable non-vectorized getter. </p>
<p>Returns a constant reference to the provided non-vectorized source. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataType</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">DummyType</td><td>(Dummy parameter type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>Argument to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the argument. </dd></dl>

</div>
</div>
<a class="anchor" id="af077b83bc7bc9d07e59895cf3df6641e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorizedType , class , typename DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DataType &amp; magrathea::Vectorizer::get </td>
          <td>(</td>
          <td class="paramtype">VectorizedType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector element getter. </p>
<p>Returns a reference to the i-th element of the provided vectorized source. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VectorizedType</td><td>(<a class="el" href="exceptionmagrathea_1_1Vectorized.html" title="Basic vectorized container.">Vectorized</a> type.) </td></tr>
    <tr><td class="paramname">DataType</td><td>(Data type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>Source container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Index of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the specified element. </dd></dl>

</div>
</div>
<a class="anchor" id="a3a3ae98c035c1f3004ee2f88f6179066"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorizedType , class , typename DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DataType &amp; magrathea::Vectorizer::get </td>
          <td>(</td>
          <td class="paramtype">const VectorizedType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Immutable vector element getter. </p>
<p>Returns a constant reference to the i-th element of the provided vectorized source. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VectorizedType</td><td>(<a class="el" href="exceptionmagrathea_1_1Vectorized.html" title="Basic vectorized container.">Vectorized</a> type.) </td></tr>
    <tr><td class="paramname">DataType</td><td>(Data type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>Source container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Index of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the specified element. </dd></dl>

</div>
</div>
<a class="anchor" id="a83ebb071ab30dce7af155d3c0e597fb9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmagrathea_1_1Vectorizer.html">Vectorizer</a> &amp; magrathea::Vectorizer::operator[] </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Direct access to the element. </p>
<p>Provides a direct access to the specified element. This function is required by the vectorization mechanism. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Index of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>This function should be overloaded by derived classes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa058daf8b240bb587b80888ab88340c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmagrathea_1_1Vectorizer.html">Vectorizer</a> &amp; magrathea::Vectorizer::operator[] </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Immutable direct access to the element. </p>
<p>Provides a constant direct access to the specified element. This function is required by the vectorization mechanism. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Index of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>This function should be overloaded by derived classes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7815b5c9e9ff56064306e7d07dae5bb7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; unsigned int, 0 &gt; magrathea::Vectorizer::parameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the template parameters. </p>
<p>Returns an array containing the template parameters. This function is required by the vectorization mechanism. </p>
<dl class="section return"><dt>Returns</dt><dd>Copy of an array of parameters. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>This function should be overloaded by derived classes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afe3c5369c91276766e0197fa33ae4951"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmagrathea_1_1Vectorizer.html">Vectorizer</a> &amp; magrathea::Vectorizer::resize </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize the container. </p>
<p>Resizes the container and returns a reference to it. This function is required by the vectorization mechanism. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>New size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Self reference. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>This function should be overloaded by derived classes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a67836bbf5aced8fee531fd2caf839f15"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorizedType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorizedType &amp; magrathea::Vectorizer::set </td>
          <td>(</td>
          <td class="paramtype">VectorizedType &amp;&#160;</td>
          <td class="paramname"><em>destination</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empty setter. </p>
<p>Does nothing. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VectorizedType</td><td>(<a class="el" href="exceptionmagrathea_1_1Vectorized.html" title="Basic vectorized container.">Vectorized</a> type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">destination</td><td>Destination of the copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the destination. </dd></dl>

</div>
</div>
<a class="anchor" id="aa586478d9b24b19586ff1d6dfdff5b68"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorizedType , class , class GenericType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorizedType &amp; magrathea::Vectorizer::set </td>
          <td>(</td>
          <td class="paramtype">VectorizedType &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GenericType &amp;&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy setter. </p>
<p>Copies the whole contents of the source to the destination. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VectorizedType</td><td>(<a class="el" href="exceptionmagrathea_1_1Vectorized.html" title="Basic vectorized container.">Vectorized</a> type.) </td></tr>
    <tr><td class="paramname">GenericType</td><td>(Generic type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">destination</td><td>Destination of the copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>Source of the copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the destination. </dd></dl>

</div>
</div>
<a class="anchor" id="ab181cd6d6a7afb777ebab551cc36bc33"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorizedType , class , class GenericType , class First , class Second , class... Others, class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorizedType &amp; magrathea::Vectorizer::set </td>
          <td>(</td>
          <td class="paramtype">VectorizedType &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GenericType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const First &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Second &amp;&#160;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Others &amp;...&#160;</td>
          <td class="paramname"><em>others</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variadic setter. </p>
<p>Calls recursively the setters for a long list of arguments. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VectorizedType</td><td>(<a class="el" href="exceptionmagrathea_1_1Vectorized.html" title="Basic vectorized container.">Vectorized</a> type.) </td></tr>
    <tr><td class="paramname">GenericType</td><td>(Generic type.) </td></tr>
    <tr><td class="paramname">First</td><td>(First type.) </td></tr>
    <tr><td class="paramname">Second</td><td>(Second type.) </td></tr>
    <tr><td class="paramname">Others</td><td>(Other types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">destination</td><td>Destination of the copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>Source of the copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>First extra argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">second</td><td>Second extra argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">others</td><td>Other arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the destination. </dd></dl>

</div>
</div>
<a class="anchor" id="acccf60d696c7fdba17a8ff7bf0efa5de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorizedType , class , class GenericType , typename SizeType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorizedType &amp; magrathea::Vectorizer::set </td>
          <td>(</td>
          <td class="paramtype">VectorizedType &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GenericType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SizeType&#160;</td>
          <td class="paramname"><em>num</em> = <code>SizeType()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial setter. </p>
<p>Copies the contents of the source to a part of the destination. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VectorizedType</td><td>(<a class="el" href="exceptionmagrathea_1_1Vectorized.html" title="Basic vectorized container.">Vectorized</a> type.) </td></tr>
    <tr><td class="paramname">GenericType</td><td>(Generic type.) </td></tr>
    <tr><td class="paramname">SizeType</td><td>(Size type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">destination</td><td>Destination of the copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>Source of the copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>Starting position of the copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>Number of elements to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the destination. </dd></dl>

</div>
</div>
<a class="anchor" id="af3453b370f7c850f2ab17f20d0d3fb33"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorizedType , class , typename DataType , typename SizeType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorizedType &amp; magrathea::Vectorizer::set </td>
          <td>(</td>
          <td class="paramtype">VectorizedType &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SizeType&#160;</td>
          <td class="paramname"><em>num</em> = <code>SizeType()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial list setter. </p>
<p>Copies the contents of the source to a part of the destination. The first element of the list is copied at the provided position, and the next elements are copied after it. If the list is too small, empty values are added to its end. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VectorizedType</td><td>(<a class="el" href="exceptionmagrathea_1_1Vectorized.html" title="Basic vectorized container.">Vectorized</a> type.) </td></tr>
    <tr><td class="paramname">DataType</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">SizeType</td><td>(Size type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">destination</td><td>Destination of the copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>Source of the copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>Starting position of the copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>Number of elements to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the destination. </dd></dl>

</div>
</div>
<a class="anchor" id="ac0dd17adf7a9cc87583510b0ed84cde8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorizedType , class , typename IteratorType , typename SizeType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorizedType &amp; magrathea::Vectorizer::set </td>
          <td>(</td>
          <td class="paramtype">VectorizedType &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IteratorType &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IteratorType &amp;&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SizeType&#160;</td>
          <td class="paramname"><em>num</em> = <code>SizeType()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::iterator_traits&lt; IteratorType &gt;::iterator_category *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial range setter. </p>
<p>Copies the values from the range to a part of the destination. The first element of the range is copied at the provided position, and the next elements are copied after it. The copy stops as soon as the end of the range is encountered or if the number of elements to copy is reached. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VectorizedType</td><td>(<a class="el" href="exceptionmagrathea_1_1Vectorized.html" title="Basic vectorized container.">Vectorized</a> type.) </td></tr>
    <tr><td class="paramname">IteratorType</td><td>(Iterator or pointer type.) </td></tr>
    <tr><td class="paramname">SizeType</td><td>(Size type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">destination</td><td>Destination of the copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator to the beginning of the range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator to the end of the range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>Starting position of the copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>Number of elements to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the destination. </dd></dl>

</div>
</div>
<a class="anchor" id="a5ea3e9a7f164f31f1f8f9b7ab3abe12c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorizedType , class , class GenericType , class MaskType , typename DummyType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorizedType &amp; magrathea::Vectorizer::set </td>
          <td>(</td>
          <td class="paramtype">VectorizedType &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GenericType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaskType &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DummyType&#160;</td>
          <td class="paramname"> = <code>DummyType()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Masked setter. </p>
<p>Copies elements of the source to the destination using a mask of boolean values : the values are copied only where the mask is true. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VectorizedType</td><td>(<a class="el" href="exceptionmagrathea_1_1Vectorized.html" title="Basic vectorized container.">Vectorized</a> type.) </td></tr>
    <tr><td class="paramname">GenericType</td><td>(Generic type.) </td></tr>
    <tr><td class="paramname">MaskType</td><td>(Mask Type.) </td></tr>
    <tr><td class="paramname">DummyType</td><td>(Dummy parameter type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">destination</td><td>Destination of the copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>Source of the copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>Boolean mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the destination. </dd></dl>

</div>
</div>
<a class="anchor" id="aacc7d73a284fc36d87653df867ef6e00"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorizedType , class , typename DataType , class MaskType , typename DummyType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorizedType &amp; magrathea::Vectorizer::set </td>
          <td>(</td>
          <td class="paramtype">VectorizedType &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaskType &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DummyType&#160;</td>
          <td class="paramname"> = <code>DummyType()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Masked list setter. </p>
<p>Copies the contents of the source to the destination using a mask of boolean values : the values are copied only where the mask is true. The iteration over values in the destination and in the source list are independant : the n-th element of the list is copied to the n-th true element of the destination. If the list is too small, empty values are added to its end. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VectorizedType</td><td>(<a class="el" href="exceptionmagrathea_1_1Vectorized.html" title="Basic vectorized container.">Vectorized</a> type.) </td></tr>
    <tr><td class="paramname">DataType</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">MaskType</td><td>(Mask Type.) </td></tr>
    <tr><td class="paramname">DummyType</td><td>(Dummy parameter type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">destination</td><td>Destination of the copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>Source of the copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>Boolean mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the destination. </dd></dl>

</div>
</div>
<a class="anchor" id="a0f6c5228f8e7f3bba38d57886a4ef51a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorizedType , class , typename IteratorType , class MaskType , typename DummyType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorizedType &amp; magrathea::Vectorizer::set </td>
          <td>(</td>
          <td class="paramtype">VectorizedType &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IteratorType &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IteratorType &amp;&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaskType &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DummyType&#160;</td>
          <td class="paramname"> = <code>DummyType()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::iterator_traits&lt; IteratorType &gt;::iterator_category *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Masked range setter. </p>
<p>Copies the values from the range to the destination using a mask of boolean values : the values are copied only where the mask is true. The iteration over values in the destination and in the range list are independant : the n-th element of the range is copied to the n-th true element of the destination. The copy stops as soon as the end of the range is encountered or if the number of elements to copy is reached. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VectorizedType</td><td>(<a class="el" href="exceptionmagrathea_1_1Vectorized.html" title="Basic vectorized container.">Vectorized</a> type.) </td></tr>
    <tr><td class="paramname">Iterator</td><td>(Iterator or pointer type.) </td></tr>
    <tr><td class="paramname">MaskType</td><td>(Mask Type.) </td></tr>
    <tr><td class="paramname">DummyType</td><td>(Dummy parameter type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">destination</td><td>Destination of the copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator to the beginning of the range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator to the end of the range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>Boolean mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the destination. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b54f2b5f17c2054f99e03c7c4614558"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int magrathea::Vectorizer::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the container. </p>
<p>Returns the current number of elements. This function is required by the vectorization mechanism. </p>
<dl class="section return"><dt>Returns</dt><dd>Copy of the size. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>This function should be overloaded by derived classes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af46ebf417fa856107cb9b84db9939f76"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void magrathea::Vectorizer::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the data type. </p>
<p>Returns a copy of the default value of the data type. </p>
<dl class="section return"><dt>Returns</dt><dd>Copy of the default value of the data type. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>This function should be overloaded by derived classes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/data/home/mbreton/magrathea_pathfinder/src/magrathea/<a class="el" href="vectorizer_8h_source.html">vectorizer.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 6 2021 17:41:42 for MAGRATHEA/PATHFINDER by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
