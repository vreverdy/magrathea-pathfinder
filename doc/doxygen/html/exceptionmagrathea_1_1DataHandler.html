<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>MAGRATHEA/PATHFINDER: magrathea::DataHandler Exception Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MAGRATHEA/PATHFINDER
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemagrathea.html">magrathea</a></li><li class="navelem"><a class="el" href="exceptionmagrathea_1_1DataHandler.html">DataHandler</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="exceptionmagrathea_1_1DataHandler-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">magrathea::DataHandler Exception Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Set of basic operations on binary data related to IO.  
 <a href="exceptionmagrathea_1_1DataHandler.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="datahandler_8h_source.html">datahandler.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Utilities</div></td></tr>
<tr class="memitem:a03a3af0a1f2adce31cd189191a420ac0"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a03a3af0a1f2adce31cd189191a420ac0"><td class="memTemplItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a03a3af0a1f2adce31cd189191a420ac0">array</a> (const Type &amp;)</td></tr>
<tr class="memdesc:a03a3af0a1f2adce31cd189191a420ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is not an array.  <a href="#a03a3af0a1f2adce31cd189191a420ac0"></a><br/></td></tr>
<tr class="separator:a03a3af0a1f2adce31cd189191a420ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d06cd95b4986d4760c6650b1642b60"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::size_t Size&gt; </td></tr>
<tr class="memitem:ab9d06cd95b4986d4760c6650b1642b60"><td class="memTemplItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#ab9d06cd95b4986d4760c6650b1642b60">array</a> (const std::array&lt; Type, Size &gt; &amp;)</td></tr>
<tr class="memdesc:ab9d06cd95b4986d4760c6650b1642b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is an array.  <a href="#ab9d06cd95b4986d4760c6650b1642b60"></a><br/></td></tr>
<tr class="separator:ab9d06cd95b4986d4760c6650b1642b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c596c3e2059535c1649654fe8a7aa0"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a40c596c3e2059535c1649654fe8a7aa0"><td class="memTemplItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a40c596c3e2059535c1649654fe8a7aa0">tuple</a> (const Type &amp;)</td></tr>
<tr class="memdesc:a40c596c3e2059535c1649654fe8a7aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is not a tuple.  <a href="#a40c596c3e2059535c1649654fe8a7aa0"></a><br/></td></tr>
<tr class="separator:a40c596c3e2059535c1649654fe8a7aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2249708da73286fe5f5a695ed202fa8c"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a2249708da73286fe5f5a695ed202fa8c"><td class="memTemplItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a2249708da73286fe5f5a695ed202fa8c">tuple</a> (const std::tuple&lt; Types...&gt; &amp;)</td></tr>
<tr class="memdesc:a2249708da73286fe5f5a695ed202fa8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a tuple.  <a href="#a2249708da73286fe5f5a695ed202fa8c"></a><br/></td></tr>
<tr class="separator:a2249708da73286fe5f5a695ed202fa8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Size</div></td></tr>
<tr class="memitem:ac4e7131096c0eeb8f86b6d017ed1edb2"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ac4e7131096c0eeb8f86b6d017ed1edb2"><td class="memTemplItemLeft" align="right" valign="top">static constexpr unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#ac4e7131096c0eeb8f86b6d017ed1edb2">size</a> ()</td></tr>
<tr class="memdesc:ac4e7131096c0eeb8f86b6d017ed1edb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements of several types.  <a href="#ac4e7131096c0eeb8f86b6d017ed1edb2"></a><br/></td></tr>
<tr class="separator:ac4e7131096c0eeb8f86b6d017ed1edb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e1fde9798b019bc5b033e2e17fa7db"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a46e1fde9798b019bc5b033e2e17fa7db">size</a> (const std::tuple&lt;&gt; &amp;)</td></tr>
<tr class="memdesc:a46e1fde9798b019bc5b033e2e17fa7db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements of an empty tuple.  <a href="#a46e1fde9798b019bc5b033e2e17fa7db"></a><br/></td></tr>
<tr class="separator:a46e1fde9798b019bc5b033e2e17fa7db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c18351676d2ac685b22524986bba92"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:af8c18351676d2ac685b22524986bba92"><td class="memTemplItemLeft" align="right" valign="top">static constexpr unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#af8c18351676d2ac685b22524986bba92">size</a> (const Type &amp;variable)</td></tr>
<tr class="memdesc:af8c18351676d2ac685b22524986bba92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements of a single variable.  <a href="#af8c18351676d2ac685b22524986bba92"></a><br/></td></tr>
<tr class="separator:af8c18351676d2ac685b22524986bba92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729d47a64d97ca03141eed087a0568d1"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename... Types&gt; </td></tr>
<tr class="memitem:a729d47a64d97ca03141eed087a0568d1"><td class="memTemplItemLeft" align="right" valign="top">static constexpr unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a729d47a64d97ca03141eed087a0568d1">size</a> (const Type &amp;variable, const Types &amp;...variables)</td></tr>
<tr class="memdesc:a729d47a64d97ca03141eed087a0568d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements of several variables.  <a href="#a729d47a64d97ca03141eed087a0568d1"></a><br/></td></tr>
<tr class="separator:a729d47a64d97ca03141eed087a0568d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6e50e89fe939e797450f8428dc40dc"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::size_t Size&gt; </td></tr>
<tr class="memitem:aeb6e50e89fe939e797450f8428dc40dc"><td class="memTemplItemLeft" align="right" valign="top">static constexpr unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#aeb6e50e89fe939e797450f8428dc40dc">size</a> (const std::array&lt; Type, Size &gt; &amp;container)</td></tr>
<tr class="memdesc:aeb6e50e89fe939e797450f8428dc40dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements of an array.  <a href="#aeb6e50e89fe939e797450f8428dc40dc"></a><br/></td></tr>
<tr class="separator:aeb6e50e89fe939e797450f8428dc40dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe440e8dde8a25b9bdfbb64dbb2c26db"><td class="memTemplParams" colspan="2">template&lt;unsigned int Current = 0, typename... Types&gt; </td></tr>
<tr class="memitem:abe440e8dde8a25b9bdfbb64dbb2c26db"><td class="memTemplItemLeft" align="right" valign="top">static constexpr unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#abe440e8dde8a25b9bdfbb64dbb2c26db">size</a> (const std::tuple&lt; Types...&gt; &amp;container)</td></tr>
<tr class="memdesc:abe440e8dde8a25b9bdfbb64dbb2c26db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements of a tuple.  <a href="#abe440e8dde8a25b9bdfbb64dbb2c26db"></a><br/></td></tr>
<tr class="separator:abe440e8dde8a25b9bdfbb64dbb2c26db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae024501895c9baf0b3fee0b73f53405a"><td class="memItemLeft" align="right" valign="top">static unsigned long long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#ae024501895c9baf0b3fee0b73f53405a">rsize</a> (const std::nullptr_t=nullptr, const std::nullptr_t=nullptr)</td></tr>
<tr class="memdesc:ae024501895c9baf0b3fee0b73f53405a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements of an empty range.  <a href="#ae024501895c9baf0b3fee0b73f53405a"></a><br/></td></tr>
<tr class="separator:ae024501895c9baf0b3fee0b73f53405a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453860a6574a579ae466ea72039b3946"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a453860a6574a579ae466ea72039b3946"><td class="memTemplItemLeft" align="right" valign="top">static unsigned long long int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a453860a6574a579ae466ea72039b3946">rsize</a> (const Type *const first, const Type *const last)</td></tr>
<tr class="memdesc:a453860a6574a579ae466ea72039b3946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements of a range between pointers.  <a href="#a453860a6574a579ae466ea72039b3946"></a><br/></td></tr>
<tr class="separator:a453860a6574a579ae466ea72039b3946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e965f35cd0f3950c21292f440f9da9f"><td class="memTemplParams" colspan="2">template&lt;typename Type , class  = typename std::enable_if&lt;!std::is_pointer&lt;Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a5e965f35cd0f3950c21292f440f9da9f"><td class="memTemplItemLeft" align="right" valign="top">static unsigned long long int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a5e965f35cd0f3950c21292f440f9da9f">rsize</a> (const Type &amp;first, const Type &amp;last, typename std::iterator_traits&lt; Type &gt;::iterator_category *=nullptr)</td></tr>
<tr class="memdesc:a5e965f35cd0f3950c21292f440f9da9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements of a range between iterators.  <a href="#a5e965f35cd0f3950c21292f440f9da9f"></a><br/></td></tr>
<tr class="separator:a5e965f35cd0f3950c21292f440f9da9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Bytesize</div></td></tr>
<tr class="memitem:a9453a2836ff2573bc80e11f1de0cebe2"><td class="memTemplParams" colspan="2">template&lt;typename Type  = void&gt; </td></tr>
<tr class="memitem:a9453a2836ff2573bc80e11f1de0cebe2"><td class="memTemplItemLeft" align="right" valign="top">static constexpr unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a9453a2836ff2573bc80e11f1de0cebe2">bytesize</a> (const std::nullptr_t=nullptr)</td></tr>
<tr class="memdesc:a9453a2836ff2573bc80e11f1de0cebe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size in bytes of a single type.  <a href="#a9453a2836ff2573bc80e11f1de0cebe2"></a><br/></td></tr>
<tr class="separator:a9453a2836ff2573bc80e11f1de0cebe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb38de93a744c640d2642c53a01770d6"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename... Types, class  = typename std::enable_if&lt;sizeof...(Types) != 0&gt;::type&gt; </td></tr>
<tr class="memitem:afb38de93a744c640d2642c53a01770d6"><td class="memTemplItemLeft" align="right" valign="top">static constexpr unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#afb38de93a744c640d2642c53a01770d6">bytesize</a> ()</td></tr>
<tr class="memdesc:afb38de93a744c640d2642c53a01770d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size in bytes of a single type.  <a href="#afb38de93a744c640d2642c53a01770d6"></a><br/></td></tr>
<tr class="separator:afb38de93a744c640d2642c53a01770d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a123543b345a2b8933a7ef121e48d7"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a91a123543b345a2b8933a7ef121e48d7">bytesize</a> (const std::tuple&lt;&gt; &amp;)</td></tr>
<tr class="memdesc:a91a123543b345a2b8933a7ef121e48d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size in bytes of an empty tuple.  <a href="#a91a123543b345a2b8933a7ef121e48d7"></a><br/></td></tr>
<tr class="separator:a91a123543b345a2b8933a7ef121e48d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005235ea08efd9713579f41791145f79"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a005235ea08efd9713579f41791145f79"><td class="memTemplItemLeft" align="right" valign="top">static constexpr unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a005235ea08efd9713579f41791145f79">bytesize</a> (const Type &amp;variable)</td></tr>
<tr class="memdesc:a005235ea08efd9713579f41791145f79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size in bytes of a single variable.  <a href="#a005235ea08efd9713579f41791145f79"></a><br/></td></tr>
<tr class="separator:a005235ea08efd9713579f41791145f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab076f5fed2b6c72e027aa4d8f9bd511"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename... Types&gt; </td></tr>
<tr class="memitem:aab076f5fed2b6c72e027aa4d8f9bd511"><td class="memTemplItemLeft" align="right" valign="top">static constexpr unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#aab076f5fed2b6c72e027aa4d8f9bd511">bytesize</a> (const Type &amp;variable, const Types &amp;...variables)</td></tr>
<tr class="memdesc:aab076f5fed2b6c72e027aa4d8f9bd511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size in bytes of several variables.  <a href="#aab076f5fed2b6c72e027aa4d8f9bd511"></a><br/></td></tr>
<tr class="separator:aab076f5fed2b6c72e027aa4d8f9bd511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6707784777d7bf711da488edff8a084e"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::size_t Size&gt; </td></tr>
<tr class="memitem:a6707784777d7bf711da488edff8a084e"><td class="memTemplItemLeft" align="right" valign="top">static constexpr unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a6707784777d7bf711da488edff8a084e">bytesize</a> (const std::array&lt; Type, Size &gt; &amp;container)</td></tr>
<tr class="memdesc:a6707784777d7bf711da488edff8a084e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size in bytes of an array.  <a href="#a6707784777d7bf711da488edff8a084e"></a><br/></td></tr>
<tr class="separator:a6707784777d7bf711da488edff8a084e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ceabc79d0ed2e208614e77672b1a10"><td class="memTemplParams" colspan="2">template&lt;unsigned int Current = 0, typename... Types&gt; </td></tr>
<tr class="memitem:aa8ceabc79d0ed2e208614e77672b1a10"><td class="memTemplItemLeft" align="right" valign="top">static constexpr unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#aa8ceabc79d0ed2e208614e77672b1a10">bytesize</a> (const std::tuple&lt; Types...&gt; &amp;container)</td></tr>
<tr class="memdesc:aa8ceabc79d0ed2e208614e77672b1a10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size in bytes of a tuple.  <a href="#aa8ceabc79d0ed2e208614e77672b1a10"></a><br/></td></tr>
<tr class="separator:aa8ceabc79d0ed2e208614e77672b1a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01a7da121ecba94a7bdc81fff5be3d5"><td class="memItemLeft" align="right" valign="top">static unsigned long long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#ae01a7da121ecba94a7bdc81fff5be3d5">rbytesize</a> (const std::nullptr_t=nullptr, const std::nullptr_t=nullptr)</td></tr>
<tr class="memdesc:ae01a7da121ecba94a7bdc81fff5be3d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size in bytes of an empty range.  <a href="#ae01a7da121ecba94a7bdc81fff5be3d5"></a><br/></td></tr>
<tr class="separator:ae01a7da121ecba94a7bdc81fff5be3d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3bc23ee6136da25ec8d15bc875298cb"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:ae3bc23ee6136da25ec8d15bc875298cb"><td class="memTemplItemLeft" align="right" valign="top">static unsigned long long int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#ae3bc23ee6136da25ec8d15bc875298cb">rbytesize</a> (const Type *const first, const Type *const last)</td></tr>
<tr class="memdesc:ae3bc23ee6136da25ec8d15bc875298cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size in bytes of a range between pointers.  <a href="#ae3bc23ee6136da25ec8d15bc875298cb"></a><br/></td></tr>
<tr class="separator:ae3bc23ee6136da25ec8d15bc875298cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e7e977cac2277aa42a2fa52f84366a6"><td class="memTemplParams" colspan="2">template&lt;typename Type , class  = typename std::enable_if&lt;!std::is_pointer&lt;Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a2e7e977cac2277aa42a2fa52f84366a6"><td class="memTemplItemLeft" align="right" valign="top">static unsigned long long int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a2e7e977cac2277aa42a2fa52f84366a6">rbytesize</a> (const Type &amp;first, const Type &amp;last, typename std::iterator_traits&lt; Type &gt;::iterator_category *=nullptr)</td></tr>
<tr class="memdesc:a2e7e977cac2277aa42a2fa52f84366a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size in bytes of a range between iterators.  <a href="#a2e7e977cac2277aa42a2fa52f84366a6"></a><br/></td></tr>
<tr class="separator:a2e7e977cac2277aa42a2fa52f84366a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Byteswap</div></td></tr>
<tr class="memitem:a2042e91ebc502db3edcf5256c0294c5f"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap, typename... Types, class  = typename std::enable_if&lt;!Byteswap&gt;::type&gt; </td></tr>
<tr class="memitem:a2042e91ebc502db3edcf5256c0294c5f"><td class="memTemplItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a2042e91ebc502db3edcf5256c0294c5f">byteswap</a> (const Types &amp;...)</td></tr>
<tr class="memdesc:a2042e91ebc502db3edcf5256c0294c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do not swap bytes.  <a href="#a2042e91ebc502db3edcf5256c0294c5f"></a><br/></td></tr>
<tr class="separator:a2042e91ebc502db3edcf5256c0294c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab69b0bf24969449ee0b986f2a19139"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap, typename... Types, class  = typename std::enable_if&lt;!Byteswap&gt;::type&gt; </td></tr>
<tr class="memitem:a1ab69b0bf24969449ee0b986f2a19139"><td class="memTemplItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a1ab69b0bf24969449ee0b986f2a19139">rbyteswap</a> (const Types &amp;...)</td></tr>
<tr class="memdesc:a1ab69b0bf24969449ee0b986f2a19139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do not swap bytes of a range.  <a href="#a1ab69b0bf24969449ee0b986f2a19139"></a><br/></td></tr>
<tr class="separator:a1ab69b0bf24969449ee0b986f2a19139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d89163c7346d993b9a17368c76673d2"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = true, class  = typename std::enable_if&lt;Byteswap&gt;::type&gt; </td></tr>
<tr class="memitem:a4d89163c7346d993b9a17368c76673d2"><td class="memTemplItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a4d89163c7346d993b9a17368c76673d2">byteswap</a> ()</td></tr>
<tr class="memdesc:a4d89163c7346d993b9a17368c76673d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap bytes of nothing.  <a href="#a4d89163c7346d993b9a17368c76673d2"></a><br/></td></tr>
<tr class="separator:a4d89163c7346d993b9a17368c76673d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6338a9f2e899a72c9d28526a27b4d5"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = true, class  = typename std::enable_if&lt;Byteswap&gt;::type&gt; </td></tr>
<tr class="memitem:a5c6338a9f2e899a72c9d28526a27b4d5"><td class="memTemplItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a5c6338a9f2e899a72c9d28526a27b4d5">byteswap</a> (std::tuple&lt;&gt; &amp;)</td></tr>
<tr class="memdesc:a5c6338a9f2e899a72c9d28526a27b4d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap bytes of an empty tuple.  <a href="#a5c6338a9f2e899a72c9d28526a27b4d5"></a><br/></td></tr>
<tr class="separator:a5c6338a9f2e899a72c9d28526a27b4d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8345c4082a891fc086d1030fc74750c8"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = true, typename Type , class  = typename std::enable_if&lt;Byteswap&gt;::type&gt; </td></tr>
<tr class="memitem:a8345c4082a891fc086d1030fc74750c8"><td class="memTemplItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a8345c4082a891fc086d1030fc74750c8">byteswap</a> (Type &amp;variable)</td></tr>
<tr class="memdesc:a8345c4082a891fc086d1030fc74750c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap bytes of a single variable.  <a href="#a8345c4082a891fc086d1030fc74750c8"></a><br/></td></tr>
<tr class="separator:a8345c4082a891fc086d1030fc74750c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca66620abc29a4a2274a77426805f722"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = true, typename Type , typename... Types, class  = typename std::enable_if&lt;Byteswap&gt;::type&gt; </td></tr>
<tr class="memitem:aca66620abc29a4a2274a77426805f722"><td class="memTemplItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#aca66620abc29a4a2274a77426805f722">byteswap</a> (Type &amp;variable, Types &amp;...variables)</td></tr>
<tr class="memdesc:aca66620abc29a4a2274a77426805f722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap bytes of several variables.  <a href="#aca66620abc29a4a2274a77426805f722"></a><br/></td></tr>
<tr class="separator:aca66620abc29a4a2274a77426805f722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb1384e1306c02a233b474e5af34378"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = true, typename Type , std::size_t Size, class  = typename std::enable_if&lt;Byteswap&gt;::type&gt; </td></tr>
<tr class="memitem:a3fb1384e1306c02a233b474e5af34378"><td class="memTemplItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a3fb1384e1306c02a233b474e5af34378">byteswap</a> (std::array&lt; Type, Size &gt; &amp;container)</td></tr>
<tr class="memdesc:a3fb1384e1306c02a233b474e5af34378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap bytes of an array.  <a href="#a3fb1384e1306c02a233b474e5af34378"></a><br/></td></tr>
<tr class="separator:a3fb1384e1306c02a233b474e5af34378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d3d574a4edcc3cd4f86a5e63fe7472"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = true, unsigned int Current = 0, typename... Types, class  = typename std::enable_if&lt;Byteswap&gt;::type&gt; </td></tr>
<tr class="memitem:a46d3d574a4edcc3cd4f86a5e63fe7472"><td class="memTemplItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a46d3d574a4edcc3cd4f86a5e63fe7472">byteswap</a> (std::tuple&lt; Types...&gt; &amp;container)</td></tr>
<tr class="memdesc:a46d3d574a4edcc3cd4f86a5e63fe7472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap bytes of a tuple.  <a href="#a46d3d574a4edcc3cd4f86a5e63fe7472"></a><br/></td></tr>
<tr class="separator:a46d3d574a4edcc3cd4f86a5e63fe7472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177dfd5de3d487fe6324fac41c1f3871"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = true, class  = typename std::enable_if&lt;Byteswap&gt;::type&gt; </td></tr>
<tr class="memitem:a177dfd5de3d487fe6324fac41c1f3871"><td class="memTemplItemLeft" align="right" valign="top">static unsigned long long int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a177dfd5de3d487fe6324fac41c1f3871">rbyteswap</a> (const std::nullptr_t=nullptr, const std::nullptr_t=nullptr)</td></tr>
<tr class="memdesc:a177dfd5de3d487fe6324fac41c1f3871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap bytes of an empty range.  <a href="#a177dfd5de3d487fe6324fac41c1f3871"></a><br/></td></tr>
<tr class="separator:a177dfd5de3d487fe6324fac41c1f3871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f17ea461a0969ff4a6e44723c3bfd7"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = true, typename Type , class  = typename std::enable_if&lt;Byteswap&gt;::type&gt; </td></tr>
<tr class="memitem:a97f17ea461a0969ff4a6e44723c3bfd7"><td class="memTemplItemLeft" align="right" valign="top">static unsigned long long int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a97f17ea461a0969ff4a6e44723c3bfd7">rbyteswap</a> (Type *const first, Type *const last)</td></tr>
<tr class="memdesc:a97f17ea461a0969ff4a6e44723c3bfd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap bytes of a range between pointers.  <a href="#a97f17ea461a0969ff4a6e44723c3bfd7"></a><br/></td></tr>
<tr class="separator:a97f17ea461a0969ff4a6e44723c3bfd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c784af750a3869cd3f1d7c338c22e4e"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = true, typename Type , class  = typename std::enable_if&lt;(Byteswap) &amp;&amp; (!std::is_pointer&lt;Type&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:a0c784af750a3869cd3f1d7c338c22e4e"><td class="memTemplItemLeft" align="right" valign="top">static unsigned long long int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a0c784af750a3869cd3f1d7c338c22e4e">rbyteswap</a> (const Type &amp;first, const Type &amp;last, typename std::iterator_traits&lt; Type &gt;::iterator_category *=nullptr)</td></tr>
<tr class="memdesc:a0c784af750a3869cd3f1d7c338c22e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap bytes of a range between iterators.  <a href="#a0c784af750a3869cd3f1d7c338c22e4e"></a><br/></td></tr>
<tr class="separator:a0c784af750a3869cd3f1d7c338c22e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Write stream</div></td></tr>
<tr class="memitem:a39a75e50677e501aa45368fcd1a9072c"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false&gt; </td></tr>
<tr class="memitem:a39a75e50677e501aa45368fcd1a9072c"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a39a75e50677e501aa45368fcd1a9072c">write</a> (std::ostream &amp;stream)</td></tr>
<tr class="memdesc:a39a75e50677e501aa45368fcd1a9072c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write nothing to stream.  <a href="#a39a75e50677e501aa45368fcd1a9072c"></a><br/></td></tr>
<tr class="separator:a39a75e50677e501aa45368fcd1a9072c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac03218d9c590597427d31e8d7fe8820b"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false&gt; </td></tr>
<tr class="memitem:ac03218d9c590597427d31e8d7fe8820b"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#ac03218d9c590597427d31e8d7fe8820b">write</a> (std::ostream &amp;stream, const std::tuple&lt;&gt; &amp;)</td></tr>
<tr class="memdesc:ac03218d9c590597427d31e8d7fe8820b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an empty tuple to stream.  <a href="#ac03218d9c590597427d31e8d7fe8820b"></a><br/></td></tr>
<tr class="separator:ac03218d9c590597427d31e8d7fe8820b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921c83976ebf7a55119f25d9589a6d71"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false, typename Type &gt; </td></tr>
<tr class="memitem:a921c83976ebf7a55119f25d9589a6d71"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a921c83976ebf7a55119f25d9589a6d71">write</a> (std::ostream &amp;stream, const Type &amp;variable)</td></tr>
<tr class="memdesc:a921c83976ebf7a55119f25d9589a6d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a single variable to stream.  <a href="#a921c83976ebf7a55119f25d9589a6d71"></a><br/></td></tr>
<tr class="separator:a921c83976ebf7a55119f25d9589a6d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee67cc8c281a41a493d41a4a25f45bc9"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false, typename Type , typename... Types&gt; </td></tr>
<tr class="memitem:aee67cc8c281a41a493d41a4a25f45bc9"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#aee67cc8c281a41a493d41a4a25f45bc9">write</a> (std::ostream &amp;stream, const Type &amp;variable, const Types &amp;...variables)</td></tr>
<tr class="memdesc:aee67cc8c281a41a493d41a4a25f45bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write several variables to stream.  <a href="#aee67cc8c281a41a493d41a4a25f45bc9"></a><br/></td></tr>
<tr class="separator:aee67cc8c281a41a493d41a4a25f45bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab61e11c5cd55fa2652511507291435"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false, typename Type , std::size_t Size&gt; </td></tr>
<tr class="memitem:a1ab61e11c5cd55fa2652511507291435"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a1ab61e11c5cd55fa2652511507291435">write</a> (std::ostream &amp;stream, const std::array&lt; Type, Size &gt; &amp;container)</td></tr>
<tr class="memdesc:a1ab61e11c5cd55fa2652511507291435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an array to stream.  <a href="#a1ab61e11c5cd55fa2652511507291435"></a><br/></td></tr>
<tr class="separator:a1ab61e11c5cd55fa2652511507291435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8fa581985c2e97824bb610459a4189f"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false, unsigned int Current = 0, typename... Types&gt; </td></tr>
<tr class="memitem:ab8fa581985c2e97824bb610459a4189f"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#ab8fa581985c2e97824bb610459a4189f">write</a> (std::ostream &amp;stream, const std::tuple&lt; Types...&gt; &amp;container)</td></tr>
<tr class="memdesc:ab8fa581985c2e97824bb610459a4189f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a tuple to stream.  <a href="#ab8fa581985c2e97824bb610459a4189f"></a><br/></td></tr>
<tr class="separator:ab8fa581985c2e97824bb610459a4189f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a51db0939e9deba460b19b46f068c9"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false&gt; </td></tr>
<tr class="memitem:a89a51db0939e9deba460b19b46f068c9"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a89a51db0939e9deba460b19b46f068c9">rwrite</a> (std::ostream &amp;stream, const std::nullptr_t=nullptr, const std::nullptr_t=nullptr)</td></tr>
<tr class="memdesc:a89a51db0939e9deba460b19b46f068c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an empty range to stream.  <a href="#a89a51db0939e9deba460b19b46f068c9"></a><br/></td></tr>
<tr class="separator:a89a51db0939e9deba460b19b46f068c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a3828a7b517b518fdbae8bc0662053"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false, typename Type &gt; </td></tr>
<tr class="memitem:a31a3828a7b517b518fdbae8bc0662053"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a31a3828a7b517b518fdbae8bc0662053">rwrite</a> (std::ostream &amp;stream, const Type *const first, const Type *const last)</td></tr>
<tr class="memdesc:a31a3828a7b517b518fdbae8bc0662053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a range between pointers to stream.  <a href="#a31a3828a7b517b518fdbae8bc0662053"></a><br/></td></tr>
<tr class="separator:a31a3828a7b517b518fdbae8bc0662053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa317b2106da44890bd8743769a432852"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false, typename Type , class  = typename std::enable_if&lt;!std::is_pointer&lt;Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:aa317b2106da44890bd8743769a432852"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#aa317b2106da44890bd8743769a432852">rwrite</a> (std::ostream &amp;stream, const Type &amp;first, const Type &amp;last, typename std::iterator_traits&lt; Type &gt;::iterator_category *=nullptr)</td></tr>
<tr class="memdesc:aa317b2106da44890bd8743769a432852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a range between iterators to stream.  <a href="#aa317b2106da44890bd8743769a432852"></a><br/></td></tr>
<tr class="separator:aa317b2106da44890bd8743769a432852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Read stream</div></td></tr>
<tr class="memitem:ae34eaeb6faf631309cb9000316771377"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false&gt; </td></tr>
<tr class="memitem:ae34eaeb6faf631309cb9000316771377"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#ae34eaeb6faf631309cb9000316771377">read</a> (std::istream &amp;stream)</td></tr>
<tr class="memdesc:ae34eaeb6faf631309cb9000316771377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read nothing from stream.  <a href="#ae34eaeb6faf631309cb9000316771377"></a><br/></td></tr>
<tr class="separator:ae34eaeb6faf631309cb9000316771377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b2d2a3c03f6fae7ce3fc7c54e3808aa"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false&gt; </td></tr>
<tr class="memitem:a3b2d2a3c03f6fae7ce3fc7c54e3808aa"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a3b2d2a3c03f6fae7ce3fc7c54e3808aa">read</a> (std::istream &amp;stream, std::tuple&lt;&gt; &amp;)</td></tr>
<tr class="memdesc:a3b2d2a3c03f6fae7ce3fc7c54e3808aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an empty tuple from stream.  <a href="#a3b2d2a3c03f6fae7ce3fc7c54e3808aa"></a><br/></td></tr>
<tr class="separator:a3b2d2a3c03f6fae7ce3fc7c54e3808aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9ffe306dfa1cbc4dfc27d0bab1385f"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false, typename Type &gt; </td></tr>
<tr class="memitem:a8a9ffe306dfa1cbc4dfc27d0bab1385f"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a8a9ffe306dfa1cbc4dfc27d0bab1385f">read</a> (std::istream &amp;stream, Type &amp;variable)</td></tr>
<tr class="memdesc:a8a9ffe306dfa1cbc4dfc27d0bab1385f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single variable from stream.  <a href="#a8a9ffe306dfa1cbc4dfc27d0bab1385f"></a><br/></td></tr>
<tr class="separator:a8a9ffe306dfa1cbc4dfc27d0bab1385f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67649218acd759dde8b1d9617a36219f"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false, typename Type , typename... Types&gt; </td></tr>
<tr class="memitem:a67649218acd759dde8b1d9617a36219f"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a67649218acd759dde8b1d9617a36219f">read</a> (std::istream &amp;stream, Type &amp;variable, Types &amp;...variables)</td></tr>
<tr class="memdesc:a67649218acd759dde8b1d9617a36219f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read several variables from stream.  <a href="#a67649218acd759dde8b1d9617a36219f"></a><br/></td></tr>
<tr class="separator:a67649218acd759dde8b1d9617a36219f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf9d85128f5bccff6f9d764120cd49f"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false, typename Type , std::size_t Size&gt; </td></tr>
<tr class="memitem:a2bf9d85128f5bccff6f9d764120cd49f"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a2bf9d85128f5bccff6f9d764120cd49f">read</a> (std::istream &amp;stream, std::array&lt; Type, Size &gt; &amp;container)</td></tr>
<tr class="memdesc:a2bf9d85128f5bccff6f9d764120cd49f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an array from stream.  <a href="#a2bf9d85128f5bccff6f9d764120cd49f"></a><br/></td></tr>
<tr class="separator:a2bf9d85128f5bccff6f9d764120cd49f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b5efbb028f2464bfbe669707e57c8f"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false, unsigned int Current = 0, typename... Types&gt; </td></tr>
<tr class="memitem:ac1b5efbb028f2464bfbe669707e57c8f"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#ac1b5efbb028f2464bfbe669707e57c8f">read</a> (std::istream &amp;stream, std::tuple&lt; Types...&gt; &amp;container)</td></tr>
<tr class="memdesc:ac1b5efbb028f2464bfbe669707e57c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a tuple from stream.  <a href="#ac1b5efbb028f2464bfbe669707e57c8f"></a><br/></td></tr>
<tr class="separator:ac1b5efbb028f2464bfbe669707e57c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309a1e2e9fa64e1fa5bcae1dbd9b1f86"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false&gt; </td></tr>
<tr class="memitem:a309a1e2e9fa64e1fa5bcae1dbd9b1f86"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a309a1e2e9fa64e1fa5bcae1dbd9b1f86">rread</a> (std::istream &amp;stream, const std::nullptr_t=nullptr, const std::nullptr_t=nullptr)</td></tr>
<tr class="memdesc:a309a1e2e9fa64e1fa5bcae1dbd9b1f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an empty range from stream.  <a href="#a309a1e2e9fa64e1fa5bcae1dbd9b1f86"></a><br/></td></tr>
<tr class="separator:a309a1e2e9fa64e1fa5bcae1dbd9b1f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4dc7bdf1e1ae704aafb92a1c3fe10e"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false, typename Type &gt; </td></tr>
<tr class="memitem:a5e4dc7bdf1e1ae704aafb92a1c3fe10e"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a5e4dc7bdf1e1ae704aafb92a1c3fe10e">rread</a> (std::istream &amp;stream, Type *const first, Type *const last)</td></tr>
<tr class="memdesc:a5e4dc7bdf1e1ae704aafb92a1c3fe10e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a range between pointers from stream.  <a href="#a5e4dc7bdf1e1ae704aafb92a1c3fe10e"></a><br/></td></tr>
<tr class="separator:a5e4dc7bdf1e1ae704aafb92a1c3fe10e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1f5e10ee3ccfbde1b7a0f0cdd9bcf2"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false, typename Type , class  = typename std::enable_if&lt;!std::is_pointer&lt;Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a6a1f5e10ee3ccfbde1b7a0f0cdd9bcf2"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a6a1f5e10ee3ccfbde1b7a0f0cdd9bcf2">rread</a> (std::istream &amp;stream, const Type &amp;first, const Type &amp;last, typename std::iterator_traits&lt; Type &gt;::iterator_category *=nullptr)</td></tr>
<tr class="memdesc:a6a1f5e10ee3ccfbde1b7a0f0cdd9bcf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a range between iterators from stream.  <a href="#a6a1f5e10ee3ccfbde1b7a0f0cdd9bcf2"></a><br/></td></tr>
<tr class="separator:a6a1f5e10ee3ccfbde1b7a0f0cdd9bcf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Write buffer</div></td></tr>
<tr class="memitem:a536f2b5c4b87cd899177ee5397df87b1"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false&gt; </td></tr>
<tr class="memitem:a536f2b5c4b87cd899177ee5397df87b1"><td class="memTemplItemLeft" align="right" valign="top">static char *&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a536f2b5c4b87cd899177ee5397df87b1">write</a> (char *&amp;buffer)</td></tr>
<tr class="memdesc:a536f2b5c4b87cd899177ee5397df87b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write nothing to buffer.  <a href="#a536f2b5c4b87cd899177ee5397df87b1"></a><br/></td></tr>
<tr class="separator:a536f2b5c4b87cd899177ee5397df87b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40bb3b3f12dbbfb56f0ae4949ab775dc"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false&gt; </td></tr>
<tr class="memitem:a40bb3b3f12dbbfb56f0ae4949ab775dc"><td class="memTemplItemLeft" align="right" valign="top">static char *&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a40bb3b3f12dbbfb56f0ae4949ab775dc">write</a> (char *&amp;buffer, const std::tuple&lt;&gt; &amp;)</td></tr>
<tr class="memdesc:a40bb3b3f12dbbfb56f0ae4949ab775dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an empty tuple to buffer.  <a href="#a40bb3b3f12dbbfb56f0ae4949ab775dc"></a><br/></td></tr>
<tr class="separator:a40bb3b3f12dbbfb56f0ae4949ab775dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f7ac2d71d0a6e12b9142f0164e5010"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false, typename Type &gt; </td></tr>
<tr class="memitem:a50f7ac2d71d0a6e12b9142f0164e5010"><td class="memTemplItemLeft" align="right" valign="top">static char *&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a50f7ac2d71d0a6e12b9142f0164e5010">write</a> (char *&amp;buffer, const Type &amp;variable)</td></tr>
<tr class="memdesc:a50f7ac2d71d0a6e12b9142f0164e5010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a single variable to buffer.  <a href="#a50f7ac2d71d0a6e12b9142f0164e5010"></a><br/></td></tr>
<tr class="separator:a50f7ac2d71d0a6e12b9142f0164e5010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa5fea125d9fc30fb1ead5d96a73b11"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false, typename Type , typename... Types&gt; </td></tr>
<tr class="memitem:abfa5fea125d9fc30fb1ead5d96a73b11"><td class="memTemplItemLeft" align="right" valign="top">static char *&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#abfa5fea125d9fc30fb1ead5d96a73b11">write</a> (char *&amp;buffer, const Type &amp;variable, const Types &amp;...variables)</td></tr>
<tr class="memdesc:abfa5fea125d9fc30fb1ead5d96a73b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write several variables to buffer.  <a href="#abfa5fea125d9fc30fb1ead5d96a73b11"></a><br/></td></tr>
<tr class="separator:abfa5fea125d9fc30fb1ead5d96a73b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc8c73ee5a6027286662b816435f953"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false, typename Type , std::size_t Size&gt; </td></tr>
<tr class="memitem:aedc8c73ee5a6027286662b816435f953"><td class="memTemplItemLeft" align="right" valign="top">static char *&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#aedc8c73ee5a6027286662b816435f953">write</a> (char *&amp;buffer, const std::array&lt; Type, Size &gt; &amp;container)</td></tr>
<tr class="memdesc:aedc8c73ee5a6027286662b816435f953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an array to buffer.  <a href="#aedc8c73ee5a6027286662b816435f953"></a><br/></td></tr>
<tr class="separator:aedc8c73ee5a6027286662b816435f953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade92542ca2ae7dac44c5b573aaaea63a"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false, unsigned int Current = 0, typename... Types&gt; </td></tr>
<tr class="memitem:ade92542ca2ae7dac44c5b573aaaea63a"><td class="memTemplItemLeft" align="right" valign="top">static char *&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#ade92542ca2ae7dac44c5b573aaaea63a">write</a> (char *&amp;buffer, const std::tuple&lt; Types...&gt; &amp;container)</td></tr>
<tr class="memdesc:ade92542ca2ae7dac44c5b573aaaea63a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a tuple to buffer.  <a href="#ade92542ca2ae7dac44c5b573aaaea63a"></a><br/></td></tr>
<tr class="separator:ade92542ca2ae7dac44c5b573aaaea63a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fef7472281e81fbdca7a42a92b36fe9"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false&gt; </td></tr>
<tr class="memitem:a2fef7472281e81fbdca7a42a92b36fe9"><td class="memTemplItemLeft" align="right" valign="top">static char *&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a2fef7472281e81fbdca7a42a92b36fe9">rwrite</a> (char *&amp;buffer, const std::nullptr_t=nullptr, const std::nullptr_t=nullptr)</td></tr>
<tr class="memdesc:a2fef7472281e81fbdca7a42a92b36fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an empty range to buffer.  <a href="#a2fef7472281e81fbdca7a42a92b36fe9"></a><br/></td></tr>
<tr class="separator:a2fef7472281e81fbdca7a42a92b36fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac43856b9e64071b14be4be469381258f"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false, typename Type &gt; </td></tr>
<tr class="memitem:ac43856b9e64071b14be4be469381258f"><td class="memTemplItemLeft" align="right" valign="top">static char *&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#ac43856b9e64071b14be4be469381258f">rwrite</a> (char *&amp;buffer, const Type *const first, const Type *const last)</td></tr>
<tr class="memdesc:ac43856b9e64071b14be4be469381258f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a range between pointers to buffer.  <a href="#ac43856b9e64071b14be4be469381258f"></a><br/></td></tr>
<tr class="separator:ac43856b9e64071b14be4be469381258f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c2ce2134d220930333c6f6c2a7e2a73"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false, typename Type , class  = typename std::enable_if&lt;!std::is_pointer&lt;Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a5c2ce2134d220930333c6f6c2a7e2a73"><td class="memTemplItemLeft" align="right" valign="top">static char *&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a5c2ce2134d220930333c6f6c2a7e2a73">rwrite</a> (char *&amp;buffer, const Type &amp;first, const Type &amp;last, typename std::iterator_traits&lt; Type &gt;::iterator_category *=nullptr)</td></tr>
<tr class="memdesc:a5c2ce2134d220930333c6f6c2a7e2a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a range between iterators to buffer.  <a href="#a5c2ce2134d220930333c6f6c2a7e2a73"></a><br/></td></tr>
<tr class="separator:a5c2ce2134d220930333c6f6c2a7e2a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Read buffer</div></td></tr>
<tr class="memitem:abb1758c0b2f72e48f5ef7db95b016ccf"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false&gt; </td></tr>
<tr class="memitem:abb1758c0b2f72e48f5ef7db95b016ccf"><td class="memTemplItemLeft" align="right" valign="top">static char *&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#abb1758c0b2f72e48f5ef7db95b016ccf">read</a> (char *&amp;buffer)</td></tr>
<tr class="memdesc:abb1758c0b2f72e48f5ef7db95b016ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read nothing from buffer.  <a href="#abb1758c0b2f72e48f5ef7db95b016ccf"></a><br/></td></tr>
<tr class="separator:abb1758c0b2f72e48f5ef7db95b016ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb8e4a637b6f4c3c798b1b94e568007"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false&gt; </td></tr>
<tr class="memitem:a4fb8e4a637b6f4c3c798b1b94e568007"><td class="memTemplItemLeft" align="right" valign="top">static char *&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a4fb8e4a637b6f4c3c798b1b94e568007">read</a> (char *&amp;buffer, std::tuple&lt;&gt; &amp;)</td></tr>
<tr class="memdesc:a4fb8e4a637b6f4c3c798b1b94e568007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an empty tuple from buffer.  <a href="#a4fb8e4a637b6f4c3c798b1b94e568007"></a><br/></td></tr>
<tr class="separator:a4fb8e4a637b6f4c3c798b1b94e568007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8fe6c9d3f4a56d178898ba64cdc93f8"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false, typename Type &gt; </td></tr>
<tr class="memitem:aa8fe6c9d3f4a56d178898ba64cdc93f8"><td class="memTemplItemLeft" align="right" valign="top">static char *&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#aa8fe6c9d3f4a56d178898ba64cdc93f8">read</a> (char *&amp;buffer, Type &amp;variable)</td></tr>
<tr class="memdesc:aa8fe6c9d3f4a56d178898ba64cdc93f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single variable from buffer.  <a href="#aa8fe6c9d3f4a56d178898ba64cdc93f8"></a><br/></td></tr>
<tr class="separator:aa8fe6c9d3f4a56d178898ba64cdc93f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73602c0c41147651f1ce8c7cbc206f6"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false, typename Type , typename... Types&gt; </td></tr>
<tr class="memitem:ae73602c0c41147651f1ce8c7cbc206f6"><td class="memTemplItemLeft" align="right" valign="top">static char *&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#ae73602c0c41147651f1ce8c7cbc206f6">read</a> (char *&amp;buffer, Type &amp;variable, Types &amp;...variables)</td></tr>
<tr class="memdesc:ae73602c0c41147651f1ce8c7cbc206f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read several variables from buffer.  <a href="#ae73602c0c41147651f1ce8c7cbc206f6"></a><br/></td></tr>
<tr class="separator:ae73602c0c41147651f1ce8c7cbc206f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8fa8651ee32050d8eb6eaf435db2c7"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false, typename Type , std::size_t Size&gt; </td></tr>
<tr class="memitem:a6d8fa8651ee32050d8eb6eaf435db2c7"><td class="memTemplItemLeft" align="right" valign="top">static char *&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a6d8fa8651ee32050d8eb6eaf435db2c7">read</a> (char *&amp;buffer, std::array&lt; Type, Size &gt; &amp;container)</td></tr>
<tr class="memdesc:a6d8fa8651ee32050d8eb6eaf435db2c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an array from buffer.  <a href="#a6d8fa8651ee32050d8eb6eaf435db2c7"></a><br/></td></tr>
<tr class="separator:a6d8fa8651ee32050d8eb6eaf435db2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f7805b4e77bb9ab70c5d2f2bee08f3"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false, unsigned int Current = 0, typename... Types&gt; </td></tr>
<tr class="memitem:a21f7805b4e77bb9ab70c5d2f2bee08f3"><td class="memTemplItemLeft" align="right" valign="top">static char *&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a21f7805b4e77bb9ab70c5d2f2bee08f3">read</a> (char *&amp;buffer, std::tuple&lt; Types...&gt; &amp;container)</td></tr>
<tr class="memdesc:a21f7805b4e77bb9ab70c5d2f2bee08f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a tuple from buffer.  <a href="#a21f7805b4e77bb9ab70c5d2f2bee08f3"></a><br/></td></tr>
<tr class="separator:a21f7805b4e77bb9ab70c5d2f2bee08f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd7431815561c8616e157b6789afff0"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false&gt; </td></tr>
<tr class="memitem:acdd7431815561c8616e157b6789afff0"><td class="memTemplItemLeft" align="right" valign="top">static char *&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#acdd7431815561c8616e157b6789afff0">rread</a> (char *&amp;buffer, const std::nullptr_t=nullptr, const std::nullptr_t=nullptr)</td></tr>
<tr class="memdesc:acdd7431815561c8616e157b6789afff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an empty range from buffer.  <a href="#acdd7431815561c8616e157b6789afff0"></a><br/></td></tr>
<tr class="separator:acdd7431815561c8616e157b6789afff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6728414b1976483a9d82af54588e62b9"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false, typename Type &gt; </td></tr>
<tr class="memitem:a6728414b1976483a9d82af54588e62b9"><td class="memTemplItemLeft" align="right" valign="top">static char *&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a6728414b1976483a9d82af54588e62b9">rread</a> (char *&amp;buffer, Type *const first, Type *const last)</td></tr>
<tr class="memdesc:a6728414b1976483a9d82af54588e62b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a range between pointers from buffer.  <a href="#a6728414b1976483a9d82af54588e62b9"></a><br/></td></tr>
<tr class="separator:a6728414b1976483a9d82af54588e62b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef7aa4fc02e64ac7c2d02b413a6dffd"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false, typename Type , class  = typename std::enable_if&lt;!std::is_pointer&lt;Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:aaef7aa4fc02e64ac7c2d02b413a6dffd"><td class="memTemplItemLeft" align="right" valign="top">static char *&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#aaef7aa4fc02e64ac7c2d02b413a6dffd">rread</a> (char *&amp;buffer, const Type &amp;first, const Type &amp;last, typename std::iterator_traits&lt; Type &gt;::iterator_category *=nullptr)</td></tr>
<tr class="memdesc:aaef7aa4fc02e64ac7c2d02b413a6dffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a range between iterators from buffer.  <a href="#aaef7aa4fc02e64ac7c2d02b413a6dffd"></a><br/></td></tr>
<tr class="separator:aaef7aa4fc02e64ac7c2d02b413a6dffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Nullification</div></td></tr>
<tr class="memitem:a7958f101a7437fe5ada971be5eceef32"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a7958f101a7437fe5ada971be5eceef32">nullify</a> ()</td></tr>
<tr class="memdesc:a7958f101a7437fe5ada971be5eceef32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nullify nothing.  <a href="#a7958f101a7437fe5ada971be5eceef32"></a><br/></td></tr>
<tr class="separator:a7958f101a7437fe5ada971be5eceef32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0026082d808e1bba847e0abdb142d61"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#ad0026082d808e1bba847e0abdb142d61">nullify</a> (std::tuple&lt;&gt; &amp;)</td></tr>
<tr class="memdesc:ad0026082d808e1bba847e0abdb142d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nullify an empty tuple.  <a href="#ad0026082d808e1bba847e0abdb142d61"></a><br/></td></tr>
<tr class="separator:ad0026082d808e1bba847e0abdb142d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa0ca7b9d5b2659fd567df2ceab1f0e7"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:aaa0ca7b9d5b2659fd567df2ceab1f0e7"><td class="memTemplItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#aaa0ca7b9d5b2659fd567df2ceab1f0e7">nullify</a> (Type &amp;variable)</td></tr>
<tr class="memdesc:aaa0ca7b9d5b2659fd567df2ceab1f0e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nullify a single variable.  <a href="#aaa0ca7b9d5b2659fd567df2ceab1f0e7"></a><br/></td></tr>
<tr class="separator:aaa0ca7b9d5b2659fd567df2ceab1f0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f14c311ad2d5f0f6faaef4383db779"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename... Types&gt; </td></tr>
<tr class="memitem:ab7f14c311ad2d5f0f6faaef4383db779"><td class="memTemplItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#ab7f14c311ad2d5f0f6faaef4383db779">nullify</a> (Type &amp;variable, Types &amp;...variables)</td></tr>
<tr class="memdesc:ab7f14c311ad2d5f0f6faaef4383db779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nullify several variables.  <a href="#ab7f14c311ad2d5f0f6faaef4383db779"></a><br/></td></tr>
<tr class="separator:ab7f14c311ad2d5f0f6faaef4383db779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ed5c28c8d5eb5b66338af0e1018852"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::size_t Size&gt; </td></tr>
<tr class="memitem:a88ed5c28c8d5eb5b66338af0e1018852"><td class="memTemplItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a88ed5c28c8d5eb5b66338af0e1018852">nullify</a> (std::array&lt; Type, Size &gt; &amp;container)</td></tr>
<tr class="memdesc:a88ed5c28c8d5eb5b66338af0e1018852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nullify an array.  <a href="#a88ed5c28c8d5eb5b66338af0e1018852"></a><br/></td></tr>
<tr class="separator:a88ed5c28c8d5eb5b66338af0e1018852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e291616af2fba57c18aa231eefd333"><td class="memTemplParams" colspan="2">template&lt;unsigned int Current = 0, typename... Types&gt; </td></tr>
<tr class="memitem:a87e291616af2fba57c18aa231eefd333"><td class="memTemplItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a87e291616af2fba57c18aa231eefd333">nullify</a> (std::tuple&lt; Types...&gt; &amp;container)</td></tr>
<tr class="memdesc:a87e291616af2fba57c18aa231eefd333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nullify a tuple.  <a href="#a87e291616af2fba57c18aa231eefd333"></a><br/></td></tr>
<tr class="separator:a87e291616af2fba57c18aa231eefd333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb826ede36fd580ea709a19fc71a3e90"><td class="memItemLeft" align="right" valign="top">static unsigned long long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#abb826ede36fd580ea709a19fc71a3e90">rnullify</a> (const std::nullptr_t=nullptr, const std::nullptr_t=nullptr)</td></tr>
<tr class="memdesc:abb826ede36fd580ea709a19fc71a3e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nullify an empty range.  <a href="#abb826ede36fd580ea709a19fc71a3e90"></a><br/></td></tr>
<tr class="separator:abb826ede36fd580ea709a19fc71a3e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370472a1aadc46f879801bf1132ab26b"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a370472a1aadc46f879801bf1132ab26b"><td class="memTemplItemLeft" align="right" valign="top">static unsigned long long int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a370472a1aadc46f879801bf1132ab26b">rnullify</a> (Type *const first, Type *const last)</td></tr>
<tr class="memdesc:a370472a1aadc46f879801bf1132ab26b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nullify a range between pointers.  <a href="#a370472a1aadc46f879801bf1132ab26b"></a><br/></td></tr>
<tr class="separator:a370472a1aadc46f879801bf1132ab26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040f6e76e4af90f1e3b696172cfbe48a"><td class="memTemplParams" colspan="2">template&lt;typename Type , class  = typename std::enable_if&lt;!std::is_pointer&lt;Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a040f6e76e4af90f1e3b696172cfbe48a"><td class="memTemplItemLeft" align="right" valign="top">static unsigned long long int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a040f6e76e4af90f1e3b696172cfbe48a">rnullify</a> (const Type &amp;first, const Type &amp;last, typename std::iterator_traits&lt; Type &gt;::iterator_category *=nullptr)</td></tr>
<tr class="memdesc:a040f6e76e4af90f1e3b696172cfbe48a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nullify a range between iterators.  <a href="#a040f6e76e4af90f1e3b696172cfbe48a"></a><br/></td></tr>
<tr class="separator:a040f6e76e4af90f1e3b696172cfbe48a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Equalization</div></td></tr>
<tr class="memitem:a51a6cff6e8a684d22e368ff56ca72fea"><td class="memTemplParams" colspan="2">template&lt;typename Reference &gt; </td></tr>
<tr class="memitem:a51a6cff6e8a684d22e368ff56ca72fea"><td class="memTemplItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a51a6cff6e8a684d22e368ff56ca72fea">equalize</a> (const Reference &amp;reference)</td></tr>
<tr class="memdesc:a51a6cff6e8a684d22e368ff56ca72fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equalize nothing.  <a href="#a51a6cff6e8a684d22e368ff56ca72fea"></a><br/></td></tr>
<tr class="separator:a51a6cff6e8a684d22e368ff56ca72fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73254d7cfb56f9d49207670ce2f0bf46"><td class="memTemplParams" colspan="2">template&lt;typename Reference &gt; </td></tr>
<tr class="memitem:a73254d7cfb56f9d49207670ce2f0bf46"><td class="memTemplItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a73254d7cfb56f9d49207670ce2f0bf46">equalize</a> (const Reference &amp;reference, std::tuple&lt;&gt; &amp;)</td></tr>
<tr class="memdesc:a73254d7cfb56f9d49207670ce2f0bf46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equalize an empty tuple.  <a href="#a73254d7cfb56f9d49207670ce2f0bf46"></a><br/></td></tr>
<tr class="separator:a73254d7cfb56f9d49207670ce2f0bf46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21aa49476bfdea5e3e1eb6db89610b6f"><td class="memTemplParams" colspan="2">template&lt;typename Reference , typename Type &gt; </td></tr>
<tr class="memitem:a21aa49476bfdea5e3e1eb6db89610b6f"><td class="memTemplItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a21aa49476bfdea5e3e1eb6db89610b6f">equalize</a> (const Reference &amp;reference, Type &amp;variable)</td></tr>
<tr class="memdesc:a21aa49476bfdea5e3e1eb6db89610b6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equalize a single variable.  <a href="#a21aa49476bfdea5e3e1eb6db89610b6f"></a><br/></td></tr>
<tr class="separator:a21aa49476bfdea5e3e1eb6db89610b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30aa6d5b117ee5af179dba30b59025f"><td class="memTemplParams" colspan="2">template&lt;typename Reference , typename Type , typename... Types&gt; </td></tr>
<tr class="memitem:ac30aa6d5b117ee5af179dba30b59025f"><td class="memTemplItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#ac30aa6d5b117ee5af179dba30b59025f">equalize</a> (const Reference &amp;reference, Type &amp;variable, Types &amp;...variables)</td></tr>
<tr class="memdesc:ac30aa6d5b117ee5af179dba30b59025f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equalize several variables.  <a href="#ac30aa6d5b117ee5af179dba30b59025f"></a><br/></td></tr>
<tr class="separator:ac30aa6d5b117ee5af179dba30b59025f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91eaaf11ba2d7d2c56cb365b1f4fae05"><td class="memTemplParams" colspan="2">template&lt;typename Reference , typename Type , std::size_t Size&gt; </td></tr>
<tr class="memitem:a91eaaf11ba2d7d2c56cb365b1f4fae05"><td class="memTemplItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a91eaaf11ba2d7d2c56cb365b1f4fae05">equalize</a> (const Reference &amp;reference, std::array&lt; Type, Size &gt; &amp;container)</td></tr>
<tr class="memdesc:a91eaaf11ba2d7d2c56cb365b1f4fae05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equalize an array.  <a href="#a91eaaf11ba2d7d2c56cb365b1f4fae05"></a><br/></td></tr>
<tr class="separator:a91eaaf11ba2d7d2c56cb365b1f4fae05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac081445d6585ad93c1420826eeb923c7"><td class="memTemplParams" colspan="2">template&lt;unsigned int Current = 0, typename Reference , typename... Types&gt; </td></tr>
<tr class="memitem:ac081445d6585ad93c1420826eeb923c7"><td class="memTemplItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#ac081445d6585ad93c1420826eeb923c7">equalize</a> (const Reference &amp;reference, std::tuple&lt; Types...&gt; &amp;container)</td></tr>
<tr class="memdesc:ac081445d6585ad93c1420826eeb923c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equalize a tuple.  <a href="#ac081445d6585ad93c1420826eeb923c7"></a><br/></td></tr>
<tr class="separator:ac081445d6585ad93c1420826eeb923c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9f3ea4fce203ea1aca7b855397d76a"><td class="memTemplParams" colspan="2">template&lt;typename Reference &gt; </td></tr>
<tr class="memitem:afd9f3ea4fce203ea1aca7b855397d76a"><td class="memTemplItemLeft" align="right" valign="top">static unsigned long long int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#afd9f3ea4fce203ea1aca7b855397d76a">requalize</a> (const Reference &amp;reference, const std::nullptr_t=nullptr, const std::nullptr_t=nullptr)</td></tr>
<tr class="memdesc:afd9f3ea4fce203ea1aca7b855397d76a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equalize an empty range.  <a href="#afd9f3ea4fce203ea1aca7b855397d76a"></a><br/></td></tr>
<tr class="separator:afd9f3ea4fce203ea1aca7b855397d76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9782498c2008f965392c3d497461bcb"><td class="memTemplParams" colspan="2">template&lt;typename Reference , typename Type &gt; </td></tr>
<tr class="memitem:af9782498c2008f965392c3d497461bcb"><td class="memTemplItemLeft" align="right" valign="top">static unsigned long long int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#af9782498c2008f965392c3d497461bcb">requalize</a> (const Reference &amp;reference, Type *const first, Type *const last)</td></tr>
<tr class="memdesc:af9782498c2008f965392c3d497461bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equalize a range between pointers.  <a href="#af9782498c2008f965392c3d497461bcb"></a><br/></td></tr>
<tr class="separator:af9782498c2008f965392c3d497461bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199258bc8b5a5e25e696322722538bca"><td class="memTemplParams" colspan="2">template&lt;typename Reference , typename Type , class  = typename std::enable_if&lt;!std::is_pointer&lt;Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a199258bc8b5a5e25e696322722538bca"><td class="memTemplItemLeft" align="right" valign="top">static unsigned long long int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a199258bc8b5a5e25e696322722538bca">requalize</a> (const Reference &amp;reference, const Type &amp;first, const Type &amp;last, typename std::iterator_traits&lt; Type &gt;::iterator_category *=nullptr)</td></tr>
<tr class="memdesc:a199258bc8b5a5e25e696322722538bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equalize a range between iterators.  <a href="#a199258bc8b5a5e25e696322722538bca"></a><br/></td></tr>
<tr class="separator:a199258bc8b5a5e25e696322722538bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Hexification</div></td></tr>
<tr class="memitem:a2ced7c88930c8cb63f53ae8ccd7d8869"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false, bool Uppercase = false&gt; </td></tr>
<tr class="memitem:a2ced7c88930c8cb63f53ae8ccd7d8869"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a2ced7c88930c8cb63f53ae8ccd7d8869">hexify</a> ()</td></tr>
<tr class="memdesc:a2ced7c88930c8cb63f53ae8ccd7d8869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert nothing to a hexadecimal string.  <a href="#a2ced7c88930c8cb63f53ae8ccd7d8869"></a><br/></td></tr>
<tr class="separator:a2ced7c88930c8cb63f53ae8ccd7d8869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e509568af157f6b3fafaa6d7b77ee5d"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false, bool Uppercase = false&gt; </td></tr>
<tr class="memitem:a5e509568af157f6b3fafaa6d7b77ee5d"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a5e509568af157f6b3fafaa6d7b77ee5d">hexify</a> (const std::tuple&lt;&gt; &amp;)</td></tr>
<tr class="memdesc:a5e509568af157f6b3fafaa6d7b77ee5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an empty tuple to a hexadecimal string.  <a href="#a5e509568af157f6b3fafaa6d7b77ee5d"></a><br/></td></tr>
<tr class="separator:a5e509568af157f6b3fafaa6d7b77ee5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6a8e6e71817c4ff9f3e09ffd2440713"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false, bool Uppercase = false, typename Type &gt; </td></tr>
<tr class="memitem:af6a8e6e71817c4ff9f3e09ffd2440713"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#af6a8e6e71817c4ff9f3e09ffd2440713">hexify</a> (const Type &amp;variable)</td></tr>
<tr class="memdesc:af6a8e6e71817c4ff9f3e09ffd2440713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a single variable to a hexadecimal string.  <a href="#af6a8e6e71817c4ff9f3e09ffd2440713"></a><br/></td></tr>
<tr class="separator:af6a8e6e71817c4ff9f3e09ffd2440713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87cdcecdb302b79db66f8781d92d2a38"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false, bool Uppercase = false, typename Type , typename... Types&gt; </td></tr>
<tr class="memitem:a87cdcecdb302b79db66f8781d92d2a38"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a87cdcecdb302b79db66f8781d92d2a38">hexify</a> (const Type &amp;variable, const Types &amp;...variables)</td></tr>
<tr class="memdesc:a87cdcecdb302b79db66f8781d92d2a38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert several variables to a hexadecimal string.  <a href="#a87cdcecdb302b79db66f8781d92d2a38"></a><br/></td></tr>
<tr class="separator:a87cdcecdb302b79db66f8781d92d2a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537df36d100df807e95e9fe4297ce788"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false, bool Uppercase = false, typename Type , std::size_t Size&gt; </td></tr>
<tr class="memitem:a537df36d100df807e95e9fe4297ce788"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a537df36d100df807e95e9fe4297ce788">hexify</a> (const std::array&lt; Type, Size &gt; &amp;container)</td></tr>
<tr class="memdesc:a537df36d100df807e95e9fe4297ce788"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an array to a hexadecimal string.  <a href="#a537df36d100df807e95e9fe4297ce788"></a><br/></td></tr>
<tr class="separator:a537df36d100df807e95e9fe4297ce788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93de73e7027c2dee8564b1520f319d3a"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false, bool Uppercase = false, unsigned int Current = 0, typename... Types&gt; </td></tr>
<tr class="memitem:a93de73e7027c2dee8564b1520f319d3a"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a93de73e7027c2dee8564b1520f319d3a">hexify</a> (const std::tuple&lt; Types...&gt; &amp;container)</td></tr>
<tr class="memdesc:a93de73e7027c2dee8564b1520f319d3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a tuple to a hexadecimal string.  <a href="#a93de73e7027c2dee8564b1520f319d3a"></a><br/></td></tr>
<tr class="separator:a93de73e7027c2dee8564b1520f319d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7bf3950e2fb436e59e3ad8d22630601"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false, bool Uppercase = false&gt; </td></tr>
<tr class="memitem:ad7bf3950e2fb436e59e3ad8d22630601"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#ad7bf3950e2fb436e59e3ad8d22630601">rhexify</a> (const std::nullptr_t=nullptr, const std::nullptr_t=nullptr, const std::string &amp;separator=&quot; &quot;)</td></tr>
<tr class="memdesc:ad7bf3950e2fb436e59e3ad8d22630601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an empty range to a hexadecimal string.  <a href="#ad7bf3950e2fb436e59e3ad8d22630601"></a><br/></td></tr>
<tr class="separator:ad7bf3950e2fb436e59e3ad8d22630601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12d94dd9d65f7e5ff945d33312f5d28"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false, bool Uppercase = false, typename Type &gt; </td></tr>
<tr class="memitem:ae12d94dd9d65f7e5ff945d33312f5d28"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#ae12d94dd9d65f7e5ff945d33312f5d28">rhexify</a> (const Type *const first, const Type *const last, const std::string &amp;separator=&quot; &quot;)</td></tr>
<tr class="memdesc:ae12d94dd9d65f7e5ff945d33312f5d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a range between pointers to a hexadecimal string.  <a href="#ae12d94dd9d65f7e5ff945d33312f5d28"></a><br/></td></tr>
<tr class="separator:ae12d94dd9d65f7e5ff945d33312f5d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1f477485c16c5d5221288531453492"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false, bool Uppercase = false, typename Type , class  = typename std::enable_if&lt;!std::is_pointer&lt;Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a1e1f477485c16c5d5221288531453492"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a1e1f477485c16c5d5221288531453492">rhexify</a> (const Type &amp;first, const Type &amp;last, const std::string &amp;separator=&quot; &quot;, typename std::iterator_traits&lt; Type &gt;::iterator_category *=nullptr)</td></tr>
<tr class="memdesc:a1e1f477485c16c5d5221288531453492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a range between iterators to a hexadecimal string.  <a href="#a1e1f477485c16c5d5221288531453492"></a><br/></td></tr>
<tr class="separator:a1e1f477485c16c5d5221288531453492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Stringification</div></td></tr>
<tr class="memitem:aabe5421ff733fe6beebb8c738d1fee63"><td class="memTemplParams" colspan="2">template&lt;unsigned int Base = 10, char Leading = char()&gt; </td></tr>
<tr class="memitem:aabe5421ff733fe6beebb8c738d1fee63"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#aabe5421ff733fe6beebb8c738d1fee63">stringify</a> ()</td></tr>
<tr class="memdesc:aabe5421ff733fe6beebb8c738d1fee63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert nothing to a string.  <a href="#aabe5421ff733fe6beebb8c738d1fee63"></a><br/></td></tr>
<tr class="separator:aabe5421ff733fe6beebb8c738d1fee63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4ab445f48e1aa494a404e904c54a66"><td class="memTemplParams" colspan="2">template&lt;unsigned int Base = 10, char Leading = char()&gt; </td></tr>
<tr class="memitem:a7c4ab445f48e1aa494a404e904c54a66"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a7c4ab445f48e1aa494a404e904c54a66">stringify</a> (const std::tuple&lt;&gt; &amp;)</td></tr>
<tr class="memdesc:a7c4ab445f48e1aa494a404e904c54a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an empty tuple to a string.  <a href="#a7c4ab445f48e1aa494a404e904c54a66"></a><br/></td></tr>
<tr class="separator:a7c4ab445f48e1aa494a404e904c54a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd735cedf604372d2942820919a2b0c"><td class="memTemplParams" colspan="2">template&lt;unsigned int Base = 10, char Leading = char(), typename Type &gt; </td></tr>
<tr class="memitem:a2dd735cedf604372d2942820919a2b0c"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a2dd735cedf604372d2942820919a2b0c">stringify</a> (const Type &amp;variable)</td></tr>
<tr class="memdesc:a2dd735cedf604372d2942820919a2b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a single variable to a string.  <a href="#a2dd735cedf604372d2942820919a2b0c"></a><br/></td></tr>
<tr class="separator:a2dd735cedf604372d2942820919a2b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54ac4f7f22feb5b1e7361d321342746"><td class="memTemplParams" colspan="2">template&lt;unsigned int Base = 10, char Leading = char(), typename Type , typename... Types&gt; </td></tr>
<tr class="memitem:ab54ac4f7f22feb5b1e7361d321342746"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#ab54ac4f7f22feb5b1e7361d321342746">stringify</a> (const Type &amp;variable, const Types &amp;...variables)</td></tr>
<tr class="memdesc:ab54ac4f7f22feb5b1e7361d321342746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert several variables to a string.  <a href="#ab54ac4f7f22feb5b1e7361d321342746"></a><br/></td></tr>
<tr class="separator:ab54ac4f7f22feb5b1e7361d321342746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71fe2f753a75d7367c34bd035e7e3d62"><td class="memTemplParams" colspan="2">template&lt;unsigned int Base = 10, char Leading = char(), typename Type , std::size_t Size&gt; </td></tr>
<tr class="memitem:a71fe2f753a75d7367c34bd035e7e3d62"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a71fe2f753a75d7367c34bd035e7e3d62">stringify</a> (const std::array&lt; Type, Size &gt; &amp;container)</td></tr>
<tr class="memdesc:a71fe2f753a75d7367c34bd035e7e3d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an array to a string.  <a href="#a71fe2f753a75d7367c34bd035e7e3d62"></a><br/></td></tr>
<tr class="separator:a71fe2f753a75d7367c34bd035e7e3d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a172045642951acb95fb0a84595aa9e56"><td class="memTemplParams" colspan="2">template&lt;unsigned int Base = 10, char Leading = char(), unsigned int Current = 0, typename... Types&gt; </td></tr>
<tr class="memitem:a172045642951acb95fb0a84595aa9e56"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a172045642951acb95fb0a84595aa9e56">stringify</a> (const std::tuple&lt; Types...&gt; &amp;container)</td></tr>
<tr class="memdesc:a172045642951acb95fb0a84595aa9e56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a tuple to a string.  <a href="#a172045642951acb95fb0a84595aa9e56"></a><br/></td></tr>
<tr class="separator:a172045642951acb95fb0a84595aa9e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db434fc9459ef0f11890cef1e222ad7"><td class="memTemplParams" colspan="2">template&lt;unsigned int Base = 10, char Leading = char()&gt; </td></tr>
<tr class="memitem:a0db434fc9459ef0f11890cef1e222ad7"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a0db434fc9459ef0f11890cef1e222ad7">rstringify</a> (const std::nullptr_t=nullptr, const std::nullptr_t=nullptr, const std::string &amp;separator=&quot; &quot;)</td></tr>
<tr class="memdesc:a0db434fc9459ef0f11890cef1e222ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an empty range to a string.  <a href="#a0db434fc9459ef0f11890cef1e222ad7"></a><br/></td></tr>
<tr class="separator:a0db434fc9459ef0f11890cef1e222ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e7e01b71aa9f81babfbe16f623aa7b"><td class="memTemplParams" colspan="2">template&lt;unsigned int Base = 10, char Leading = char(), typename Type &gt; </td></tr>
<tr class="memitem:af9e7e01b71aa9f81babfbe16f623aa7b"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#af9e7e01b71aa9f81babfbe16f623aa7b">rstringify</a> (const Type *const first, const Type *const last, const std::string &amp;separator=&quot; &quot;)</td></tr>
<tr class="memdesc:af9e7e01b71aa9f81babfbe16f623aa7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a range between pointers to a string.  <a href="#af9e7e01b71aa9f81babfbe16f623aa7b"></a><br/></td></tr>
<tr class="separator:af9e7e01b71aa9f81babfbe16f623aa7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55cfb860edddeed639be96c6bb6a83f"><td class="memTemplParams" colspan="2">template&lt;unsigned int Base = 10, char Leading = char(), typename Type , class  = typename std::enable_if&lt;!std::is_pointer&lt;Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ac55cfb860edddeed639be96c6bb6a83f"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#ac55cfb860edddeed639be96c6bb6a83f">rstringify</a> (const Type &amp;first, const Type &amp;last, const std::string &amp;separator=&quot; &quot;, typename std::iterator_traits&lt; Type &gt;::iterator_category *=nullptr)</td></tr>
<tr class="memdesc:ac55cfb860edddeed639be96c6bb6a83f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a range between iterators to a string.  <a href="#ac55cfb860edddeed639be96c6bb6a83f"></a><br/></td></tr>
<tr class="separator:ac55cfb860edddeed639be96c6bb6a83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Print</div></td></tr>
<tr class="memitem:a1e2ce163626bd93089e4f06ad7402eb5"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a1e2ce163626bd93089e4f06ad7402eb5">print</a> (std::ostream &amp;stream)</td></tr>
<tr class="memdesc:a1e2ce163626bd93089e4f06ad7402eb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print nothing to stream.  <a href="#a1e2ce163626bd93089e4f06ad7402eb5"></a><br/></td></tr>
<tr class="separator:a1e2ce163626bd93089e4f06ad7402eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3517e714a8fb5b5e3bf426fb3a2b9e60"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a3517e714a8fb5b5e3bf426fb3a2b9e60">print</a> (std::ostream &amp;stream, const std::tuple&lt;&gt; &amp;)</td></tr>
<tr class="memdesc:a3517e714a8fb5b5e3bf426fb3a2b9e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an empty tuple to stream.  <a href="#a3517e714a8fb5b5e3bf426fb3a2b9e60"></a><br/></td></tr>
<tr class="separator:a3517e714a8fb5b5e3bf426fb3a2b9e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a27564c6dc2ed89a013300f9fca57a"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a47a27564c6dc2ed89a013300f9fca57a"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a47a27564c6dc2ed89a013300f9fca57a">print</a> (std::ostream &amp;stream, const Type &amp;variable)</td></tr>
<tr class="memdesc:a47a27564c6dc2ed89a013300f9fca57a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a single variable to stream.  <a href="#a47a27564c6dc2ed89a013300f9fca57a"></a><br/></td></tr>
<tr class="separator:a47a27564c6dc2ed89a013300f9fca57a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0717030f561af1bd430228d2344c52"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename... Types&gt; </td></tr>
<tr class="memitem:a0e0717030f561af1bd430228d2344c52"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a0e0717030f561af1bd430228d2344c52">print</a> (std::ostream &amp;stream, const Type &amp;variable, const Types &amp;...variables)</td></tr>
<tr class="memdesc:a0e0717030f561af1bd430228d2344c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print several variables to stream.  <a href="#a0e0717030f561af1bd430228d2344c52"></a><br/></td></tr>
<tr class="separator:a0e0717030f561af1bd430228d2344c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a368733a11174f5cd268e7ccdd060d9"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::size_t Size&gt; </td></tr>
<tr class="memitem:a0a368733a11174f5cd268e7ccdd060d9"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a0a368733a11174f5cd268e7ccdd060d9">print</a> (std::ostream &amp;stream, const std::array&lt; Type, Size &gt; &amp;container)</td></tr>
<tr class="memdesc:a0a368733a11174f5cd268e7ccdd060d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an array to stream.  <a href="#a0a368733a11174f5cd268e7ccdd060d9"></a><br/></td></tr>
<tr class="separator:a0a368733a11174f5cd268e7ccdd060d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3a922b97c206664e1333240e82d9e2"><td class="memTemplParams" colspan="2">template&lt;unsigned int Current = 0, typename... Types&gt; </td></tr>
<tr class="memitem:a9b3a922b97c206664e1333240e82d9e2"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a9b3a922b97c206664e1333240e82d9e2">print</a> (std::ostream &amp;stream, const std::tuple&lt; Types...&gt; &amp;container)</td></tr>
<tr class="memdesc:a9b3a922b97c206664e1333240e82d9e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a tuple to stream.  <a href="#a9b3a922b97c206664e1333240e82d9e2"></a><br/></td></tr>
<tr class="separator:a9b3a922b97c206664e1333240e82d9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881ef2cae9609cbbb2f3e3f77443c0bb"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a881ef2cae9609cbbb2f3e3f77443c0bb">rprint</a> (std::ostream &amp;stream, const std::nullptr_t=nullptr, const std::nullptr_t=nullptr)</td></tr>
<tr class="memdesc:a881ef2cae9609cbbb2f3e3f77443c0bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an empty range to stream.  <a href="#a881ef2cae9609cbbb2f3e3f77443c0bb"></a><br/></td></tr>
<tr class="separator:a881ef2cae9609cbbb2f3e3f77443c0bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4874d6bc840ee89a485fdcc3ce341031"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a4874d6bc840ee89a485fdcc3ce341031"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a4874d6bc840ee89a485fdcc3ce341031">rprint</a> (std::ostream &amp;stream, const Type *const first, const Type *const last)</td></tr>
<tr class="memdesc:a4874d6bc840ee89a485fdcc3ce341031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a range between pointers to stream.  <a href="#a4874d6bc840ee89a485fdcc3ce341031"></a><br/></td></tr>
<tr class="separator:a4874d6bc840ee89a485fdcc3ce341031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6677d3414ea7c4d76662ce56d4320801"><td class="memTemplParams" colspan="2">template&lt;typename Type , class  = typename std::enable_if&lt;!std::is_pointer&lt;Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a6677d3414ea7c4d76662ce56d4320801"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a6677d3414ea7c4d76662ce56d4320801">rprint</a> (std::ostream &amp;stream, const Type &amp;first, const Type &amp;last, typename std::iterator_traits&lt; Type &gt;::iterator_category *=nullptr)</td></tr>
<tr class="memdesc:a6677d3414ea7c4d76662ce56d4320801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a range between iterators to stream.  <a href="#a6677d3414ea7c4d76662ce56d4320801"></a><br/></td></tr>
<tr class="separator:a6677d3414ea7c4d76662ce56d4320801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Scan</div></td></tr>
<tr class="memitem:a5e26ce4a9478dcc7c83d904bf8c494f6"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a5e26ce4a9478dcc7c83d904bf8c494f6">scan</a> (std::istream &amp;stream)</td></tr>
<tr class="memdesc:a5e26ce4a9478dcc7c83d904bf8c494f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan nothing from stream.  <a href="#a5e26ce4a9478dcc7c83d904bf8c494f6"></a><br/></td></tr>
<tr class="separator:a5e26ce4a9478dcc7c83d904bf8c494f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2694fc43019f85c66b1f88b4db924f85"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a2694fc43019f85c66b1f88b4db924f85">scan</a> (std::istream &amp;stream, std::tuple&lt;&gt; &amp;)</td></tr>
<tr class="memdesc:a2694fc43019f85c66b1f88b4db924f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan an empty tuple from stream.  <a href="#a2694fc43019f85c66b1f88b4db924f85"></a><br/></td></tr>
<tr class="separator:a2694fc43019f85c66b1f88b4db924f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0d2f234267a5c274662c6fe48fe988"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a2f0d2f234267a5c274662c6fe48fe988"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a2f0d2f234267a5c274662c6fe48fe988">scan</a> (std::istream &amp;stream, Type &amp;variable)</td></tr>
<tr class="memdesc:a2f0d2f234267a5c274662c6fe48fe988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan a single variable from stream.  <a href="#a2f0d2f234267a5c274662c6fe48fe988"></a><br/></td></tr>
<tr class="separator:a2f0d2f234267a5c274662c6fe48fe988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adefa5bd26a29d5b13d3f94a45bd99973"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename... Types&gt; </td></tr>
<tr class="memitem:adefa5bd26a29d5b13d3f94a45bd99973"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#adefa5bd26a29d5b13d3f94a45bd99973">scan</a> (std::istream &amp;stream, Type &amp;variable, Types &amp;...variables)</td></tr>
<tr class="memdesc:adefa5bd26a29d5b13d3f94a45bd99973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan several variables from stream.  <a href="#adefa5bd26a29d5b13d3f94a45bd99973"></a><br/></td></tr>
<tr class="separator:adefa5bd26a29d5b13d3f94a45bd99973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf322f4399f6008717153ca2338c1ab3"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::size_t Size&gt; </td></tr>
<tr class="memitem:abf322f4399f6008717153ca2338c1ab3"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#abf322f4399f6008717153ca2338c1ab3">scan</a> (std::istream &amp;stream, std::array&lt; Type, Size &gt; &amp;container)</td></tr>
<tr class="memdesc:abf322f4399f6008717153ca2338c1ab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan an array from stream.  <a href="#abf322f4399f6008717153ca2338c1ab3"></a><br/></td></tr>
<tr class="separator:abf322f4399f6008717153ca2338c1ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcdea61c7011b22539e783c9fb782e07"><td class="memTemplParams" colspan="2">template&lt;unsigned int Current = 0, typename... Types&gt; </td></tr>
<tr class="memitem:afcdea61c7011b22539e783c9fb782e07"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#afcdea61c7011b22539e783c9fb782e07">scan</a> (std::istream &amp;stream, std::tuple&lt; Types...&gt; &amp;container)</td></tr>
<tr class="memdesc:afcdea61c7011b22539e783c9fb782e07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan a tuple from stream.  <a href="#afcdea61c7011b22539e783c9fb782e07"></a><br/></td></tr>
<tr class="separator:afcdea61c7011b22539e783c9fb782e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f1d27ed688fd6886c19eebae03d4be"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#ab5f1d27ed688fd6886c19eebae03d4be">rscan</a> (std::istream &amp;stream, const std::nullptr_t=nullptr, const std::nullptr_t=nullptr)</td></tr>
<tr class="memdesc:ab5f1d27ed688fd6886c19eebae03d4be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan an empty range from stream.  <a href="#ab5f1d27ed688fd6886c19eebae03d4be"></a><br/></td></tr>
<tr class="separator:ab5f1d27ed688fd6886c19eebae03d4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48cd90a288bcb730d481bf475d6918fa"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a48cd90a288bcb730d481bf475d6918fa"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a48cd90a288bcb730d481bf475d6918fa">rscan</a> (std::istream &amp;stream, Type *const first, Type *const last)</td></tr>
<tr class="memdesc:a48cd90a288bcb730d481bf475d6918fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan a range between pointers from stream.  <a href="#a48cd90a288bcb730d481bf475d6918fa"></a><br/></td></tr>
<tr class="separator:a48cd90a288bcb730d481bf475d6918fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d23e8cc8b4ac2983e1e84c8120f30c"><td class="memTemplParams" colspan="2">template&lt;typename Type , class  = typename std::enable_if&lt;!std::is_pointer&lt;Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ae8d23e8cc8b4ac2983e1e84c8120f30c"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#ae8d23e8cc8b4ac2983e1e84c8120f30c">rscan</a> (std::istream &amp;stream, const Type &amp;first, const Type &amp;last, typename std::iterator_traits&lt; Type &gt;::iterator_category *=nullptr)</td></tr>
<tr class="memdesc:ae8d23e8cc8b4ac2983e1e84c8120f30c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan a range between iterators from stream.  <a href="#ae8d23e8cc8b4ac2983e1e84c8120f30c"></a><br/></td></tr>
<tr class="separator:ae8d23e8cc8b4ac2983e1e84c8120f30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Test</div></td></tr>
<tr class="memitem:a480460d73295525655079a6a3a380660"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html#a480460d73295525655079a6a3a380660">example</a> ()</td></tr>
<tr class="memdesc:a480460d73295525655079a6a3a380660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Example function.  <a href="#a480460d73295525655079a6a3a380660"></a><br/></td></tr>
<tr class="separator:a480460d73295525655079a6a3a380660"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Set of basic operations on binary data related to IO. </p>
<p>Provides a wide range of overloaded utilities to handle and format data for reading and writing tasks : byteswap, size, extraction from tuples... </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a03a3af0a1f2adce31cd189191a420ac0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool magrathea::DataHandler::array </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is not an array. </p>
<p>Returns false as the passed argument is not a standard array. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether the argument is a standard array. </dd></dl>

</div>
</div>
<a class="anchor" id="ab9d06cd95b4986d4760c6650b1642b60"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::size_t Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool magrathea::DataHandler::array </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; Type, Size &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is an array. </p>
<p>Returns true as the passed argument is a standard array. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether the argument is a standard array. </dd></dl>

</div>
</div>
<a class="anchor" id="a9453a2836ff2573bc80e11f1de0cebe2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned int magrathea::DataHandler::bytesize </td>
          <td>(</td>
          <td class="paramtype">const std::nullptr_t&#160;</td>
          <td class="paramname"> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size in bytes of a single type. </p>
<p>Computes the size in bytes of the passed type. The returned size is either the result of <code>sizeof()</code> or 0 if the type is void. Note that if the passed type is a templated type, like a tuple, the inner arguments are not extracted, and the result is simply the same as <code>sizeof()</code> . </p>
<dl class="section return"><dt>Returns</dt><dd>Size in bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="afb38de93a744c640d2642c53a01770d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename... Types, class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned int magrathea::DataHandler::bytesize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size in bytes of a single type. </p>
<p>Computes the size in bytes of the passed types. The returned size is the sum of the sizes of each type. </p>
<dl class="section return"><dt>Returns</dt><dd>Size in bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="a91a123543b345a2b8933a7ef121e48d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned int magrathea::DataHandler::bytesize </td>
          <td>(</td>
          <td class="paramtype">const std::tuple&lt;&gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size in bytes of an empty tuple. </p>
<p>Function overload that does nothing. </p>
<dl class="section return"><dt>Returns</dt><dd>Size in bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="a005235ea08efd9713579f41791145f79"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned int magrathea::DataHandler::bytesize </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>variable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size in bytes of a single variable. </p>
<p>Computes the size in bytes of the passed variable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>(Variable type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">variable</td><td>Variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size in bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="aab076f5fed2b6c72e027aa4d8f9bd511"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned int magrathea::DataHandler::bytesize </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Types &amp;...&#160;</td>
          <td class="paramname"><em>variables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size in bytes of several variables. </p>
<p>Computes the sum of the size in bytes of the passed variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>(Variable type.) </td></tr>
    <tr><td class="paramname">Types</td><td>(Variadic types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">variable</td><td>Variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">variables</td><td>Variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size in bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="a6707784777d7bf711da488edff8a084e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::size_t Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned int magrathea::DataHandler::bytesize </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; Type, Size &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size in bytes of an array. </p>
<p>Computes the sum of the size in bytes of elements of the passed array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>(Array type.) </td></tr>
    <tr><td class="paramname">Size</td><td>(Array size.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>Array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size in bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="aa8ceabc79d0ed2e208614e77672b1a10"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int Current, typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned int magrathea::DataHandler::bytesize </td>
          <td>(</td>
          <td class="paramtype">const std::tuple&lt; Types...&gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size in bytes of a tuple. </p>
<p>Computes the sum of the size in bytes of elements of the passed tuple. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Current</td><td>(Current level of recursion.) </td></tr>
    <tr><td class="paramname">Types</td><td>(Variadic types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>Tuple. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size in bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="a2042e91ebc502db3edcf5256c0294c5f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, typename... Types, class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int magrathea::DataHandler::byteswap </td>
          <td>(</td>
          <td class="paramtype">const Types &amp;&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do not swap bytes. </p>
<p>Function overload that does nothing. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Do not swap endianness if false. </td></tr>
    <tr><td class="paramname">Types</td><td>(Variadic types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements successfully byteswapped. </dd></dl>

</div>
</div>
<a class="anchor" id="a4d89163c7346d993b9a17368c76673d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int magrathea::DataHandler::byteswap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap bytes of nothing. </p>
<p>Function overload that does nothing. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness if true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements successfully byteswapped. </dd></dl>

</div>
</div>
<a class="anchor" id="a5c6338a9f2e899a72c9d28526a27b4d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int magrathea::DataHandler::byteswap </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt;&gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap bytes of an empty tuple. </p>
<p>Function overload that does nothing. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness if true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements successfully byteswapped. </dd></dl>

</div>
</div>
<a class="anchor" id="a8345c4082a891fc086d1030fc74750c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, typename Type, class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int magrathea::DataHandler::byteswap </td>
          <td>(</td>
          <td class="paramtype">Type &amp;&#160;</td>
          <td class="paramname"><em>variable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap bytes of a single variable. </p>
<p>Inverts the order of bytes of the passed variable to change the endianness. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness if true. </td></tr>
    <tr><td class="paramname">Type</td><td>(Variable type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">variable</td><td>Variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements successfully byteswapped. </dd></dl>

</div>
</div>
<a class="anchor" id="aca66620abc29a4a2274a77426805f722"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, typename Type, typename... Types, class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int magrathea::DataHandler::byteswap </td>
          <td>(</td>
          <td class="paramtype">Type &amp;&#160;</td>
          <td class="paramname"><em>variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Types &amp;...&#160;</td>
          <td class="paramname"><em>variables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap bytes of several variables. </p>
<p>Inverts the order of bytes of the passed variables to change the endianness. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness if true. </td></tr>
    <tr><td class="paramname">Type</td><td>(Variable type.) </td></tr>
    <tr><td class="paramname">Types</td><td>(Variadic types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">variable</td><td>Variable. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">variables</td><td>Variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements successfully byteswapped. </dd></dl>

</div>
</div>
<a class="anchor" id="a3fb1384e1306c02a233b474e5af34378"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, typename Type, std::size_t Size, class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int magrathea::DataHandler::byteswap </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; Type, Size &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap bytes of an array. </p>
<p>Inverts the order of bytes of each element of the passed array to change the endianness. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness if true. </td></tr>
    <tr><td class="paramname">Type</td><td>(Array type.) </td></tr>
    <tr><td class="paramname">Size</td><td>(Array size.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">container</td><td>Array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements successfully byteswapped. </dd></dl>

</div>
</div>
<a class="anchor" id="a46d3d574a4edcc3cd4f86a5e63fe7472"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, unsigned int Current, typename... Types, class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int magrathea::DataHandler::byteswap </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; Types...&gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap bytes of a tuple. </p>
<p>Inverts the order of bytes of each element of the passed tuple to change the endianness. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness if true. </td></tr>
    <tr><td class="paramname">Current</td><td>(Current level of recursion.) </td></tr>
    <tr><td class="paramname">Types</td><td>(Variadic types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">container</td><td>Tuple. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements successfully byteswapped. </dd></dl>

</div>
</div>
<a class="anchor" id="a51a6cff6e8a684d22e368ff56ca72fea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Reference &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int magrathea::DataHandler::equalize </td>
          <td>(</td>
          <td class="paramtype">const Reference &amp;&#160;</td>
          <td class="paramname"><em>reference</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equalize nothing. </p>
<p>Function overload that does nothing. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Reference</td><td>(Reference type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reference</td><td>Reference value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements successfully set to the reference value. </dd></dl>

</div>
</div>
<a class="anchor" id="a73254d7cfb56f9d49207670ce2f0bf46"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Reference &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int magrathea::DataHandler::equalize </td>
          <td>(</td>
          <td class="paramtype">const Reference &amp;&#160;</td>
          <td class="paramname"><em>reference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt;&gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equalize an empty tuple. </p>
<p>Function overload that does nothing. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Reference</td><td>(Reference type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reference</td><td>Reference value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements successfully set to the reference value. </dd></dl>

</div>
</div>
<a class="anchor" id="a21aa49476bfdea5e3e1eb6db89610b6f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Reference , typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int magrathea::DataHandler::equalize </td>
          <td>(</td>
          <td class="paramtype">const Reference &amp;&#160;</td>
          <td class="paramname"><em>reference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type &amp;&#160;</td>
          <td class="paramname"><em>variable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equalize a single variable. </p>
<p>Set the passed variable to the reference value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Reference</td><td>(Reference type.) </td></tr>
    <tr><td class="paramname">Type</td><td>(Variable type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reference</td><td>Reference value. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">variable</td><td>Variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements successfully set to the reference value. </dd></dl>

</div>
</div>
<a class="anchor" id="ac30aa6d5b117ee5af179dba30b59025f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Reference , typename Type , typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int magrathea::DataHandler::equalize </td>
          <td>(</td>
          <td class="paramtype">const Reference &amp;&#160;</td>
          <td class="paramname"><em>reference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type &amp;&#160;</td>
          <td class="paramname"><em>variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Types &amp;...&#160;</td>
          <td class="paramname"><em>variables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equalize several variables. </p>
<p>Set the passed variables to the reference value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Reference</td><td>(Reference type.) </td></tr>
    <tr><td class="paramname">Type</td><td>(Variable type.) </td></tr>
    <tr><td class="paramname">Types</td><td>(Variadic types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reference</td><td>Reference value. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">variable</td><td>Variable. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">variables</td><td>Variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements successfully set to the reference value. </dd></dl>

</div>
</div>
<a class="anchor" id="a91eaaf11ba2d7d2c56cb365b1f4fae05"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Reference , typename Type , std::size_t Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int magrathea::DataHandler::equalize </td>
          <td>(</td>
          <td class="paramtype">const Reference &amp;&#160;</td>
          <td class="paramname"><em>reference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; Type, Size &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equalize an array. </p>
<p>Set each element of the passed array to the reference value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Reference</td><td>(Reference type.) </td></tr>
    <tr><td class="paramname">Type</td><td>(Array type.) </td></tr>
    <tr><td class="paramname">Size</td><td>(Array size.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reference</td><td>Reference value. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">container</td><td>Array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements successfully set to the reference value. </dd></dl>

</div>
</div>
<a class="anchor" id="ac081445d6585ad93c1420826eeb923c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int Current, typename Reference , typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int magrathea::DataHandler::equalize </td>
          <td>(</td>
          <td class="paramtype">const Reference &amp;&#160;</td>
          <td class="paramname"><em>reference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; Types...&gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equalize a tuple. </p>
<p>Set each element of the passed tuple to the reference value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Current</td><td>(Current level of recursion.) </td></tr>
    <tr><td class="paramname">Reference</td><td>(Reference type.) </td></tr>
    <tr><td class="paramname">Types</td><td>(Variadic types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reference</td><td>Reference value. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">container</td><td>Tuple. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements successfully set to the reference value. </dd></dl>

</div>
</div>
<a class="anchor" id="a480460d73295525655079a6a3a380660"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int magrathea::DataHandler::example </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Example function. </p>
<p>Tests and demonstrates the use of <a class="el" href="exceptionmagrathea_1_1Timer.html" title="A timer to manage time measurements and benchmarks.">Timer</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if no error. </dd></dl>

</div>
</div>
<a class="anchor" id="a2ced7c88930c8cb63f53ae8ccd7d8869"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, bool Uppercase&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string magrathea::DataHandler::hexify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert nothing to a hexadecimal string. </p>
<p>Function overload that does nothing. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap bytes of hexadecimal conversion if true. </td></tr>
    <tr><td class="paramname">Uppercase</td><td>Force uppercase letters for hexadecimal representation if true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Hexadecimal representation of the input. </dd></dl>

</div>
</div>
<a class="anchor" id="a5e509568af157f6b3fafaa6d7b77ee5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, bool Uppercase&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string magrathea::DataHandler::hexify </td>
          <td>(</td>
          <td class="paramtype">const std::tuple&lt;&gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an empty tuple to a hexadecimal string. </p>
<p>Function overload that does nothing. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap bytes of hexadecimal conversion if true. </td></tr>
    <tr><td class="paramname">Uppercase</td><td>Force uppercase letters for hexadecimal representation if true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Hexadecimal representation of the input. </dd></dl>

</div>
</div>
<a class="anchor" id="af6a8e6e71817c4ff9f3e09ffd2440713"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, bool Uppercase, typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string magrathea::DataHandler::hexify </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>variable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a single variable to a hexadecimal string. </p>
<p>Converts bytes of the passed variable to their hexadecimal representation and returns the associated string. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap bytes of hexadecimal conversion if true. </td></tr>
    <tr><td class="paramname">Uppercase</td><td>Force uppercase letters for hexadecimal representation if true. </td></tr>
    <tr><td class="paramname">Type</td><td>(Variable type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">variable</td><td>Variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Hexadecimal representation of the input. </dd></dl>

</div>
</div>
<a class="anchor" id="a87cdcecdb302b79db66f8781d92d2a38"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, bool Uppercase, typename Type , typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string magrathea::DataHandler::hexify </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Types &amp;...&#160;</td>
          <td class="paramname"><em>variables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert several variables to a hexadecimal string. </p>
<p>Converts bytes of the passed variables to their hexadecimal representation and returns the associated string. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap bytes of hexadecimal conversion if true. </td></tr>
    <tr><td class="paramname">Uppercase</td><td>Force uppercase letters for hexadecimal representation if true. </td></tr>
    <tr><td class="paramname">Type</td><td>(Variable type.) </td></tr>
    <tr><td class="paramname">Types</td><td>(Variadic types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">variable</td><td>Variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">variables</td><td>Variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Hexadecimal representation of the input. </dd></dl>

</div>
</div>
<a class="anchor" id="a537df36d100df807e95e9fe4297ce788"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, bool Uppercase, typename Type , std::size_t Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string magrathea::DataHandler::hexify </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; Type, Size &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an array to a hexadecimal string. </p>
<p>Converts bytes of each element of the passed array to their hexadecimal representation and returns the associated string. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap bytes of hexadecimal conversion if true. </td></tr>
    <tr><td class="paramname">Uppercase</td><td>Force uppercase letters for hexadecimal representation if true. </td></tr>
    <tr><td class="paramname">Type</td><td>(Array type.) </td></tr>
    <tr><td class="paramname">Size</td><td>(Array size.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>Array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Hexadecimal representation of the input. </dd></dl>

</div>
</div>
<a class="anchor" id="a93de73e7027c2dee8564b1520f319d3a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, bool Uppercase, unsigned int Current, typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string magrathea::DataHandler::hexify </td>
          <td>(</td>
          <td class="paramtype">const std::tuple&lt; Types...&gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a tuple to a hexadecimal string. </p>
<p>Converts bytes of each element of the passed tuple to their hexadecimal representation and returns the associated string. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap bytes of hexadecimal conversion if true. </td></tr>
    <tr><td class="paramname">Uppercase</td><td>Force uppercase letters for hexadecimal representation if true. </td></tr>
    <tr><td class="paramname">Current</td><td>(Current level of recursion.) </td></tr>
    <tr><td class="paramname">Types</td><td>(Variadic types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>Tuple. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Hexadecimal representation of the input. </dd></dl>

</div>
</div>
<a class="anchor" id="a7958f101a7437fe5ada971be5eceef32"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int magrathea::DataHandler::nullify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Nullify nothing. </p>
<p>Function overload that does nothing. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of elements successfully set to zero. </dd></dl>

</div>
</div>
<a class="anchor" id="ad0026082d808e1bba847e0abdb142d61"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int magrathea::DataHandler::nullify </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt;&gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Nullify an empty tuple. </p>
<p>Function overload that does nothing. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of elements successfully set to zero. </dd></dl>

</div>
</div>
<a class="anchor" id="aaa0ca7b9d5b2659fd567df2ceab1f0e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int magrathea::DataHandler::nullify </td>
          <td>(</td>
          <td class="paramtype">Type &amp;&#160;</td>
          <td class="paramname"><em>variable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Nullify a single variable. </p>
<p>Calls the constructor of the passed variable to nullify it. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>(Variable type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">variable</td><td>Variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements successfully set to zero. </dd></dl>

</div>
</div>
<a class="anchor" id="ab7f14c311ad2d5f0f6faaef4383db779"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int magrathea::DataHandler::nullify </td>
          <td>(</td>
          <td class="paramtype">Type &amp;&#160;</td>
          <td class="paramname"><em>variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Types &amp;...&#160;</td>
          <td class="paramname"><em>variables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Nullify several variables. </p>
<p>Calls the constructor of the passed variables to nullify them. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>(Variable type.) </td></tr>
    <tr><td class="paramname">Types</td><td>(Variadic types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">variable</td><td>Variable. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">variables</td><td>Variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements successfully set to zero. </dd></dl>

</div>
</div>
<a class="anchor" id="a88ed5c28c8d5eb5b66338af0e1018852"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::size_t Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int magrathea::DataHandler::nullify </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; Type, Size &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Nullify an array. </p>
<p>Calls the constructor of each element of the passed array to nullify it. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>(Array type.) </td></tr>
    <tr><td class="paramname">Size</td><td>(Array size.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">container</td><td>Array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements successfully set to zero. </dd></dl>

</div>
</div>
<a class="anchor" id="a87e291616af2fba57c18aa231eefd333"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int Current, typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int magrathea::DataHandler::nullify </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; Types...&gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Nullify a tuple. </p>
<p>Calls the constructor of each element of the passed tuple to nullify it. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Current</td><td>(Current level of recursion.) </td></tr>
    <tr><td class="paramname">Types</td><td>(Variadic types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">container</td><td>Tuple. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements successfully set to zero. </dd></dl>

</div>
</div>
<a class="anchor" id="a1e2ce163626bd93089e4f06ad7402eb5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::DataHandler::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print nothing to stream. </p>
<p>Function overload that does nothing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the stream has no failure, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a3517e714a8fb5b5e3bf426fb3a2b9e60"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::DataHandler::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::tuple&lt;&gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print an empty tuple to stream. </p>
<p>Function overload that does nothing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the stream has no failure, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a47a27564c6dc2ed89a013300f9fca57a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::DataHandler::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>variable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print a single variable to stream. </p>
<p>Prints the next variable to the stream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>(Variable type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">variable</td><td>Variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the stream has no failure, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a0e0717030f561af1bd430228d2344c52"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::DataHandler::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Types &amp;...&#160;</td>
          <td class="paramname"><em>variables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print several variables to stream. </p>
<p>Prints the next variables to the stream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>(Variable type.) </td></tr>
    <tr><td class="paramname">Types</td><td>(Variadic types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">variable</td><td>Variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">variables</td><td>Variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the stream has no failure, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a0a368733a11174f5cd268e7ccdd060d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::size_t Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::DataHandler::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; Type, Size &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print an array to stream. </p>
<p>Prints each element of the passed array to the stream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>(Array type.) </td></tr>
    <tr><td class="paramname">Size</td><td>(Array size.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>Array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the stream has no failure, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a9b3a922b97c206664e1333240e82d9e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int Current, typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::DataHandler::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::tuple&lt; Types...&gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print a tuple to stream. </p>
<p>Prints each element of the passed tuple to the stream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Current</td><td>(Current level of recursion.) </td></tr>
    <tr><td class="paramname">Types</td><td>(Variadic types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>Tuple. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the stream has no failure, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ae01a7da121ecba94a7bdc81fff5be3d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long int magrathea::DataHandler::rbytesize </td>
          <td>(</td>
          <td class="paramtype">const std::nullptr_t&#160;</td>
          <td class="paramname"> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::nullptr_t&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size in bytes of an empty range. </p>
<p>Function overload that does nothing. </p>
<dl class="section return"><dt>Returns</dt><dd>Size in bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ae3bc23ee6136da25ec8d15bc875298cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long int magrathea::DataHandler::rbytesize </td>
          <td>(</td>
          <td class="paramtype">const Type *const&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type *const&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size in bytes of a range between pointers. </p>
<p>Computes the sum of the size in bytes of the elements of the range between the passed pointers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>(Pointer type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Pointer to the beginning. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Pointer to the end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size in bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="a2e7e977cac2277aa42a2fa52f84366a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long int magrathea::DataHandler::rbytesize </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::iterator_traits&lt; Type &gt;::iterator_category *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size in bytes of a range between iterators. </p>
<p>Computes the sum of the size in bytes of the range between the passed iterators. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>(Iterator type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator to the beginning. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator to the end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size in bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ab69b0bf24969449ee0b986f2a19139"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, typename... Types, class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int magrathea::DataHandler::rbyteswap </td>
          <td>(</td>
          <td class="paramtype">const Types &amp;&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do not swap bytes of a range. </p>
<p>Function overload that does nothing. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Do not swap endianness if false. </td></tr>
    <tr><td class="paramname">Types</td><td>(Variadic types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements successfully byteswapped. </dd></dl>

</div>
</div>
<a class="anchor" id="a177dfd5de3d487fe6324fac41c1f3871"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long int magrathea::DataHandler::rbyteswap </td>
          <td>(</td>
          <td class="paramtype">const std::nullptr_t&#160;</td>
          <td class="paramname"> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::nullptr_t&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap bytes of an empty range. </p>
<p>Function overload that does nothing. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness if true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements successfully byteswapped. </dd></dl>

</div>
</div>
<a class="anchor" id="a97f17ea461a0969ff4a6e44723c3bfd7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, typename Type, class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long int magrathea::DataHandler::rbyteswap </td>
          <td>(</td>
          <td class="paramtype">Type *const&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type *const&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap bytes of a range between pointers. </p>
<p>Inverts the order of bytes of each element of the range between the passed pointers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness if true. </td></tr>
    <tr><td class="paramname">Type</td><td>(Pointer type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Pointer to the beginning. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Pointer to the end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements successfully byteswapped. </dd></dl>

</div>
</div>
<a class="anchor" id="a0c784af750a3869cd3f1d7c338c22e4e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, typename Type, class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long int magrathea::DataHandler::rbyteswap </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::iterator_traits&lt; Type &gt;::iterator_category *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap bytes of a range between iterators. </p>
<p>Inverts the order of bytes of each element of the range between the passed iterators. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness if true. </td></tr>
    <tr><td class="paramname">Type</td><td>(Iterator type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator to the beginning. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator to the end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements successfully byteswapped. </dd></dl>

</div>
</div>
<a class="anchor" id="ae34eaeb6faf631309cb9000316771377"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::DataHandler::read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read nothing from stream. </p>
<p>Function overload that does nothing. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness after reading if true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td><a class="el" href="exceptionInput.html" title="Input utilities for raytracing.">Input</a> stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the stream has no failure, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b2d2a3c03f6fae7ce3fc7c54e3808aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::DataHandler::read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt;&gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read an empty tuple from stream. </p>
<p>Function overload that does nothing. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness after reading if true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td><a class="el" href="exceptionInput.html" title="Input utilities for raytracing.">Input</a> stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the stream has no failure, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a8a9ffe306dfa1cbc4dfc27d0bab1385f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::DataHandler::read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type &amp;&#160;</td>
          <td class="paramname"><em>variable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a single variable from stream. </p>
<p>Reads the next variable from the stream and swap bytes if necessary. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness after reading if true. </td></tr>
    <tr><td class="paramname">Type</td><td>(Variable type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td><a class="el" href="exceptionInput.html" title="Input utilities for raytracing.">Input</a> stream. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">variable</td><td>Variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the stream has no failure, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a67649218acd759dde8b1d9617a36219f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, typename Type , typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::DataHandler::read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type &amp;&#160;</td>
          <td class="paramname"><em>variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Types &amp;...&#160;</td>
          <td class="paramname"><em>variables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read several variables from stream. </p>
<p>Reads the next variables from the stream and swap bytes if necessary. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness after reading if true. </td></tr>
    <tr><td class="paramname">Type</td><td>(Variable type.) </td></tr>
    <tr><td class="paramname">Types</td><td>(Variadic types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td><a class="el" href="exceptionInput.html" title="Input utilities for raytracing.">Input</a> stream. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">variable</td><td>Variable. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">variables</td><td>Variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the stream has no failure, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a2bf9d85128f5bccff6f9d764120cd49f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, typename Type , std::size_t Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::DataHandler::read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; Type, Size &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read an array from stream. </p>
<p>Reads each element of the passed array from the stream and swap bytes if necessary. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness after reading if true. </td></tr>
    <tr><td class="paramname">Type</td><td>(Array type.) </td></tr>
    <tr><td class="paramname">Size</td><td>(Array size.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td><a class="el" href="exceptionInput.html" title="Input utilities for raytracing.">Input</a> stream. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">container</td><td>Array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the stream has no failure, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ac1b5efbb028f2464bfbe669707e57c8f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, unsigned int Current, typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::DataHandler::read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; Types...&gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a tuple from stream. </p>
<p>Reads each element of the passed tuple from the stream and swap bytes if necessary. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness after reading if true. </td></tr>
    <tr><td class="paramname">Current</td><td>(Current level of recursion.) </td></tr>
    <tr><td class="paramname">Types</td><td>(Variadic types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td><a class="el" href="exceptionInput.html" title="Input utilities for raytracing.">Input</a> stream. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">container</td><td>Tuple. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the stream has no failure, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="abb1758c0b2f72e48f5ef7db95b016ccf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char *&amp; magrathea::DataHandler::read </td>
          <td>(</td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read nothing from buffer. </p>
<p>Function overload that does nothing. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness after reading if true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td><a class="el" href="exceptionInput.html" title="Input utilities for raytracing.">Input</a> buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new position in the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a4fb8e4a637b6f4c3c798b1b94e568007"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char *&amp; magrathea::DataHandler::read </td>
          <td>(</td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt;&gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read an empty tuple from buffer. </p>
<p>Function overload that does nothing. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness after reading if true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td><a class="el" href="exceptionInput.html" title="Input utilities for raytracing.">Input</a> buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new position in the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="aa8fe6c9d3f4a56d178898ba64cdc93f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char *&amp; magrathea::DataHandler::read </td>
          <td>(</td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type &amp;&#160;</td>
          <td class="paramname"><em>variable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a single variable from buffer. </p>
<p>Reads the next variable from the buffer and swap bytes if necessary. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness after reading if true. </td></tr>
    <tr><td class="paramname">Type</td><td>(Variable type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td><a class="el" href="exceptionInput.html" title="Input utilities for raytracing.">Input</a> buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">variable</td><td>Variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new position in the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="ae73602c0c41147651f1ce8c7cbc206f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, typename Type , typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char *&amp; magrathea::DataHandler::read </td>
          <td>(</td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type &amp;&#160;</td>
          <td class="paramname"><em>variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Types &amp;...&#160;</td>
          <td class="paramname"><em>variables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read several variables from buffer. </p>
<p>Reads the next variables from the buffer and swap bytes if necessary. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness after reading if true. </td></tr>
    <tr><td class="paramname">Type</td><td>(Variable type.) </td></tr>
    <tr><td class="paramname">Types</td><td>(Variadic types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td><a class="el" href="exceptionInput.html" title="Input utilities for raytracing.">Input</a> buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">variable</td><td>Variable. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">variables</td><td>Variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new position in the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a6d8fa8651ee32050d8eb6eaf435db2c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, typename Type , std::size_t Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char *&amp; magrathea::DataHandler::read </td>
          <td>(</td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; Type, Size &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read an array from buffer. </p>
<p>Reads each element of the passed array from the buffer and swap bytes if necessary. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness after reading if true. </td></tr>
    <tr><td class="paramname">Type</td><td>(Array type.) </td></tr>
    <tr><td class="paramname">Size</td><td>(Array size.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td><a class="el" href="exceptionInput.html" title="Input utilities for raytracing.">Input</a> buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">container</td><td>Array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new position in the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a21f7805b4e77bb9ab70c5d2f2bee08f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, unsigned int Current, typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char *&amp; magrathea::DataHandler::read </td>
          <td>(</td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; Types...&gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a tuple from buffer. </p>
<p>Reads each element of the passed tuple from the buffer and swap bytes if necessary. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness after reading if true. </td></tr>
    <tr><td class="paramname">Current</td><td>(Current level of recursion.) </td></tr>
    <tr><td class="paramname">Types</td><td>(Variadic types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td><a class="el" href="exceptionInput.html" title="Input utilities for raytracing.">Input</a> buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">container</td><td>Tuple. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new position in the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="afd9f3ea4fce203ea1aca7b855397d76a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Reference &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long int magrathea::DataHandler::requalize </td>
          <td>(</td>
          <td class="paramtype">const Reference &amp;&#160;</td>
          <td class="paramname"><em>reference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::nullptr_t&#160;</td>
          <td class="paramname"> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::nullptr_t&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equalize an empty range. </p>
<p>Function overload that does nothing. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Reference</td><td>(Reference type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reference</td><td>Reference value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements successfully set to the reference value. </dd></dl>

</div>
</div>
<a class="anchor" id="af9782498c2008f965392c3d497461bcb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Reference , typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long int magrathea::DataHandler::requalize </td>
          <td>(</td>
          <td class="paramtype">const Reference &amp;&#160;</td>
          <td class="paramname"><em>reference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type *const&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type *const&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equalize a range between pointers. </p>
<p>Set each element of the range between the passed pointers to the reference value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Reference</td><td>(Reference type.) </td></tr>
    <tr><td class="paramname">Type</td><td>(Pointer type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reference</td><td>Reference value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Pointer to the beginning. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Pointer to the end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements successfully set to the reference value. </dd></dl>

</div>
</div>
<a class="anchor" id="a199258bc8b5a5e25e696322722538bca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Reference , typename Type , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long int magrathea::DataHandler::requalize </td>
          <td>(</td>
          <td class="paramtype">const Reference &amp;&#160;</td>
          <td class="paramname"><em>reference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::iterator_traits&lt; Type &gt;::iterator_category *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equalize a range between iterators. </p>
<p>Set each element of the range between the passed iterators to the reference value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Reference</td><td>(Reference type.) </td></tr>
    <tr><td class="paramname">Type</td><td>(Iterator type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reference</td><td>Reference value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator to the beginning. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator to the end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements successfully set to the reference value. </dd></dl>

</div>
</div>
<a class="anchor" id="ad7bf3950e2fb436e59e3ad8d22630601"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, bool Uppercase&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string magrathea::DataHandler::rhexify </td>
          <td>(</td>
          <td class="paramtype">const std::nullptr_t&#160;</td>
          <td class="paramname"> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::nullptr_t&#160;</td>
          <td class="paramname"> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>separator</em> = <code>&quot;&#160;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an empty range to a hexadecimal string. </p>
<p>Function overload that does nothing. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap bytes of hexadecimal conversion if true. </td></tr>
    <tr><td class="paramname">Uppercase</td><td>Force uppercase letters for hexadecimal representation if true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">separator</td><td>String used as a separator between elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Hexadecimal representation of the input. </dd></dl>

</div>
</div>
<a class="anchor" id="ae12d94dd9d65f7e5ff945d33312f5d28"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, bool Uppercase, typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string magrathea::DataHandler::rhexify </td>
          <td>(</td>
          <td class="paramtype">const Type *const&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type *const&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>separator</em> = <code>&quot;&#160;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a range between pointers to a hexadecimal string. </p>
<p>Converts bytes of each element of the range between the passed pointers to their hexadecimal representation and returns the associated string. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap bytes of hexadecimal conversion if true. </td></tr>
    <tr><td class="paramname">Uppercase</td><td>Force uppercase letters for hexadecimal representation if true. </td></tr>
    <tr><td class="paramname">Type</td><td>(Pointer type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Pointer to the beginning. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Pointer to the end. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">separator</td><td>String used as a separator between elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Hexadecimal representation of the input. </dd></dl>

</div>
</div>
<a class="anchor" id="a1e1f477485c16c5d5221288531453492"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, bool Uppercase, typename Type , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string magrathea::DataHandler::rhexify </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>separator</em> = <code>&quot;&#160;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::iterator_traits&lt; Type &gt;::iterator_category *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a range between iterators to a hexadecimal string. </p>
<p>Converts bytes of each element of the range between the passed iterators to their hexadecimal representation and returns the associated string. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap bytes of hexadecimal conversion if true. </td></tr>
    <tr><td class="paramname">Uppercase</td><td>Force uppercase letters for hexadecimal representation if true. </td></tr>
    <tr><td class="paramname">Type</td><td>(Iterator type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator to the beginning. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator to the end. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">separator</td><td>String used as a separator between elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Hexadecimal representation of the input. </dd></dl>

</div>
</div>
<a class="anchor" id="abb826ede36fd580ea709a19fc71a3e90"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long int magrathea::DataHandler::rnullify </td>
          <td>(</td>
          <td class="paramtype">const std::nullptr_t&#160;</td>
          <td class="paramname"> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::nullptr_t&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Nullify an empty range. </p>
<p>Function overload that does nothing. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of elements successfully set to zero. </dd></dl>

</div>
</div>
<a class="anchor" id="a370472a1aadc46f879801bf1132ab26b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long int magrathea::DataHandler::rnullify </td>
          <td>(</td>
          <td class="paramtype">Type *const&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type *const&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Nullify a range between pointers. </p>
<p>Calls the constructor of each element of the range between the passed pointers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>(Pointer type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Pointer to the beginning. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Pointer to the end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements successfully set to zero. </dd></dl>

</div>
</div>
<a class="anchor" id="a040f6e76e4af90f1e3b696172cfbe48a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long int magrathea::DataHandler::rnullify </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::iterator_traits&lt; Type &gt;::iterator_category *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Nullify a range between iterators. </p>
<p>Calls the constructor of each element of the range between the passed iterators. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>(Iterator type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator to the beginning. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator to the end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements successfully set to zero. </dd></dl>

</div>
</div>
<a class="anchor" id="a881ef2cae9609cbbb2f3e3f77443c0bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::DataHandler::rprint </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::nullptr_t&#160;</td>
          <td class="paramname"> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::nullptr_t&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print an empty range to stream. </p>
<p>Function overload that does nothing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the stream has no failure, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a4874d6bc840ee89a485fdcc3ce341031"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::DataHandler::rprint </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type *const&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type *const&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print a range between pointers to stream. </p>
<p>Prints each element of the range between the passed pointers to the stream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>(Pointer type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Pointer to the beginning. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Pointer to the end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the stream has no failure, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a6677d3414ea7c4d76662ce56d4320801"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::DataHandler::rprint </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::iterator_traits&lt; Type &gt;::iterator_category *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print a range between iterators to stream. </p>
<p>Prints each element of the range between the passed iterators to the stream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>(Iterator type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator to the beginning. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator to the end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the stream has no failure, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a309a1e2e9fa64e1fa5bcae1dbd9b1f86"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::DataHandler::rread </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::nullptr_t&#160;</td>
          <td class="paramname"> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::nullptr_t&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read an empty range from stream. </p>
<p>Function overload that does nothing. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness after reading if true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td><a class="el" href="exceptionInput.html" title="Input utilities for raytracing.">Input</a> stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the stream has no failure, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a5e4dc7bdf1e1ae704aafb92a1c3fe10e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::DataHandler::rread </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type *const&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type *const&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a range between pointers from stream. </p>
<p>Reads each element of the range between the passed pointers from the stream and swap bytes if necessary. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness after reading if true. </td></tr>
    <tr><td class="paramname">Type</td><td>(Pointer type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td><a class="el" href="exceptionInput.html" title="Input utilities for raytracing.">Input</a> stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Pointer to the beginning. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Pointer to the end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the stream has no failure, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a1f5e10ee3ccfbde1b7a0f0cdd9bcf2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, typename Type , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::DataHandler::rread </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::iterator_traits&lt; Type &gt;::iterator_category *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a range between iterators from stream. </p>
<p>Reads each element of the range between the passed iterators from the stream and swap bytes if necessary. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness after reading if true. </td></tr>
    <tr><td class="paramname">Type</td><td>(Iterator type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td><a class="el" href="exceptionInput.html" title="Input utilities for raytracing.">Input</a> stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator to the beginning. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator to the end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the stream has no failure, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="acdd7431815561c8616e157b6789afff0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char *&amp; magrathea::DataHandler::rread </td>
          <td>(</td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::nullptr_t&#160;</td>
          <td class="paramname"> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::nullptr_t&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read an empty range from buffer. </p>
<p>Function overload that does nothing. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness after reading if true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td><a class="el" href="exceptionInput.html" title="Input utilities for raytracing.">Input</a> buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new position in the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a6728414b1976483a9d82af54588e62b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char *&amp; magrathea::DataHandler::rread </td>
          <td>(</td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type *const&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type *const&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a range between pointers from buffer. </p>
<p>Reads each element of the range between the passed pointers from the buffer and swap bytes if necessary. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness after reading if true. </td></tr>
    <tr><td class="paramname">Type</td><td>(Pointer type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td><a class="el" href="exceptionInput.html" title="Input utilities for raytracing.">Input</a> buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Pointer to the beginning. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Pointer to the end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new position in the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="aaef7aa4fc02e64ac7c2d02b413a6dffd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, typename Type , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char *&amp; magrathea::DataHandler::rread </td>
          <td>(</td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::iterator_traits&lt; Type &gt;::iterator_category *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a range between iterators from buffer. </p>
<p>Reads each element of the range between the passed iterators from the buffer and swap bytes if necessary. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness after reading if true. </td></tr>
    <tr><td class="paramname">Type</td><td>(Iterator type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td><a class="el" href="exceptionInput.html" title="Input utilities for raytracing.">Input</a> buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator to the beginning. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator to the end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new position in the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="ab5f1d27ed688fd6886c19eebae03d4be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::DataHandler::rscan </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::nullptr_t&#160;</td>
          <td class="paramname"> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::nullptr_t&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan an empty range from stream. </p>
<p>Function overload that does nothing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td><a class="el" href="exceptionInput.html" title="Input utilities for raytracing.">Input</a> stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the stream has no failure, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a48cd90a288bcb730d481bf475d6918fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::DataHandler::rscan </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type *const&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type *const&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan a range between pointers from stream. </p>
<p>Scans each element of the range between the passed pointers from the stream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>(Pointer type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td><a class="el" href="exceptionInput.html" title="Input utilities for raytracing.">Input</a> stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Pointer to the beginning. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Pointer to the end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the stream has no failure, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ae8d23e8cc8b4ac2983e1e84c8120f30c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::DataHandler::rscan </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::iterator_traits&lt; Type &gt;::iterator_category *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan a range between iterators from stream. </p>
<p>Scans each element of the range between the passed iterators from the stream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>(Iterator type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td><a class="el" href="exceptionInput.html" title="Input utilities for raytracing.">Input</a> stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator to the beginning. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator to the end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the stream has no failure, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ae024501895c9baf0b3fee0b73f53405a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long int magrathea::DataHandler::rsize </td>
          <td>(</td>
          <td class="paramtype">const std::nullptr_t&#160;</td>
          <td class="paramname"> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::nullptr_t&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of elements of an empty range. </p>
<p>Function overload that does nothing. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of elements. </dd></dl>

</div>
</div>
<a class="anchor" id="a453860a6574a579ae466ea72039b3946"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long int magrathea::DataHandler::rsize </td>
          <td>(</td>
          <td class="paramtype">const Type *const&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type *const&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of elements of a range between pointers. </p>
<p>Computes the number of elements of the range between the passed pointers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>(Pointer type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Pointer to the beginning. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Pointer to the end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements. </dd></dl>

</div>
</div>
<a class="anchor" id="a5e965f35cd0f3950c21292f440f9da9f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long int magrathea::DataHandler::rsize </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::iterator_traits&lt; Type &gt;::iterator_category *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of elements of a range between iterators. </p>
<p>Computes the number of elements of the range between the passed iterators. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>(Iterator type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator to the beginning. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator to the end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements. </dd></dl>

</div>
</div>
<a class="anchor" id="a0db434fc9459ef0f11890cef1e222ad7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int Base, char Leading&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string magrathea::DataHandler::rstringify </td>
          <td>(</td>
          <td class="paramtype">const std::nullptr_t&#160;</td>
          <td class="paramname"> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::nullptr_t&#160;</td>
          <td class="paramname"> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>separator</em> = <code>&quot;&#160;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an empty range to a string. </p>
<p>Function overload that does nothing. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Base</td><td>Base representation for integers : 2, 8, 10 or 16. </td></tr>
    <tr><td class="paramname">Leading</td><td>Leading character for integers : 0, 9-13 or 32-126. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">separator</td><td>String used as a separator between elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String conversion of arguments. </dd></dl>

</div>
</div>
<a class="anchor" id="af9e7e01b71aa9f81babfbe16f623aa7b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int Base, char Leading, typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string magrathea::DataHandler::rstringify </td>
          <td>(</td>
          <td class="paramtype">const Type *const&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type *const&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>separator</em> = <code>&quot;&#160;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a range between pointers to a string. </p>
<p>Converts each element of the range between the passed pointers to a string. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Base</td><td>Base representation for integers : 2, 8, 10 or 16. </td></tr>
    <tr><td class="paramname">Leading</td><td>Leading character for integers : 0, 9-13 or 32-126. </td></tr>
    <tr><td class="paramname">Type</td><td>(Pointer type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Pointer to the beginning. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Pointer to the end. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">separator</td><td>String used as a separator between elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String conversion of arguments. </dd></dl>

</div>
</div>
<a class="anchor" id="ac55cfb860edddeed639be96c6bb6a83f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int Base, char Leading, typename Type , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string magrathea::DataHandler::rstringify </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>separator</em> = <code>&quot;&#160;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::iterator_traits&lt; Type &gt;::iterator_category *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a range between iterators to a string. </p>
<p>Converts each element of the range between the passed iterators to a string. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Base</td><td>Base representation for integers : 2, 8, 10 or 16. </td></tr>
    <tr><td class="paramname">Leading</td><td>Leading character for integers : 0, 9-13 or 32-126. </td></tr>
    <tr><td class="paramname">Type</td><td>(Iterator type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator to the beginning. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator to the end. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">separator</td><td>String used as a separator between elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String conversion of arguments. </dd></dl>

</div>
</div>
<a class="anchor" id="a89a51db0939e9deba460b19b46f068c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::DataHandler::rwrite </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::nullptr_t&#160;</td>
          <td class="paramname"> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::nullptr_t&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write an empty range to stream. </p>
<p>Function overload that does nothing. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness for writing if true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the stream has no failure, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a31a3828a7b517b518fdbae8bc0662053"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::DataHandler::rwrite </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type *const&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type *const&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a range between pointers to stream. </p>
<p>Writes each element of the range between the passed pointers to the stream and swap bytes if necessary. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness for writing if true. </td></tr>
    <tr><td class="paramname">Type</td><td>(Pointer type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Pointer to the beginning. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Pointer to the end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the stream has no failure, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aa317b2106da44890bd8743769a432852"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, typename Type , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::DataHandler::rwrite </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::iterator_traits&lt; Type &gt;::iterator_category *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a range between iterators to stream. </p>
<p>Writes each element of the range between the passed iterators to the stream and swap bytes if necessary. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness for writing if true. </td></tr>
    <tr><td class="paramname">Type</td><td>(Iterator type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator to the beginning. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator to the end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the stream has no failure, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a2fef7472281e81fbdca7a42a92b36fe9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char *&amp; magrathea::DataHandler::rwrite </td>
          <td>(</td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::nullptr_t&#160;</td>
          <td class="paramname"> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::nullptr_t&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write an empty range to buffer. </p>
<p>Function overload that does nothing. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness for writing if true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new position in the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="ac43856b9e64071b14be4be469381258f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char *&amp; magrathea::DataHandler::rwrite </td>
          <td>(</td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type *const&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type *const&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a range between pointers to buffer. </p>
<p>Writes each element of the range between the passed pointers to the buffer and swap bytes if necessary. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness for writing if true. </td></tr>
    <tr><td class="paramname">Type</td><td>(Pointer type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Pointer to the beginning. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Pointer to the end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new position in the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a5c2ce2134d220930333c6f6c2a7e2a73"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, typename Type , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char *&amp; magrathea::DataHandler::rwrite </td>
          <td>(</td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::iterator_traits&lt; Type &gt;::iterator_category *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a range between iterators to buffer. </p>
<p>Writes each element of the range between the passed iterators to the buffer and swap bytes if necessary. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness for writing if true. </td></tr>
    <tr><td class="paramname">Type</td><td>(Iterator type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator to the beginning. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator to the end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new position in the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a5e26ce4a9478dcc7c83d904bf8c494f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::DataHandler::scan </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan nothing from stream. </p>
<p>Function overload that does nothing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td><a class="el" href="exceptionInput.html" title="Input utilities for raytracing.">Input</a> stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the stream has no failure, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a2694fc43019f85c66b1f88b4db924f85"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::DataHandler::scan </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt;&gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan an empty tuple from stream. </p>
<p>Function overload that does nothing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td><a class="el" href="exceptionInput.html" title="Input utilities for raytracing.">Input</a> stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the stream has no failure, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a2f0d2f234267a5c274662c6fe48fe988"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::DataHandler::scan </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type &amp;&#160;</td>
          <td class="paramname"><em>variable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan a single variable from stream. </p>
<p>Scans the next variable from the stream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>(Variable type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td><a class="el" href="exceptionInput.html" title="Input utilities for raytracing.">Input</a> stream. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">variable</td><td>Variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the stream has no failure, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="adefa5bd26a29d5b13d3f94a45bd99973"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::DataHandler::scan </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type &amp;&#160;</td>
          <td class="paramname"><em>variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Types &amp;...&#160;</td>
          <td class="paramname"><em>variables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan several variables from stream. </p>
<p>Scans the next variables from the stream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>(Variable type.) </td></tr>
    <tr><td class="paramname">Types</td><td>(Variadic types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td><a class="el" href="exceptionInput.html" title="Input utilities for raytracing.">Input</a> stream. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">variable</td><td>Variable. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">variables</td><td>Variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the stream has no failure, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="abf322f4399f6008717153ca2338c1ab3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::size_t Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::DataHandler::scan </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; Type, Size &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan an array from stream. </p>
<p>Scans each element of the passed array from the stream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>(Array type.) </td></tr>
    <tr><td class="paramname">Size</td><td>(Array size.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td><a class="el" href="exceptionInput.html" title="Input utilities for raytracing.">Input</a> stream. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">container</td><td>Array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the stream has no failure, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="afcdea61c7011b22539e783c9fb782e07"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int Current, typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::DataHandler::scan </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; Types...&gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan a tuple from stream. </p>
<p>Scans each element of the passed tuple from the stream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Current</td><td>(Current level of recursion.) </td></tr>
    <tr><td class="paramname">Types</td><td>(Variadic types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td><a class="el" href="exceptionInput.html" title="Input utilities for raytracing.">Input</a> stream. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">container</td><td>Tuple. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the stream has no failure, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ac4e7131096c0eeb8f86b6d017ed1edb2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned int magrathea::DataHandler::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of elements of several types. </p>
<p>Computes the number of elements of the passed types. Note that if the passed type is a templated type, like a tuple, the inner arguments are not extracted, and the result is simply the same as <code>sizeof...()</code> . </p>
<dl class="section return"><dt>Returns</dt><dd>Number of elements. </dd></dl>

</div>
</div>
<a class="anchor" id="a46e1fde9798b019bc5b033e2e17fa7db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned int magrathea::DataHandler::size </td>
          <td>(</td>
          <td class="paramtype">const std::tuple&lt;&gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of elements of an empty tuple. </p>
<p>Function overload that does nothing. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of elements. </dd></dl>

</div>
</div>
<a class="anchor" id="af8c18351676d2ac685b22524986bba92"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned int magrathea::DataHandler::size </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>variable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of elements of a single variable. </p>
<p>Computes the number of elements of the passed variable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>(Variable type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">variable</td><td>Variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements. </dd></dl>

</div>
</div>
<a class="anchor" id="a729d47a64d97ca03141eed087a0568d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned int magrathea::DataHandler::size </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Types &amp;...&#160;</td>
          <td class="paramname"><em>variables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of elements of several variables. </p>
<p>Computes the number of elements of the passed variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>(Variable type.) </td></tr>
    <tr><td class="paramname">Types</td><td>(Variadic types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">variable</td><td>Variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">variables</td><td>Variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements. </dd></dl>

</div>
</div>
<a class="anchor" id="aeb6e50e89fe939e797450f8428dc40dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::size_t Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned int magrathea::DataHandler::size </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; Type, Size &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of elements of an array. </p>
<p>Computes the number of elements of the passed array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>(Array type.) </td></tr>
    <tr><td class="paramname">Size</td><td>(Array size.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>Array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements. </dd></dl>

</div>
</div>
<a class="anchor" id="abe440e8dde8a25b9bdfbb64dbb2c26db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int Current, typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned int magrathea::DataHandler::size </td>
          <td>(</td>
          <td class="paramtype">const std::tuple&lt; Types...&gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of elements of a tuple. </p>
<p>Computes the number of elements of the passed tuple. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Current</td><td>(Current level of recursion.) </td></tr>
    <tr><td class="paramname">Types</td><td>(Variadic types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>Tuple. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements. </dd></dl>

</div>
</div>
<a class="anchor" id="aabe5421ff733fe6beebb8c738d1fee63"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int Base, char Leading&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string magrathea::DataHandler::stringify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert nothing to a string. </p>
<p>Function overload that does nothing. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Base</td><td>Base representation for integers : 2, 8, 10 or 16. </td></tr>
    <tr><td class="paramname">Leading</td><td>Leading character for integers : 0, 9-13 or 32-126. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String conversion of arguments. </dd></dl>

</div>
</div>
<a class="anchor" id="a7c4ab445f48e1aa494a404e904c54a66"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int Base, char Leading&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string magrathea::DataHandler::stringify </td>
          <td>(</td>
          <td class="paramtype">const std::tuple&lt;&gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an empty tuple to a string. </p>
<p>Function overload that does nothing. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Base</td><td>Base representation for integers : 2, 8, 10 or 16. </td></tr>
    <tr><td class="paramname">Leading</td><td>Leading character for integers : 0, 9-13 or 32-126. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String conversion of arguments. </dd></dl>

</div>
</div>
<a class="anchor" id="a2dd735cedf604372d2942820919a2b0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int Base, char Leading, typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string magrathea::DataHandler::stringify </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>variable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a single variable to a string. </p>
<p>Converts the passed variable to a string. The base of conversion can be specified for integral numbers, and it is possible to fill-in the result with leading characters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Base</td><td>Base representation for integers : 2, 8, 10 or 16. </td></tr>
    <tr><td class="paramname">Leading</td><td>Leading character for integers : 0, 9-13 or 32-126. </td></tr>
    <tr><td class="paramname">Type</td><td>(Variable type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">variable</td><td>Variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String conversion of arguments. </dd></dl>

</div>
</div>
<a class="anchor" id="ab54ac4f7f22feb5b1e7361d321342746"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int Base, char Leading, typename Type , typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string magrathea::DataHandler::stringify </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Types &amp;...&#160;</td>
          <td class="paramname"><em>variables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert several variables to a string. </p>
<p>Converts the passed variables to a string. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Base</td><td>Base representation for integers : 2, 8, 10 or 16. </td></tr>
    <tr><td class="paramname">Leading</td><td>Leading character for integers : 0, 9-13 or 32-126. </td></tr>
    <tr><td class="paramname">Type</td><td>(Variable type.) </td></tr>
    <tr><td class="paramname">Types</td><td>(Variadic types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">variable</td><td>Variable. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">variables</td><td>Variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String conversion of arguments. </dd></dl>

</div>
</div>
<a class="anchor" id="a71fe2f753a75d7367c34bd035e7e3d62"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int Base, char Leading, typename Type , std::size_t Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string magrathea::DataHandler::stringify </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; Type, Size &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an array to a string. </p>
<p>Converts each element of the passed array to a string. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Base</td><td>Base representation for integers : 2, 8, 10 or 16. </td></tr>
    <tr><td class="paramname">Leading</td><td>Leading character for integers : 0, 9-13 or 32-126. </td></tr>
    <tr><td class="paramname">Type</td><td>(Array type.) </td></tr>
    <tr><td class="paramname">Size</td><td>(Array size.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">container</td><td>Array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String conversion of arguments. </dd></dl>

</div>
</div>
<a class="anchor" id="a172045642951acb95fb0a84595aa9e56"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int Base, char Leading, unsigned int Current, typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string magrathea::DataHandler::stringify </td>
          <td>(</td>
          <td class="paramtype">const std::tuple&lt; Types...&gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a tuple to a string. </p>
<p>Converts each element of the passed tuple to a string. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Base</td><td>Base representation for integers : 2, 8, 10 or 16. </td></tr>
    <tr><td class="paramname">Leading</td><td>Leading character for integers : 0, 9-13 or 32-126. </td></tr>
    <tr><td class="paramname">Current</td><td>(Current level of recursion.) </td></tr>
    <tr><td class="paramname">Types</td><td>(Variadic types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">container</td><td>Tuple. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String conversion of arguments. </dd></dl>

</div>
</div>
<a class="anchor" id="a40c596c3e2059535c1649654fe8a7aa0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool magrathea::DataHandler::tuple </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is not a tuple. </p>
<p>Returns false as the passed argument is not a standard tuple. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether the argument is a standard tuple. </dd></dl>

</div>
</div>
<a class="anchor" id="a2249708da73286fe5f5a695ed202fa8c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool magrathea::DataHandler::tuple </td>
          <td>(</td>
          <td class="paramtype">const std::tuple&lt; Types...&gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is a tuple. </p>
<p>Returns true as the passed argument is a standard tuple. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether the argument is a standard tuple. </dd></dl>

</div>
</div>
<a class="anchor" id="a39a75e50677e501aa45368fcd1a9072c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::DataHandler::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write nothing to stream. </p>
<p>Function overload that does nothing. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness for writing if true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the stream has no failure, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ac03218d9c590597427d31e8d7fe8820b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::DataHandler::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::tuple&lt;&gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write an empty tuple to stream. </p>
<p>Function overload that does nothing. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness for writing if true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the stream has no failure, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a921c83976ebf7a55119f25d9589a6d71"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::DataHandler::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>variable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a single variable to stream. </p>
<p>Writes the next variable to the stream and swap bytes if necessary. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness for writing if true. </td></tr>
    <tr><td class="paramname">Type</td><td>(Variable type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">variable</td><td>Variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the stream has no failure, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aee67cc8c281a41a493d41a4a25f45bc9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, typename Type , typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::DataHandler::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Types &amp;...&#160;</td>
          <td class="paramname"><em>variables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write several variables to stream. </p>
<p>Writes the next variables to the stream and swap bytes if necessary. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness for writing if true. </td></tr>
    <tr><td class="paramname">Type</td><td>(Variable type.) </td></tr>
    <tr><td class="paramname">Types</td><td>(Variadic types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">variable</td><td>Variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">variables</td><td>Variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the stream has no failure, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ab61e11c5cd55fa2652511507291435"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, typename Type , std::size_t Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::DataHandler::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; Type, Size &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write an array to stream. </p>
<p>Writes each element of the passed array to the stream and swap bytes if necessary. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness for writing if true. </td></tr>
    <tr><td class="paramname">Type</td><td>(Array type.) </td></tr>
    <tr><td class="paramname">Size</td><td>(Array size.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>Array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the stream has no failure, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ab8fa581985c2e97824bb610459a4189f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, unsigned int Current, typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::DataHandler::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::tuple&lt; Types...&gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a tuple to stream. </p>
<p>Writes each element of the passed tuple to the stream and swap bytes if necessary. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness for writing if true. </td></tr>
    <tr><td class="paramname">Current</td><td>(Current level of recursion.) </td></tr>
    <tr><td class="paramname">Types</td><td>(Variadic types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>Tuple. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the stream has no failure, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a536f2b5c4b87cd899177ee5397df87b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char *&amp; magrathea::DataHandler::write </td>
          <td>(</td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write nothing to buffer. </p>
<p>Function overload that does nothing. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness for writing if true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new position in the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a40bb3b3f12dbbfb56f0ae4949ab775dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char *&amp; magrathea::DataHandler::write </td>
          <td>(</td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::tuple&lt;&gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write an empty tuple to buffer. </p>
<p>Function overload that does nothing. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness for writing if true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new position in the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a50f7ac2d71d0a6e12b9142f0164e5010"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char *&amp; magrathea::DataHandler::write </td>
          <td>(</td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>variable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a single variable to buffer. </p>
<p>Writes the next variable to the buffer and swap bytes if necessary. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness for writing if true. </td></tr>
    <tr><td class="paramname">Type</td><td>(Variable type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">variable</td><td>Variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new position in the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="abfa5fea125d9fc30fb1ead5d96a73b11"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, typename Type , typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char *&amp; magrathea::DataHandler::write </td>
          <td>(</td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Types &amp;...&#160;</td>
          <td class="paramname"><em>variables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write several variables to buffer. </p>
<p>Writes the next variables to the buffer and swap bytes if necessary. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness for writing if true. </td></tr>
    <tr><td class="paramname">Type</td><td>(Variable type.) </td></tr>
    <tr><td class="paramname">Types</td><td>(Variadic types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">variable</td><td>Variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">variables</td><td>Variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new position in the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="aedc8c73ee5a6027286662b816435f953"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, typename Type , std::size_t Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char *&amp; magrathea::DataHandler::write </td>
          <td>(</td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; Type, Size &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write an array to buffer. </p>
<p>Writes each element of the passed array to the buffer and swap bytes if necessary. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness for writing if true. </td></tr>
    <tr><td class="paramname">Type</td><td>(Array type.) </td></tr>
    <tr><td class="paramname">Size</td><td>(Array size.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>Array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new position in the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="ade92542ca2ae7dac44c5b573aaaea63a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, unsigned int Current, typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char *&amp; magrathea::DataHandler::write </td>
          <td>(</td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::tuple&lt; Types...&gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a tuple to buffer. </p>
<p>Writes each element of the passed tuple to the buffer and swap bytes if necessary. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness for writing if true. </td></tr>
    <tr><td class="paramname">Current</td><td>(Current level of recursion.) </td></tr>
    <tr><td class="paramname">Types</td><td>(Variadic types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>Tuple. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new position in the buffer. </dd></dl>

</div>
</div>
<hr/>The documentation for this exception was generated from the following file:<ul>
<li>/data/home/mbreton/magrathea_pathfinder/src/magrathea/<a class="el" href="datahandler_8h_source.html">datahandler.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 6 2021 17:41:39 for MAGRATHEA/PATHFINDER by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
