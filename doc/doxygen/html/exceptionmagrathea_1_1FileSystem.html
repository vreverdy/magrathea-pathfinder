<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>MAGRATHEA/PATHFINDER: magrathea::FileSystem Exception Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MAGRATHEA/PATHFINDER
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemagrathea.html">magrathea</a></li><li class="navelem"><a class="el" href="exceptionmagrathea_1_1FileSystem.html">FileSystem</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="exceptionmagrathea_1_1FileSystem-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">magrathea::FileSystem Exception Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Global file management.  
 <a href="exceptionmagrathea_1_1FileSystem.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="filesystem_8h_source.html">filesystem.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Utilities</div></td></tr>
<tr class="memitem:ac5ee917157fa4b42e78d30c0da0bf133"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1FileSystem.html#ac5ee917157fa4b42e78d30c0da0bf133">endianness</a> ()</td></tr>
<tr class="memdesc:ac5ee917157fa4b42e78d30c0da0bf133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get system endianness.  <a href="#ac5ee917157fa4b42e78d30c0da0bf133"></a><br/></td></tr>
<tr class="separator:ac5ee917157fa4b42e78d30c0da0bf133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d989cd366395e5ef84131f79134d7de"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap, typename Type , class  = typename std::enable_if&lt;!Byteswap&gt;::type&gt; </td></tr>
<tr class="memitem:a1d989cd366395e5ef84131f79134d7de"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1FileSystem.html#a1d989cd366395e5ef84131f79134d7de">byteswap</a> (const Type &amp;variable)</td></tr>
<tr class="memdesc:a1d989cd366395e5ef84131f79134d7de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do not swap bytes.  <a href="#a1d989cd366395e5ef84131f79134d7de"></a><br/></td></tr>
<tr class="separator:a1d989cd366395e5ef84131f79134d7de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64859ee869800ddcdc7c224a93703c59"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = true, typename Type , class  = typename std::enable_if&lt;Byteswap&gt;::type&gt; </td></tr>
<tr class="memitem:a64859ee869800ddcdc7c224a93703c59"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1FileSystem.html#a64859ee869800ddcdc7c224a93703c59">byteswap</a> (Type &amp;variable)</td></tr>
<tr class="memdesc:a64859ee869800ddcdc7c224a93703c59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap bytes.  <a href="#a64859ee869800ddcdc7c224a93703c59"></a><br/></td></tr>
<tr class="separator:a64859ee869800ddcdc7c224a93703c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5eac053ec39dbb33200d5f3e3915484"><td class="memTemplParams" colspan="2">template&lt;typename Type  = unsigned int, class  = typename std::enable_if&lt;std::is_integral&lt;Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ad5eac053ec39dbb33200d5f3e3915484"><td class="memTemplItemLeft" align="right" valign="top">static Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1FileSystem.html#ad5eac053ec39dbb33200d5f3e3915484">bom</a> ()</td></tr>
<tr class="memdesc:ad5eac053ec39dbb33200d5f3e3915484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte order mark.  <a href="#ad5eac053ec39dbb33200d5f3e3915484"></a><br/></td></tr>
<tr class="separator:ad5eac053ec39dbb33200d5f3e3915484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc7bab8ef392d0e64176fa9249f1f34"><td class="memTemplParams" colspan="2">template&lt;typename Type , class  = typename std::enable_if&lt;std::is_integral&lt;Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a8bc7bab8ef392d0e64176fa9249f1f34"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1FileSystem.html#a8bc7bab8ef392d0e64176fa9249f1f34">bom</a> (const Type &amp;mark)</td></tr>
<tr class="memdesc:a8bc7bab8ef392d0e64176fa9249f1f34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte order mark endianness.  <a href="#a8bc7bab8ef392d0e64176fa9249f1f34"></a><br/></td></tr>
<tr class="separator:a8bc7bab8ef392d0e64176fa9249f1f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Size</div></td></tr>
<tr class="memitem:ae163e0811a033225b60eac354e4e4b79"><td class="memTemplParams" colspan="2">template&lt;typename Type  = char, class Stream &gt; </td></tr>
<tr class="memitem:ae163e0811a033225b60eac354e4e4b79"><td class="memTemplItemLeft" align="right" valign="top">static long long int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1FileSystem.html#ae163e0811a033225b60eac354e4e4b79">weight</a> (Stream &amp;stream)</td></tr>
<tr class="memdesc:ae163e0811a033225b60eac354e4e4b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the weight of a file in terms of a specific type.  <a href="#ae163e0811a033225b60eac354e4e4b79"></a><br/></td></tr>
<tr class="separator:ae163e0811a033225b60eac354e4e4b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221bf898f3123b019033a104b54c545c"><td class="memItemLeft" align="right" valign="top">static long long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1FileSystem.html#a221bf898f3123b019033a104b54c545c">size</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:a221bf898f3123b019033a104b54c545c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get size of a file passed by name.  <a href="#a221bf898f3123b019033a104b54c545c"></a><br/></td></tr>
<tr class="separator:a221bf898f3123b019033a104b54c545c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dda7047196f0a54857709a39e0f0159"><td class="memItemLeft" align="right" valign="top">static long long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1FileSystem.html#a2dda7047196f0a54857709a39e0f0159">size</a> (std::istream &amp;stream)</td></tr>
<tr class="memdesc:a2dda7047196f0a54857709a39e0f0159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get size of a file passed by input stream.  <a href="#a2dda7047196f0a54857709a39e0f0159"></a><br/></td></tr>
<tr class="separator:a2dda7047196f0a54857709a39e0f0159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff3132806866f74d193f60bff56d6a9"><td class="memItemLeft" align="right" valign="top">static long long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1FileSystem.html#a2ff3132806866f74d193f60bff56d6a9">size</a> (std::ostream &amp;stream)</td></tr>
<tr class="memdesc:a2ff3132806866f74d193f60bff56d6a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get size of a file passed by output stream.  <a href="#a2ff3132806866f74d193f60bff56d6a9"></a><br/></td></tr>
<tr class="separator:a2ff3132806866f74d193f60bff56d6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Management</div></td></tr>
<tr class="memitem:ac8d575fbc1fbb3c49b96cfc80a3f19fa"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1FileSystem.html#ac8d575fbc1fbb3c49b96cfc80a3f19fa">temporary</a> (const std::string &amp;prefix=&quot;\b&quot;, const std::string &amp;suffix=&quot;&quot;)</td></tr>
<tr class="memdesc:ac8d575fbc1fbb3c49b96cfc80a3f19fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporary file name.  <a href="#ac8d575fbc1fbb3c49b96cfc80a3f19fa"></a><br/></td></tr>
<tr class="separator:ac8d575fbc1fbb3c49b96cfc80a3f19fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89c2d6a918b7d7c0c17ca5b59f98bce"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1FileSystem.html#af89c2d6a918b7d7c0c17ca5b59f98bce">dated</a> (const std::string &amp;prefix=&quot;&quot;, const std::string &amp;suffix=&quot;&quot;, const std::string &amp;format=&quot;%Y-%m-%d-%H-%M-%S&quot;)</td></tr>
<tr class="memdesc:af89c2d6a918b7d7c0c17ca5b59f98bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dated file name.  <a href="#af89c2d6a918b7d7c0c17ca5b59f98bce"></a><br/></td></tr>
<tr class="separator:af89c2d6a918b7d7c0c17ca5b59f98bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8dbf24aaa89c7a0509b675b5d71812"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1FileSystem.html#adb8dbf24aaa89c7a0509b675b5d71812">remove</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:adb8dbf24aaa89c7a0509b675b5d71812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a file.  <a href="#adb8dbf24aaa89c7a0509b675b5d71812"></a><br/></td></tr>
<tr class="separator:adb8dbf24aaa89c7a0509b675b5d71812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9d515761f4e5041c3eac9307d4d570"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1FileSystem.html#a3b9d515761f4e5041c3eac9307d4d570">rename</a> (const std::string &amp;oldname, const std::string &amp;newname, const std::ios::openmode &amp;mode=std::ios::out)</td></tr>
<tr class="memdesc:a3b9d515761f4e5041c3eac9307d4d570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename a file.  <a href="#a3b9d515761f4e5041c3eac9307d4d570"></a><br/></td></tr>
<tr class="separator:a3b9d515761f4e5041c3eac9307d4d570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb019d214bae39f7d75770908c9d025"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1FileSystem.html#a5fb019d214bae39f7d75770908c9d025">copy</a> (const std::string &amp;oldname, const std::string &amp;newname, const std::ios::openmode &amp;mode=std::ios::out, const long long int chunk=-1)</td></tr>
<tr class="memdesc:a5fb019d214bae39f7d75770908c9d025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy.  <a href="#a5fb019d214bae39f7d75770908c9d025"></a><br/></td></tr>
<tr class="separator:a5fb019d214bae39f7d75770908c9d025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Split and join</div></td></tr>
<tr class="memitem:ab76df44fc991333abf9ff6f003a057f4"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false, typename Marker  = long long int, class Container &gt; </td></tr>
<tr class="memitem:ab76df44fc991333abf9ff6f003a057f4"><td class="memTemplItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1FileSystem.html#ab76df44fc991333abf9ff6f003a057f4">split</a> (const std::string &amp;filename, const Container &amp;filenames, const std::ios::openmode &amp;mode=std::ios::out, const long long int chunk=-1, const unsigned long long int limit=0)</td></tr>
<tr class="memdesc:ab76df44fc991333abf9ff6f003a057f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a file in several files.  <a href="#ab76df44fc991333abf9ff6f003a057f4"></a><br/></td></tr>
<tr class="separator:ab76df44fc991333abf9ff6f003a057f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f237a31be083d0420877f7e50c0f8f"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false, typename Marker  = long long int, class Container &gt; </td></tr>
<tr class="memitem:ac9f237a31be083d0420877f7e50c0f8f"><td class="memTemplItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1FileSystem.html#ac9f237a31be083d0420877f7e50c0f8f">unsplit</a> (const Container &amp;filenames, const std::string &amp;filename, const std::ios::openmode &amp;mode=std::ios::out, const long long int chunk=-1)</td></tr>
<tr class="memdesc:ac9f237a31be083d0420877f7e50c0f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsplit several files in a file.  <a href="#ac9f237a31be083d0420877f7e50c0f8f"></a><br/></td></tr>
<tr class="separator:ac9f237a31be083d0420877f7e50c0f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546b2a27bbf077ab905c15ba3cfead65"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false, typename Marker  = long long int, class Container &gt; </td></tr>
<tr class="memitem:a546b2a27bbf077ab905c15ba3cfead65"><td class="memTemplItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1FileSystem.html#a546b2a27bbf077ab905c15ba3cfead65">join</a> (const Container &amp;filenames, const std::string &amp;filename, const std::ios::openmode &amp;mode=std::ios::out, const long long int chunk=-1)</td></tr>
<tr class="memdesc:a546b2a27bbf077ab905c15ba3cfead65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join several files in a file.  <a href="#a546b2a27bbf077ab905c15ba3cfead65"></a><br/></td></tr>
<tr class="separator:a546b2a27bbf077ab905c15ba3cfead65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b7681662209ad48ebef52c0f1a2e91"><td class="memTemplParams" colspan="2">template&lt;bool Byteswap = false, typename Marker  = long long int, class Container &gt; </td></tr>
<tr class="memitem:a37b7681662209ad48ebef52c0f1a2e91"><td class="memTemplItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1FileSystem.html#a37b7681662209ad48ebef52c0f1a2e91">unjoin</a> (const std::string &amp;filename, const Container &amp;filenames, const std::ios::openmode &amp;mode=std::ios::out, const long long int chunk=-1)</td></tr>
<tr class="memdesc:a37b7681662209ad48ebef52c0f1a2e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unjoin a file in several files.  <a href="#a37b7681662209ad48ebef52c0f1a2e91"></a><br/></td></tr>
<tr class="separator:a37b7681662209ad48ebef52c0f1a2e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Comparison</div></td></tr>
<tr class="memitem:ac26eddde6c5fa22440c29b81e8967290"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1FileSystem.html#ac26eddde6c5fa22440c29b81e8967290">compare</a> (const std::string &amp;first, const std::string &amp;second, const long long int chunk=-1)</td></tr>
<tr class="memdesc:ac26eddde6c5fa22440c29b81e8967290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two files passed by names.  <a href="#ac26eddde6c5fa22440c29b81e8967290"></a><br/></td></tr>
<tr class="separator:ac26eddde6c5fa22440c29b81e8967290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd721bd279d0095255b832f0e9032969"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1FileSystem.html#acd721bd279d0095255b832f0e9032969">compare</a> (std::istream &amp;first, std::istream &amp;second, const long long int chunk=-1)</td></tr>
<tr class="memdesc:acd721bd279d0095255b832f0e9032969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two files passed by input stream.  <a href="#acd721bd279d0095255b832f0e9032969"></a><br/></td></tr>
<tr class="separator:acd721bd279d0095255b832f0e9032969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a9323b17881fdddfe256bc2ade30e3"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1FileSystem.html#af2a9323b17881fdddfe256bc2ade30e3">compare</a> (std::ostream &amp;first, std::ostream &amp;second, const long long int chunk=-1)</td></tr>
<tr class="memdesc:af2a9323b17881fdddfe256bc2ade30e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two files passed by output stream.  <a href="#af2a9323b17881fdddfe256bc2ade30e3"></a><br/></td></tr>
<tr class="separator:af2a9323b17881fdddfe256bc2ade30e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Existence and creation</div></td></tr>
<tr class="memitem:ae75b7fb73e1a1c2cf21fad6da443fc9e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1FileSystem.html#ae75b7fb73e1a1c2cf21fad6da443fc9e">exist</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:ae75b7fb73e1a1c2cf21fad6da443fc9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check file existence.  <a href="#ae75b7fb73e1a1c2cf21fad6da443fc9e"></a><br/></td></tr>
<tr class="separator:ae75b7fb73e1a1c2cf21fad6da443fc9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0114471f9d98afd6e524b3dcf6ab4e"><td class="memTemplParams" colspan="2">template&lt;typename Type  = char&gt; </td></tr>
<tr class="memitem:aab0114471f9d98afd6e524b3dcf6ab4e"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1FileSystem.html#aab0114471f9d98afd6e524b3dcf6ab4e">check</a> (const std::string &amp;filename, const long long int min=-1, const long long int max=-1)</td></tr>
<tr class="memdesc:aab0114471f9d98afd6e524b3dcf6ab4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check file consistency.  <a href="#aab0114471f9d98afd6e524b3dcf6ab4e"></a><br/></td></tr>
<tr class="separator:aab0114471f9d98afd6e524b3dcf6ab4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b9ba26d56d0d899b3b81521a54c9c2"><td class="memTemplParams" colspan="2">template&lt;class Contents  = std::true_type&gt; </td></tr>
<tr class="memitem:a03b9ba26d56d0d899b3b81521a54c9c2"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1FileSystem.html#a03b9ba26d56d0d899b3b81521a54c9c2">create</a> (const std::string &amp;filename, const <a class="el" href="exceptionmagrathea_1_1Contents.html">Contents</a> &amp;contents=<a class="el" href="exceptionmagrathea_1_1Contents.html">Contents</a>())</td></tr>
<tr class="memdesc:a03b9ba26d56d0d899b3b81521a54c9c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a file.  <a href="#a03b9ba26d56d0d899b3b81521a54c9c2"></a><br/></td></tr>
<tr class="separator:a03b9ba26d56d0d899b3b81521a54c9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1404089cc3cdb33aa4037db8a22448fc"><td class="memTemplParams" colspan="2">template&lt;class Contents  = std::true_type&gt; </td></tr>
<tr class="memitem:a1404089cc3cdb33aa4037db8a22448fc"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1FileSystem.html#a1404089cc3cdb33aa4037db8a22448fc">initialize</a> (const std::string &amp;filename, const <a class="el" href="exceptionmagrathea_1_1Contents.html">Contents</a> &amp;contents=<a class="el" href="exceptionmagrathea_1_1Contents.html">Contents</a>())</td></tr>
<tr class="memdesc:a1404089cc3cdb33aa4037db8a22448fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a new file.  <a href="#a1404089cc3cdb33aa4037db8a22448fc"></a><br/></td></tr>
<tr class="separator:a1404089cc3cdb33aa4037db8a22448fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e3c1fa21f46bf45f17dde1ed900fac"><td class="memTemplParams" colspan="2">template&lt;class Contents  = std::true_type&gt; </td></tr>
<tr class="memitem:a65e3c1fa21f46bf45f17dde1ed900fac"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1FileSystem.html#a65e3c1fa21f46bf45f17dde1ed900fac">reset</a> (const std::string &amp;filename, const <a class="el" href="exceptionmagrathea_1_1Contents.html">Contents</a> &amp;contents=<a class="el" href="exceptionmagrathea_1_1Contents.html">Contents</a>())</td></tr>
<tr class="memdesc:a65e3c1fa21f46bf45f17dde1ed900fac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset an existing file.  <a href="#a65e3c1fa21f46bf45f17dde1ed900fac"></a><br/></td></tr>
<tr class="separator:a65e3c1fa21f46bf45f17dde1ed900fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0345d27cbaef759355440effaff913"><td class="memTemplParams" colspan="2">template&lt;class Contents  = char, class  = typename std::enable_if&lt;!std::is_convertible&lt;Contents, std::string&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:adb0345d27cbaef759355440effaff913"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1FileSystem.html#adb0345d27cbaef759355440effaff913">generate</a> (const std::string &amp;filename, const std::ios::openmode &amp;mode, const long long int amount, const long long int chunk=-1, const <a class="el" href="exceptionmagrathea_1_1Contents.html">Contents</a> &amp;contents=<a class="el" href="exceptionmagrathea_1_1Contents.html">Contents</a>())</td></tr>
<tr class="memdesc:adb0345d27cbaef759355440effaff913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a binary file based on contents.  <a href="#adb0345d27cbaef759355440effaff913"></a><br/></td></tr>
<tr class="separator:adb0345d27cbaef759355440effaff913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff977ee70d9313ae9cb9e93ac92cde8d"><td class="memTemplParams" colspan="2">template&lt;class Contents , class  = typename std::enable_if&lt;std::is_convertible&lt;Contents, std::string&gt;::value&gt;::type, class  = void&gt; </td></tr>
<tr class="memitem:aff977ee70d9313ae9cb9e93ac92cde8d"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1FileSystem.html#aff977ee70d9313ae9cb9e93ac92cde8d">generate</a> (const std::string &amp;filename, const std::ios::openmode &amp;mode, const long long int amount, const long long int chunk, const <a class="el" href="exceptionmagrathea_1_1Contents.html">Contents</a> &amp;contents)</td></tr>
<tr class="separator:aff977ee70d9313ae9cb9e93ac92cde8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0a5f524e5888a850c94b2404fef886"><td class="memTemplParams" colspan="2">template&lt;class Engine , class Distribution , class Contents  = typename std::decay&lt;Distribution&gt;::type::result_type, class  = typename std::enable_if&lt;(std::decay&lt;Engine&gt;::type::min() != std::decay&lt;Engine&gt;::type::max()) &amp;&amp; (!std::is_void&lt;typename std::decay&lt;Distribution&gt;::type::result_type&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:abc0a5f524e5888a850c94b2404fef886"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1FileSystem.html#abc0a5f524e5888a850c94b2404fef886">generate</a> (const std::string &amp;filename, const std::ios::openmode &amp;mode, const long long int amount, const long long int chunk, Engine &amp;&amp;engine, Distribution &amp;&amp;distribution)</td></tr>
<tr class="memdesc:abc0a5f524e5888a850c94b2404fef886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random binary file.  <a href="#abc0a5f524e5888a850c94b2404fef886"></a><br/></td></tr>
<tr class="separator:abc0a5f524e5888a850c94b2404fef886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Size control</div></td></tr>
<tr class="memitem:aa5ab15c43fde776dea907791626dd923"><td class="memTemplParams" colspan="2">template&lt;typename Type  = char, class Stream &gt; </td></tr>
<tr class="memitem:aa5ab15c43fde776dea907791626dd923"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1FileSystem.html#aa5ab15c43fde776dea907791626dd923">empty</a> (Stream &amp;stream)</td></tr>
<tr class="memdesc:aa5ab15c43fde776dea907791626dd923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty file.  <a href="#aa5ab15c43fde776dea907791626dd923"></a><br/></td></tr>
<tr class="separator:aa5ab15c43fde776dea907791626dd923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cd28f91dc3b950c9e66842a57717b74"><td class="memTemplParams" colspan="2">template&lt;typename Type  = char, class Stream &gt; </td></tr>
<tr class="memitem:a1cd28f91dc3b950c9e66842a57717b74"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1FileSystem.html#a1cd28f91dc3b950c9e66842a57717b74">exact</a> (Stream &amp;stream, const long long int amount)</td></tr>
<tr class="memdesc:a1cd28f91dc3b950c9e66842a57717b74"><td class="mdescLeft">&#160;</td><td class="mdescRight">File of exact specified size.  <a href="#a1cd28f91dc3b950c9e66842a57717b74"></a><br/></td></tr>
<tr class="separator:a1cd28f91dc3b950c9e66842a57717b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b8ebf32ffef006ddd544f27ebaaca5"><td class="memTemplParams" colspan="2">template&lt;typename Type  = char, class Stream &gt; </td></tr>
<tr class="memitem:aa6b8ebf32ffef006ddd544f27ebaaca5"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1FileSystem.html#aa6b8ebf32ffef006ddd544f27ebaaca5">regular</a> (Stream &amp;stream, const long long int min=-1, const long long int max=-1)</td></tr>
<tr class="memdesc:aa6b8ebf32ffef006ddd544f27ebaaca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Regular file.  <a href="#aa6b8ebf32ffef006ddd544f27ebaaca5"></a><br/></td></tr>
<tr class="separator:aa6b8ebf32ffef006ddd544f27ebaaca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">File types</div></td></tr>
<tr class="memitem:a1f15b71c69f7aa799b8012209e749fbd"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1FileSystem.html#a1f15b71c69f7aa799b8012209e749fbd">ascii</a> (const std::string &amp;filename, const long long int min=-1, const long long int max=-1, const long long int chunk=-1)</td></tr>
<tr class="memdesc:a1f15b71c69f7aa799b8012209e749fbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ascii file.  <a href="#a1f15b71c69f7aa799b8012209e749fbd"></a><br/></td></tr>
<tr class="separator:a1f15b71c69f7aa799b8012209e749fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e62cc199cec0729e6d2516d5ba82f3c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1FileSystem.html#a3e62cc199cec0729e6d2516d5ba82f3c">eascii</a> (const std::string &amp;filename, const long long int min=-1, const long long int max=-1, const long long int chunk=-1)</td></tr>
<tr class="memdesc:a3e62cc199cec0729e6d2516d5ba82f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extended ascii file.  <a href="#a3e62cc199cec0729e6d2516d5ba82f3c"></a><br/></td></tr>
<tr class="separator:a3e62cc199cec0729e6d2516d5ba82f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99f1baaaac4e91b2bfdb38798e20263"><td class="memTemplParams" colspan="2">template&lt;typename Type  = char&gt; </td></tr>
<tr class="memitem:aa99f1baaaac4e91b2bfdb38798e20263"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1FileSystem.html#aa99f1baaaac4e91b2bfdb38798e20263">binary</a> (const std::string &amp;filename, const long long int min=-1, const long long int max=-1, const long long int chunk=-1)</td></tr>
<tr class="memdesc:aa99f1baaaac4e91b2bfdb38798e20263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary file.  <a href="#aa99f1baaaac4e91b2bfdb38798e20263"></a><br/></td></tr>
<tr class="separator:aa99f1baaaac4e91b2bfdb38798e20263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Test</div></td></tr>
<tr class="memitem:a36d84f3342bac68ef5b4c92bc3965041"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1FileSystem.html#a36d84f3342bac68ef5b4c92bc3965041">example</a> ()</td></tr>
<tr class="memdesc:a36d84f3342bac68ef5b4c92bc3965041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Example function.  <a href="#a36d84f3342bac68ef5b4c92bc3965041"></a><br/></td></tr>
<tr class="separator:a36d84f3342bac68ef5b4c92bc3965041"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Global file management. </p>
<p>Provides general functions to manage files, retrieve some information and perform standard operations on files. All functions are standard-compliant, but use either C++ or C depending on performances. Most functions return whether the operation is a success and do not throw any exception. In the class, an unit means the size in bytes of a provided type. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1f15b71c69f7aa799b8012209e749fbd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::FileSystem::ascii </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long int&#160;</td>
          <td class="paramname"><em>min</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long int&#160;</td>
          <td class="paramname"><em>max</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long int&#160;</td>
          <td class="paramname"><em>chunk</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ascii file. </p>
<p>Tests whether the file is an ascii file containing between the minimum and maximum amount of bytes and using the chunk parameter to control the buffer size. A file is considered as ascii if all its bytes are in the ranges [9, 13] or [32, 126]. An empty file is considered as an ascii file. A value of -1 for the minimum or for the maximum means that this boundary is not tested. Finally, the chunk parameter allows to specify whether a buffer is used in binary mode : 0 corresponds to no buffer, a positive integer corresponds to the amount of contents that is put into the buffer, and a negative integer corresponds to a buffer of the total size of the file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>File name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min</td><td>Check if the file contains at least this amount of data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>Check if the file contains at most this amount of data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">chunk</td><td>Buffer size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the file is an ascii file satisfying the provided conditions, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aa99f1baaaac4e91b2bfdb38798e20263"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::FileSystem::binary </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long int&#160;</td>
          <td class="paramname"><em>min</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long int&#160;</td>
          <td class="paramname"><em>max</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long int&#160;</td>
          <td class="paramname"><em>chunk</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binary file. </p>
<p>Tests whether the file is a binary file containing between the minimum and maximum amount of data and using the chunk parameter to control the buffer size. A file is considered as binary if it has a byte outside of the ranges [9, 13] or [32, 126], or [128, 255]. An empty file is not considered as a binary file. If the file size is not divisible by the specified unit, the function returns false. A value of -1 for the minimum or for the maximum means that this boundary is not tested. Finally, the chunk parameter allows to specify whether a buffer is used in binary mode : 0 corresponds to no buffer, a positive integer corresponds to the amount of contents that is put into the buffer, and a negative integer corresponds to a buffer of the total size of the file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>File name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min</td><td>Check if the file contains at least this amount of data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>Check if the file contains at most this amount of data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">chunk</td><td>Buffer size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the file is a binary file satisfying the provided conditions, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ad5eac053ec39dbb33200d5f3e3915484"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type magrathea::FileSystem::bom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Byte order mark. </p>
<p>Returns the byte order mark 0xFEFF casted to the provided type. It is used to detect the endianness : for example, for a 4-bytes integer : 00-00-FE-FF indicates big-endianness and FF-FE-00-00 indicates little-endianness. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Integral byte order mark type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cast of 0xFEFF. </dd></dl>

</div>
</div>
<a class="anchor" id="a8bc7bab8ef392d0e64176fa9249f1f34"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::FileSystem::bom </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>mark</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Byte order mark endianness. </p>
<p>Returns endianness from byte order mark passed as parameter : true for big-endian, false for little-endian. The byte order mark should be of the form FE-FF. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>(Integral byte order mark type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mark</td><td>Byte order mark. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True for big-endian, false for little-endian. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Unrecognized byte order mark. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1d989cd366395e5ef84131f79134d7de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, typename Type , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::FileSystem::byteswap </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>variable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do not swap bytes. </p>
<p>Does not invert the order of bytes of the passed variable to keep the endianness. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Do not swap endianness if false. </td></tr>
    <tr><td class="paramname">Type</td><td>(Variable type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">variable</td><td>Variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if the variable has not been byteswapped. </dd></dl>

</div>
</div>
<a class="anchor" id="a64859ee869800ddcdc7c224a93703c59"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, typename Type , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::FileSystem::byteswap </td>
          <td>(</td>
          <td class="paramtype">Type &amp;&#160;</td>
          <td class="paramname"><em>variable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap bytes. </p>
<p>Inverts the order of bytes of the passed variable to change the endianness. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness if true. </td></tr>
    <tr><td class="paramname">Type</td><td>(Variable type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">variable</td><td>Variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the variable has been byteswapped. </dd></dl>

</div>
</div>
<a class="anchor" id="aab0114471f9d98afd6e524b3dcf6ab4e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::FileSystem::check </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long int&#160;</td>
          <td class="paramname"><em>min</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long int&#160;</td>
          <td class="paramname"><em>max</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check file consistency. </p>
<p>Returns whether the file can be opened successfully and whether it contains between the minimum and the maximum data of the provided type. If the total size is not divisible by the size of the type, the function returns false. If the file is not empty, reading a byte is also tested. A value of -1 for the minimum or for the maximum means that this boundary is not tested. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type representing the considered unit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>File name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min</td><td>Check if the file contains at least this amount of data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>Check if the file contains at most this amount of data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the file can be opened an is compliant to the provided parameters, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ac26eddde6c5fa22440c29b81e8967290"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::FileSystem::compare </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long int&#160;</td>
          <td class="paramname"><em>chunk</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two files passed by names. </p>
<p>Compares two files from their file names and return true if both can be tested without errors, have the same size, and have the same contents. A file compared to itself returns true whether it can be opened without errors. Finally, the chunk parameter allows to specify whether a buffer is used for the comparison : 0 corresponds to no buffer, a positive integer corresponds to the amount of bytes that is put into the buffer, and a negative integer corresponds to a buffer of the total size of the file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>First file name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">second</td><td>Second file name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">chunk</td><td>Buffer size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if both files compares equal without errors, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="acd721bd279d0095255b832f0e9032969"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::FileSystem::compare </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long int&#160;</td>
          <td class="paramname"><em>chunk</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two files passed by input stream. </p>
<p>Compares two opened input streams and return true if both can be tested without errors, have the same size, and have the same contents. A stream compared to itself returns true whether it can be accessed without errors. Finally, the chunk parameter allows to specify whether a buffer is used for the comparison : 0 corresponds to no buffer, a positive integer corresponds to the amount of bytes that is put into the buffer, and a negative integer corresponds to a buffer of the total size of the file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">first</td><td>First input stream. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">second</td><td>Second input stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">chunk</td><td>Buffer size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if both input streams compares equal without errors, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="af2a9323b17881fdddfe256bc2ade30e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::FileSystem::compare </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long int&#160;</td>
          <td class="paramname"><em>chunk</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two files passed by output stream. </p>
<p>Compares two opened output streams and return true if both can be tested without errors and have the same size as no further comparison can be done with output streams. Finally, the chunk parameter allows to specify whether a buffer is used for the comparison : 0 corresponds to no buffer, a positive integer corresponds to the amount of bytes that is put into the buffer, and negative integer corresponds to a buffer of the total size of the file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">first</td><td>First output stream. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">second</td><td>Second output stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">chunk</td><td>Buffer size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if both output streams compares equal without errors, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a5fb019d214bae39f7d75770908c9d025"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::FileSystem::copy </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>oldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::ios::openmode &amp;&#160;</td>
          <td class="paramname"><em>mode</em> = <code>std::ios::out</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long int&#160;</td>
          <td class="paramname"><em>chunk</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy. </p>
<p>Copy the provided file to a new location. If the old and new names are equal, the function returns false without further tests. By default, if a standard output open mode is specified, all existing files are protected and only a new one can be created. This protection can be removed by explicitely specifying the truncate open mode. Finally, the chunk parameter allows to specify whether a buffer is used for the copy : 0 corresponds to no buffer, a positive integer corresponds to the amount of bytes that is put into the buffer, and a negative integer corresponds to a buffer of the total size of the file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">oldname</td><td>Old file name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newname</td><td>New file name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Open mode. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">chunk</td><td>Buffer size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the copy was done without errors, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a03b9ba26d56d0d899b3b81521a54c9c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Contents &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::FileSystem::create </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="exceptionmagrathea_1_1Contents.html">Contents</a> &amp;&#160;</td>
          <td class="paramname"><em>contents</em> = <code><a class="el" href="exceptionmagrathea_1_1Contents.html">Contents</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a file. </p>
<p>Creates a file, overwriting any previous file if needed. This is equivalent to create a new file using an <code>std::ofstream</code> and the <code>std::ios::trunc</code> open mode. The extra parameter allows to initialize the file with contents : if this parameter is convertible to a string, the file is opened as a text file, otherwise it is considered as a binary file. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="exceptionmagrathea_1_1Contents.html" title="Basic implementation of numerical simulation contents.">Contents</a></td><td><a class="el" href="exceptionmagrathea_1_1Contents.html" title="Basic implementation of numerical simulation contents.">Contents</a> type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>File name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">contents</td><td><a class="el" href="exceptionmagrathea_1_1Contents.html" title="Basic implementation of numerical simulation contents.">Contents</a> to add to the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the file was created without errors, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="af89c2d6a918b7d7c0c17ca5b59f98bce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string magrathea::FileSystem::dated </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>suffix</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>format</em> = <code>&quot;%Y-%m-%d-%H-%M-%S&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dated file name. </p>
<p>Generates a file name from the current time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix</td><td>File name prefix or path. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">suffix</td><td>File name suffix or extension. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Date format compatible with <code>strftime()</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Generated dated file name. </dd></dl>

</div>
</div>
<a class="anchor" id="a3e62cc199cec0729e6d2516d5ba82f3c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::FileSystem::eascii </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long int&#160;</td>
          <td class="paramname"><em>min</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long int&#160;</td>
          <td class="paramname"><em>max</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long int&#160;</td>
          <td class="paramname"><em>chunk</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extended ascii file. </p>
<p>Tests whether the file is an extended ascii file containing between the minimum and maximum amount of bytes and using the chunk parameter to control the buffer size. A file is considered as extended ascii if all its bytes are in the ranges [9, 13] or [32, 126], or [128, 255]. An empty file is considered as an extended ascii file. A value of -1 for the minimum or for the maximum means that this boundary is not tested. Finally, the chunk parameter allows to specify whether a buffer is used in binary mode : 0 corresponds to no buffer, a positive integer corresponds to the amount of contents that is put into the buffer, and a negative integer corresponds to a buffer of the total size of the file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>File name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min</td><td>Check if the file contains at least this amount of data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>Check if the file contains at most this amount of data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">chunk</td><td>Buffer size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the file is an extended ascii file satisfying the provided conditions, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aa5ab15c43fde776dea907791626dd923"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , class Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::FileSystem::empty </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empty file. </p>
<p>Returns whether the file exists and is empty. The unit type is here for compatibility reasons with other size control functions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type representing the considered unit. </td></tr>
    <tr><td class="paramname">Stream</td><td>(String, input stream or output stream.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td>Stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the file size is null, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ac5ee917157fa4b42e78d30c0da0bf133"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::FileSystem::endianness </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get system endianness. </p>
<p>Returns the system endianness tested with an integer. </p>
<dl class="section return"><dt>Returns</dt><dd>True for big-endian, false for little-endian. </dd></dl>

</div>
</div>
<a class="anchor" id="a1cd28f91dc3b950c9e66842a57717b74"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , class Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::FileSystem::exact </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long int&#160;</td>
          <td class="paramname"><em>amount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>File of exact specified size. </p>
<p>Returns whether the file size measured in the specified unit is exactly equals to the value. For example if the specified type is an integer, and the value is equal to 4, it returns true if the file contains exactly 4 integers. A value equals to -1 returns true if the file size cannot be computed. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type representing the considered unit. </td></tr>
    <tr><td class="paramname">Stream</td><td>(String, input stream or output stream.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td>Stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">amount</td><td>Amount of contents to for comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the file size corresponds to the provided value, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a36d84f3342bac68ef5b4c92bc3965041"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int magrathea::FileSystem::example </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Example function. </p>
<p>Tests and demonstrates the use of <a class="el" href="exceptionmagrathea_1_1FileSystem.html" title="Global file management.">FileSystem</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if no error. </dd></dl>

</div>
</div>
<a class="anchor" id="ae75b7fb73e1a1c2cf21fad6da443fc9e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::FileSystem::exist </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check file existence. </p>
<p>Returns whether the file can be opened. The difference with the <code><a class="el" href="exceptionmagrathea_1_1FileSystem.html#aab0114471f9d98afd6e524b3dcf6ab4e" title="Check file consistency.">check()</a></code> function is that <code>exists()</code> use a C test without checking the C++ error bits. Consequently, it may be faster than the <code><a class="el" href="exceptionmagrathea_1_1FileSystem.html#aab0114471f9d98afd6e524b3dcf6ab4e" title="Check file consistency.">check()</a></code> implementation and therefore is well suited to check the existence of a large number of files. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>File name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the file exists, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="adb0345d27cbaef759355440effaff913"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Contents , class , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::FileSystem::generate </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::ios::openmode &amp;&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long int&#160;</td>
          <td class="paramname"><em>amount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long int&#160;</td>
          <td class="paramname"><em>chunk</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="exceptionmagrathea_1_1Contents.html">Contents</a> &amp;&#160;</td>
          <td class="paramname"><em>contents</em> = <code><a class="el" href="exceptionmagrathea_1_1Contents.html">Contents</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a binary file based on contents. </p>
<p>Generate a text file based on contents.</p>
<p>Creates a new file putting a repetition of the specified amount of contents in it. To use the binary mode, this contents should not be convertible to a string. By default, if a standard output open mode is specified, all existing files are protected and only a new one can be created. This protection can be removed by explicitely specifying the truncate open mode. Finally, the chunk parameter allows to specify whether a buffer is used in binary mode : 0 corresponds to no buffer, a positive integer corresponds to the amount of contents that is put into the buffer, and a negative integer corresponds to a buffer of the total size of the file. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="exceptionmagrathea_1_1Contents.html" title="Basic implementation of numerical simulation contents.">Contents</a></td><td>(<a class="el" href="exceptionmagrathea_1_1Contents.html" title="Basic implementation of numerical simulation contents.">Contents</a> type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>File name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Open mode. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">amount</td><td>Amount of contents to be put in the file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">chunk</td><td>Buffer size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">contents</td><td><a class="el" href="exceptionmagrathea_1_1Contents.html" title="Basic implementation of numerical simulation contents.">Contents</a> to add to the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the file was created without errors, false otherwise.</dd></dl>
<p>Creates a new text file putting a repetition of the specified amount of contents in it. To use the text mode, this contents should be convertible to a string. By default, if a standard output open mode is specified, all existing files are protected and only a new one can be created. This protection can be removed by explicitely specifying the truncate open mode. Finally, the chunk parameter allows to specify whether a buffer string is used in text mode : 0 corresponds to no buffer, a positive integer corresponds to the amount of contents copies that are put into the buffer, and a negative integer corresponds to a buffer of the total size of the file. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="exceptionmagrathea_1_1Contents.html" title="Basic implementation of numerical simulation contents.">Contents</a></td><td>(<a class="el" href="exceptionmagrathea_1_1Contents.html" title="Basic implementation of numerical simulation contents.">Contents</a> type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>File name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Open mode. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">amount</td><td>Amount of contents to be put in the file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">chunk</td><td>Buffer size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">contents</td><td><a class="el" href="exceptionmagrathea_1_1Contents.html" title="Basic implementation of numerical simulation contents.">Contents</a> to add to the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the file was created without errors, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aff977ee70d9313ae9cb9e93ac92cde8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Contents , class  = typename std::enable_if&lt;std::is_convertible&lt;Contents, std::string&gt;::value&gt;::type, class  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool magrathea::FileSystem::generate </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::ios::openmode &amp;&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long int&#160;</td>
          <td class="paramname"><em>amount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long int&#160;</td>
          <td class="paramname"><em>chunk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="exceptionmagrathea_1_1Contents.html">Contents</a> &amp;&#160;</td>
          <td class="paramname"><em>contents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abc0a5f524e5888a850c94b2404fef886"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Engine , class Distribution , class Contents , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::FileSystem::generate </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::ios::openmode &amp;&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long int&#160;</td>
          <td class="paramname"><em>amount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long int&#160;</td>
          <td class="paramname"><em>chunk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Engine &amp;&amp;&#160;</td>
          <td class="paramname"><em>engine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Distribution &amp;&amp;&#160;</td>
          <td class="paramname"><em>distribution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a random binary file. </p>
<p>Creates a new random file putting a repetition of the random numbers generated thanks to the specified engine and distribution and using the distribution result type as the contents type. By default, if a standard output open mode is specified, all existing files are protected and only a new one can be created. This protection can be removed by explicitely specifying the truncate open mode. Finally, the chunk parameter allows to specify whether a buffer is used in binary mode : 0 corresponds to no buffer, a positive integer corresponds to the amount of contents that is put into the buffer, and a negative integer corresponds to a buffer of the total size of the file. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Engine</td><td>(Random engine type.) </td></tr>
    <tr><td class="paramname">Distribution</td><td>(Random distribution type.) </td></tr>
    <tr><td class="paramname"><a class="el" href="exceptionmagrathea_1_1Contents.html" title="Basic implementation of numerical simulation contents.">Contents</a></td><td>(<a class="el" href="exceptionmagrathea_1_1Contents.html" title="Basic implementation of numerical simulation contents.">Contents</a> type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>File name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Open mode. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">amount</td><td>Amount of contents to be put in the file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">chunk</td><td>Buffer size. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">engine</td><td>Random engine. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">distribution</td><td>Random distribution. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the file was created without errors, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a1404089cc3cdb33aa4037db8a22448fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Contents &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::FileSystem::initialize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="exceptionmagrathea_1_1Contents.html">Contents</a> &amp;&#160;</td>
          <td class="paramname"><em>contents</em> = <code><a class="el" href="exceptionmagrathea_1_1Contents.html">Contents</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize a new file. </p>
<p>Creates a new file, without overwriting any previous file. This function is well suited to create a file without risking to erase some important existing data. The extra parameter allows to initialize the file with contents : if this parameter is convertible to a string, the file is opened as a text file, otherwise it is considered as a binary file. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="exceptionmagrathea_1_1Contents.html" title="Basic implementation of numerical simulation contents.">Contents</a></td><td><a class="el" href="exceptionmagrathea_1_1Contents.html" title="Basic implementation of numerical simulation contents.">Contents</a> type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>File name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">contents</td><td><a class="el" href="exceptionmagrathea_1_1Contents.html" title="Basic implementation of numerical simulation contents.">Contents</a> to add to the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the file was created without errors, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a546b2a27bbf077ab905c15ba3cfead65"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, typename Marker , class Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int magrathea::FileSystem::join </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>filenames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::ios::openmode &amp;&#160;</td>
          <td class="paramname"><em>mode</em> = <code>std::ios::out</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long int&#160;</td>
          <td class="paramname"><em>chunk</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Join several files in a file. </p>
<p>Joins the provided list of file into a single file. At the beginning and the end of each file a record marker of the file size in bytes is added. By default, if a standard output open mode is specified, all existing files are protected and only a new one can be created. This protection can be removed by explicitely specifying the truncate open mode. Finally, the chunk parameter allows to specify whether a buffer is used for the copy : 0 corresponds to no buffer, a positive integer corresponds to the amount of bytes that is put into the buffer, and a negative integer corresponds to a buffer of the total size of the file. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness of markers. </td></tr>
    <tr><td class="paramname">Marker</td><td>Record marker type. </td></tr>
    <tr><td class="paramname">Container</td><td>(File container type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filenames</td><td><a class="el" href="exceptionInput.html" title="Input utilities for raytracing.">Input</a> file names to join. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> file name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Open mode. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">chunk</td><td>Buffer size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of files written on success, zero on error. </dd></dl>

</div>
</div>
<a class="anchor" id="aa6b8ebf32ffef006ddd544f27ebaaca5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , class Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::FileSystem::regular </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long int&#160;</td>
          <td class="paramname"><em>min</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long int&#160;</td>
          <td class="paramname"><em>max</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Regular file. </p>
<p>Tests if the file is regular regarding to the provided options. It returns true if the file can be read without problems, if its size in bytes can be divided by the size of the provided type, and if its size in the specified unit is between the minimum and maximum provided amount of data. A value of -1 for the minimum or for the maximum means that this boundary is not tested. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type representing the considered unit. </td></tr>
    <tr><td class="paramname">Stream</td><td>(String, input stream or output stream.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td>Stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min</td><td>Check if the file contains at least this amount of data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>Check if the file contains at most this amount of data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the file size is regular regarding the parameters, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="adb8dbf24aaa89c7a0509b675b5d71812"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::FileSystem::remove </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a file. </p>
<p>Removes an existing file from the file system and returns true on success. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>File name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b9d515761f4e5041c3eac9307d4d570"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::FileSystem::rename </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>oldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::ios::openmode &amp;&#160;</td>
          <td class="paramname"><em>mode</em> = <code>std::ios::out</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rename a file. </p>
<p>Renames an existing file and returns true on success. If the old and new names are equal, the function returns false without further tests. If the new file name already exists, nothing is done and the function fails except if the truncate open mode is specified : in that case, the existing file is erased. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">oldname</td><td>Old name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newname</td><td>New name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Open mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a65e3c1fa21f46bf45f17dde1ed900fac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Contents &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool magrathea::FileSystem::reset </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="exceptionmagrathea_1_1Contents.html">Contents</a> &amp;&#160;</td>
          <td class="paramname"><em>contents</em> = <code><a class="el" href="exceptionmagrathea_1_1Contents.html">Contents</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset an existing file. </p>
<p>Erases the contents of an existing file without creating a new one if the specified name does not exist. This function is well suited to avoid the unexpected creation of new files. The extra parameter allows to initialize the file with contents : if this parameter is convertible to a string, the file is opened as a text file, otherwise it is considered as a binary file. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="exceptionmagrathea_1_1Contents.html" title="Basic implementation of numerical simulation contents.">Contents</a></td><td><a class="el" href="exceptionmagrathea_1_1Contents.html" title="Basic implementation of numerical simulation contents.">Contents</a> type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>File name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">contents</td><td><a class="el" href="exceptionmagrathea_1_1Contents.html" title="Basic implementation of numerical simulation contents.">Contents</a> to add to the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the file was created without errors, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a221bf898f3123b019033a104b54c545c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long long int magrathea::FileSystem::size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get size of a file passed by name. </p>
<p>Opens the file, computes its size and closes it. If the file does not exist or if a stream error is detected, -1 is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>File name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>File size in bytes or -1 if error. </dd></dl>

</div>
</div>
<a class="anchor" id="a2dda7047196f0a54857709a39e0f0159"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long long int magrathea::FileSystem::size </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get size of a file passed by input stream. </p>
<p>Saves the current position, computes the size of the passed stream and returns to the original position. If the file does not exist or if a stream error is detected, -1 is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td><a class="el" href="exceptionInput.html" title="Input utilities for raytracing.">Input</a> stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>File size in bytes or -1 if error. </dd></dl>

</div>
</div>
<a class="anchor" id="a2ff3132806866f74d193f60bff56d6a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long long int magrathea::FileSystem::size </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get size of a file passed by output stream. </p>
<p>Saves the current position, computes the size of the passed stream and returns to the original position. If the file does not exist or if a stream error is detected, -1 is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>File size in bytes or -1 if error. </dd></dl>

</div>
</div>
<a class="anchor" id="ab76df44fc991333abf9ff6f003a057f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, typename Marker , class Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int magrathea::FileSystem::split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>filenames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::ios::openmode &amp;&#160;</td>
          <td class="paramname"><em>mode</em> = <code>std::ios::out</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long int&#160;</td>
          <td class="paramname"><em>chunk</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long long int&#160;</td>
          <td class="paramname"><em>limit</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split a file in several files. </p>
<p>Splits the provided file into several ones of lower sizes. At the beginning and the end of each file, the current iterator byte position regarding the splitted file is saved as a marker. A beginning marker equals to zero corresponds to the first and an end marker equals to zero corresponds to the last file. The limit parameter allows to limit the size by file to an exact number of bytes. By default, if a standard output open mode is specified, all existing files are protected and only new ones can be created. This protection can be removed by explicitely specifying the truncate open mode. Finally, the chunk parameter allows to specify whether a buffer is used for the copy : 0 corresponds to no buffer, a positive integer corresponds to the amount of bytes that is put into the buffer, and a negative integer corresponds to a buffer of the total size of the file. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness of markers. </td></tr>
    <tr><td class="paramname">Marker</td><td>Record marker type. </td></tr>
    <tr><td class="paramname">Container</td><td>(File container type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td><a class="el" href="exceptionInput.html" title="Input utilities for raytracing.">Input</a> file name to split. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filenames</td><td><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> file names. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Open mode. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">chunk</td><td>Buffer size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">limit</td><td>Size limit of each file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of files written on success, zero on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ac8d575fbc1fbb3c49b96cfc80a3f19fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string magrathea::FileSystem::temporary </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>&quot;\b&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>suffix</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Temporary file name. </p>
<p>Generates a temporary file name. If no argument is used, then the default location is used. If an empty prefix is specified, the path is erased, and only the file name is kept. If a prefix or a suffix is specified, the default path is erased, the file name is kept and prefixed and suffixed by the arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix</td><td>File name prefix or path. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">suffix</td><td>File name suffix or extension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Generated temporary file name. </dd></dl>

</div>
</div>
<a class="anchor" id="a37b7681662209ad48ebef52c0f1a2e91"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, typename Marker , class Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int magrathea::FileSystem::unjoin </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>filenames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::ios::openmode &amp;&#160;</td>
          <td class="paramname"><em>mode</em> = <code>std::ios::out</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long int&#160;</td>
          <td class="paramname"><em>chunk</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unjoin a file in several files. </p>
<p>Unjoins the provided file into the original ones. The original marker size should correspond to the provided one. If output file names are not unique, the previous file is truncated or not depending on the specified open mode. By default, if a standard output open mode is specified, all existing files are protected and only new ones can be created. This protection can be removed by explicitely specifying the truncate open mode. Finally, the chunk parameter allows to specify whether a buffer is used for the copy : 0 corresponds to no buffer, a positive integer corresponds to the amount of bytes that is put into the buffer, and a negative integer corresponds to a buffer of the total size of the file. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness of markers. </td></tr>
    <tr><td class="paramname">Marker</td><td>Record marker type. </td></tr>
    <tr><td class="paramname">Container</td><td>(File container type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td><a class="el" href="exceptionInput.html" title="Input utilities for raytracing.">Input</a> file name to unjoin. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filenames</td><td><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> file names. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Open mode. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">chunk</td><td>Buffer size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of files written on success, zero on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ac9f237a31be083d0420877f7e50c0f8f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Byteswap, typename Marker , class Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int magrathea::FileSystem::unsplit </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>filenames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::ios::openmode &amp;&#160;</td>
          <td class="paramname"><em>mode</em> = <code>std::ios::out</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long int&#160;</td>
          <td class="paramname"><em>chunk</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsplit several files in a file. </p>
<p>Unsplits the provided list of files into the original one. The original marker size should correspond to the provided one. By default, if a standard output open mode is specified, all existing files are protected and only a new one can be created. This protection can be removed by explicitely specifying the truncate open mode. Finally, the chunk parameter allows to specify whether a buffer is used for the copy : 0 corresponds to no buffer, a positive integer corresponds to the amount of bytes that is put into the buffer, and a negative integer corresponds to a buffer of the total size of the file. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Byteswap</td><td>Swap endianness of markers. </td></tr>
    <tr><td class="paramname">Marker</td><td>Record marker type. </td></tr>
    <tr><td class="paramname">Container</td><td>(File container type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filenames</td><td><a class="el" href="exceptionInput.html" title="Input utilities for raytracing.">Input</a> file names to unsplit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> file name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Open mode. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">chunk</td><td>Buffer size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of files written on success, zero on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ae163e0811a033225b60eac354e4e4b79"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , class Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long long int magrathea::FileSystem::weight </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the weight of a file in terms of a specific type. </p>
<p>Returns the amount of data of the specified type equivalent to the file size. This is just the file size divided by the size of the specified type rounded to the lower integer. If the file does not exist or if a stream error is detected, -1 is returned. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type representing the considered unit. </td></tr>
    <tr><td class="paramname">Stream</td><td>(String, input stream or output stream.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td>Stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>File weight in unit or -1 if error. </dd></dl>

</div>
</div>
<hr/>The documentation for this exception was generated from the following file:<ul>
<li>/data/home/mbreton/magrathea_pathfinder/src/magrathea/<a class="el" href="filesystem_8h_source.html">filesystem.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 6 2021 17:41:39 for MAGRATHEA/PATHFINDER by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
