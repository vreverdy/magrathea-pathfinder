<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>MAGRATHEA/PATHFINDER: magrathea::StaticVectorizer&lt; Kind, Size, Crtp, Type, Parameters &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MAGRATHEA/PATHFINDER
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemagrathea.html">magrathea</a></li><li class="navelem"><a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classmagrathea_1_1StaticVectorizer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">magrathea::StaticVectorizer&lt; Kind, Size, Crtp, Type, Parameters &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Helper class for generic constant size vectorization.  
 <a href="classmagrathea_1_1StaticVectorizer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="staticvectorizer_8h_source.html">staticvectorizer.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for magrathea::StaticVectorizer&lt; Kind, Size, Crtp, Type, Parameters &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classmagrathea_1_1StaticVectorizer.png" usemap="#magrathea::StaticVectorizer&lt; Kind, Size, Crtp, Type, Parameters &gt;_map" alt=""/>
  <map id="magrathea::StaticVectorizer&lt; Kind, Size, Crtp, Type, Parameters &gt;_map" name="magrathea::StaticVectorizer&lt; Kind, Size, Crtp, Type, Parameters &gt;_map">
<area href="classmagrathea_1_1Vectorizer.html" title="Helper base class for generic vectorization." alt="magrathea::Vectorizer" shape="rect" coords="0,0,392,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Vectorization</div></td></tr>
<tr class="memitem:a4b5d5e63c27e77f1d734f80d7ca3d2df"><td class="memItemLeft" align="right" valign="top">Type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a4b5d5e63c27e77f1d734f80d7ca3d2df">operator[]</a> (const unsigned int i)</td></tr>
<tr class="memdesc:a4b5d5e63c27e77f1d734f80d7ca3d2df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the element.  <a href="#a4b5d5e63c27e77f1d734f80d7ca3d2df"></a><br/></td></tr>
<tr class="separator:a4b5d5e63c27e77f1d734f80d7ca3d2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf04553a28c73c6a6d04f2d29c8cdfeb"><td class="memItemLeft" align="right" valign="top">const Type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#adf04553a28c73c6a6d04f2d29c8cdfeb">operator[]</a> (const unsigned int i) const </td></tr>
<tr class="memdesc:adf04553a28c73c6a6d04f2d29c8cdfeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Immutable direct access to the element.  <a href="#adf04553a28c73c6a6d04f2d29c8cdfeb"></a><br/></td></tr>
<tr class="separator:adf04553a28c73c6a6d04f2d29c8cdfeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41dd9d48122248b8ee10d1ef372cd560"><td class="memItemLeft" align="right" valign="top">Crtp&lt; Type, Parameters...&gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a41dd9d48122248b8ee10d1ef372cd560">resize</a> (const unsigned int n)</td></tr>
<tr class="memdesc:a41dd9d48122248b8ee10d1ef372cd560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the container.  <a href="#a41dd9d48122248b8ee10d1ef372cd560"></a><br/></td></tr>
<tr class="separator:a41dd9d48122248b8ee10d1ef372cd560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Operators : assignment</div></td></tr>
<tr class="memitem:a53c433b861ee583956eeed639868cda0"><td class="memItemLeft" align="right" valign="top">Crtp&lt; Type, Parameters...&gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a53c433b861ee583956eeed639868cda0">operator=</a> (const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters...&gt; &amp;rhs)</td></tr>
<tr class="memdesc:a53c433b861ee583956eeed639868cda0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="#a53c433b861ee583956eeed639868cda0"></a><br/></td></tr>
<tr class="separator:a53c433b861ee583956eeed639868cda0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f365bb136ebe481ebadbc939379300"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , class  = typename std::enable_if&lt;std::is_convertible&lt;OtherType, Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:aa0f365bb136ebe481ebadbc939379300"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; Type, Parameters...&gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#aa0f365bb136ebe481ebadbc939379300">operator=</a> (const std::initializer_list&lt; OtherType &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aa0f365bb136ebe481ebadbc939379300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer list assignment operator.  <a href="#aa0f365bb136ebe481ebadbc939379300"></a><br/></td></tr>
<tr class="separator:aa0f365bb136ebe481ebadbc939379300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f80b1a26224671bcc94082b329703d0"><td class="memTemplParams" colspan="2">template&lt;class Misc &gt; </td></tr>
<tr class="memitem:a7f80b1a26224671bcc94082b329703d0"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; Type, Parameters...&gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a7f80b1a26224671bcc94082b329703d0">operator=</a> (const Misc &amp;rhs)</td></tr>
<tr class="memdesc:a7f80b1a26224671bcc94082b329703d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="#a7f80b1a26224671bcc94082b329703d0"></a><br/></td></tr>
<tr class="separator:a7f80b1a26224671bcc94082b329703d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Operators : compound assignement</div></td></tr>
<tr class="memitem:adeebb70a5bf1d4fe1e3c86fbd0830e1a"><td class="memTemplParams" colspan="2">template&lt;class GenericType &gt; </td></tr>
<tr class="memitem:adeebb70a5bf1d4fe1e3c86fbd0830e1a"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; Type, Parameters...&gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#adeebb70a5bf1d4fe1e3c86fbd0830e1a">operator+=</a> (const GenericType &amp;rhs)</td></tr>
<tr class="memdesc:adeebb70a5bf1d4fe1e3c86fbd0830e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment.  <a href="#adeebb70a5bf1d4fe1e3c86fbd0830e1a"></a><br/></td></tr>
<tr class="separator:adeebb70a5bf1d4fe1e3c86fbd0830e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb336da47554c90ce21eb1bba271630"><td class="memTemplParams" colspan="2">template&lt;class GenericType &gt; </td></tr>
<tr class="memitem:a1eb336da47554c90ce21eb1bba271630"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; Type, Parameters...&gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a1eb336da47554c90ce21eb1bba271630">operator-=</a> (const GenericType &amp;rhs)</td></tr>
<tr class="memdesc:a1eb336da47554c90ce21eb1bba271630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substraction assignment.  <a href="#a1eb336da47554c90ce21eb1bba271630"></a><br/></td></tr>
<tr class="separator:a1eb336da47554c90ce21eb1bba271630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ba80f798f95863f6e13d72d154b934"><td class="memTemplParams" colspan="2">template&lt;class GenericType &gt; </td></tr>
<tr class="memitem:ae5ba80f798f95863f6e13d72d154b934"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; Type, Parameters...&gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#ae5ba80f798f95863f6e13d72d154b934">operator*=</a> (const GenericType &amp;rhs)</td></tr>
<tr class="memdesc:ae5ba80f798f95863f6e13d72d154b934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication assignment.  <a href="#ae5ba80f798f95863f6e13d72d154b934"></a><br/></td></tr>
<tr class="separator:ae5ba80f798f95863f6e13d72d154b934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d79a23a4ef654dd107c1682a5fa8d0"><td class="memTemplParams" colspan="2">template&lt;class GenericType &gt; </td></tr>
<tr class="memitem:ac0d79a23a4ef654dd107c1682a5fa8d0"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; Type, Parameters...&gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#ac0d79a23a4ef654dd107c1682a5fa8d0">operator/=</a> (const GenericType &amp;rhs)</td></tr>
<tr class="memdesc:ac0d79a23a4ef654dd107c1682a5fa8d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division assignment.  <a href="#ac0d79a23a4ef654dd107c1682a5fa8d0"></a><br/></td></tr>
<tr class="separator:ac0d79a23a4ef654dd107c1682a5fa8d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c9e3e893460b9955602af8e30ef60c"><td class="memTemplParams" colspan="2">template&lt;class GenericType &gt; </td></tr>
<tr class="memitem:a47c9e3e893460b9955602af8e30ef60c"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; Type, Parameters...&gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a47c9e3e893460b9955602af8e30ef60c">operator%=</a> (const GenericType &amp;rhs)</td></tr>
<tr class="memdesc:a47c9e3e893460b9955602af8e30ef60c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modulo assignment.  <a href="#a47c9e3e893460b9955602af8e30ef60c"></a><br/></td></tr>
<tr class="separator:a47c9e3e893460b9955602af8e30ef60c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d6cd5651a735815e1af42ab3ea21a6"><td class="memTemplParams" colspan="2">template&lt;class GenericType &gt; </td></tr>
<tr class="memitem:ab4d6cd5651a735815e1af42ab3ea21a6"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; Type, Parameters...&gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#ab4d6cd5651a735815e1af42ab3ea21a6">operator&amp;=</a> (const GenericType &amp;rhs)</td></tr>
<tr class="memdesc:ab4d6cd5651a735815e1af42ab3ea21a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise AND assignment.  <a href="#ab4d6cd5651a735815e1af42ab3ea21a6"></a><br/></td></tr>
<tr class="separator:ab4d6cd5651a735815e1af42ab3ea21a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c8eb2274664155f9b714200544247b"><td class="memTemplParams" colspan="2">template&lt;class GenericType &gt; </td></tr>
<tr class="memitem:a19c8eb2274664155f9b714200544247b"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; Type, Parameters...&gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a19c8eb2274664155f9b714200544247b">operator|=</a> (const GenericType &amp;rhs)</td></tr>
<tr class="memdesc:a19c8eb2274664155f9b714200544247b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise OR assignment.  <a href="#a19c8eb2274664155f9b714200544247b"></a><br/></td></tr>
<tr class="separator:a19c8eb2274664155f9b714200544247b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a45a8f2b81d90168197a26dac6fb0f"><td class="memTemplParams" colspan="2">template&lt;class GenericType &gt; </td></tr>
<tr class="memitem:a38a45a8f2b81d90168197a26dac6fb0f"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; Type, Parameters...&gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a38a45a8f2b81d90168197a26dac6fb0f">operator^=</a> (const GenericType &amp;rhs)</td></tr>
<tr class="memdesc:a38a45a8f2b81d90168197a26dac6fb0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise XOR assignment.  <a href="#a38a45a8f2b81d90168197a26dac6fb0f"></a><br/></td></tr>
<tr class="separator:a38a45a8f2b81d90168197a26dac6fb0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22eee562fea2e47fceb1a28f045d684a"><td class="memTemplParams" colspan="2">template&lt;class GenericType &gt; </td></tr>
<tr class="memitem:a22eee562fea2e47fceb1a28f045d684a"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; Type, Parameters...&gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a22eee562fea2e47fceb1a28f045d684a">operator&lt;&lt;=</a> (const GenericType &amp;rhs)</td></tr>
<tr class="memdesc:a22eee562fea2e47fceb1a28f045d684a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise left shift assignment.  <a href="#a22eee562fea2e47fceb1a28f045d684a"></a><br/></td></tr>
<tr class="separator:a22eee562fea2e47fceb1a28f045d684a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af997b81383cd6fda10a5c816ab5fa066"><td class="memTemplParams" colspan="2">template&lt;class GenericType &gt; </td></tr>
<tr class="memitem:af997b81383cd6fda10a5c816ab5fa066"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; Type, Parameters...&gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#af997b81383cd6fda10a5c816ab5fa066">operator&gt;&gt;=</a> (const GenericType &amp;rhs)</td></tr>
<tr class="memdesc:af997b81383cd6fda10a5c816ab5fa066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise right shift assignment.  <a href="#af997b81383cd6fda10a5c816ab5fa066"></a><br/></td></tr>
<tr class="separator:af997b81383cd6fda10a5c816ab5fa066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Operators : main</div></td></tr>
<tr class="memitem:a567b025704b733cbd38dc5504102dfca"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , class  = typename std::enable_if&lt;std::is_convertible&lt;OtherType, Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a567b025704b733cbd38dc5504102dfca"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; typename <br class="typebreak"/>
std::common_type&lt; Type, <br class="typebreak"/>
OtherType &gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, <br class="typebreak"/>
Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a567b025704b733cbd38dc5504102dfca">operator+</a> (const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, OtherType, Parameters...&gt; &amp;rhs) const </td></tr>
<tr class="memdesc:a567b025704b733cbd38dc5504102dfca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition.  <a href="#a567b025704b733cbd38dc5504102dfca"></a><br/></td></tr>
<tr class="separator:a567b025704b733cbd38dc5504102dfca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9323dd009e06bac4ff6c426217a11443"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , class  = typename std::enable_if&lt;std::is_convertible&lt;OtherType, Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a9323dd009e06bac4ff6c426217a11443"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; typename <br class="typebreak"/>
std::common_type&lt; Type, <br class="typebreak"/>
OtherType &gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, <br class="typebreak"/>
Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a9323dd009e06bac4ff6c426217a11443">operator-</a> (const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, OtherType, Parameters...&gt; &amp;rhs) const </td></tr>
<tr class="memdesc:a9323dd009e06bac4ff6c426217a11443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substraction.  <a href="#a9323dd009e06bac4ff6c426217a11443"></a><br/></td></tr>
<tr class="separator:a9323dd009e06bac4ff6c426217a11443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915d0b7778501174f122a8497fb46387"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , class  = typename std::enable_if&lt;std::is_convertible&lt;OtherType, Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a915d0b7778501174f122a8497fb46387"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; typename <br class="typebreak"/>
std::common_type&lt; Type, <br class="typebreak"/>
OtherType &gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, <br class="typebreak"/>
Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a915d0b7778501174f122a8497fb46387">operator*</a> (const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, OtherType, Parameters...&gt; &amp;rhs) const </td></tr>
<tr class="memdesc:a915d0b7778501174f122a8497fb46387"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication.  <a href="#a915d0b7778501174f122a8497fb46387"></a><br/></td></tr>
<tr class="separator:a915d0b7778501174f122a8497fb46387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c01771117232fb2ba44a73682f7d2d"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , class  = typename std::enable_if&lt;std::is_convertible&lt;OtherType, Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a37c01771117232fb2ba44a73682f7d2d"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; typename <br class="typebreak"/>
std::common_type&lt; Type, <br class="typebreak"/>
OtherType &gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, <br class="typebreak"/>
Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a37c01771117232fb2ba44a73682f7d2d">operator/</a> (const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, OtherType, Parameters...&gt; &amp;rhs) const </td></tr>
<tr class="memdesc:a37c01771117232fb2ba44a73682f7d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division.  <a href="#a37c01771117232fb2ba44a73682f7d2d"></a><br/></td></tr>
<tr class="separator:a37c01771117232fb2ba44a73682f7d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2236077d26b29ce7b03a3990d4f16e"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , class  = typename std::enable_if&lt;std::is_convertible&lt;OtherType, Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:add2236077d26b29ce7b03a3990d4f16e"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; typename <br class="typebreak"/>
std::common_type&lt; Type, <br class="typebreak"/>
OtherType &gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, <br class="typebreak"/>
Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#add2236077d26b29ce7b03a3990d4f16e">operator%</a> (const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, OtherType, Parameters...&gt; &amp;rhs) const </td></tr>
<tr class="memdesc:add2236077d26b29ce7b03a3990d4f16e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modulo.  <a href="#add2236077d26b29ce7b03a3990d4f16e"></a><br/></td></tr>
<tr class="separator:add2236077d26b29ce7b03a3990d4f16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a87d64ccefc340329bbd5cc1ddb9717"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , class  = typename std::enable_if&lt;std::is_convertible&lt;OtherType, Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a8a87d64ccefc340329bbd5cc1ddb9717"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; typename <br class="typebreak"/>
std::common_type&lt; Type, <br class="typebreak"/>
OtherType &gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, <br class="typebreak"/>
Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a8a87d64ccefc340329bbd5cc1ddb9717">operator&amp;</a> (const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, OtherType, Parameters...&gt; &amp;rhs) const </td></tr>
<tr class="memdesc:a8a87d64ccefc340329bbd5cc1ddb9717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise AND.  <a href="#a8a87d64ccefc340329bbd5cc1ddb9717"></a><br/></td></tr>
<tr class="separator:a8a87d64ccefc340329bbd5cc1ddb9717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dfa7d06a43760b3550fa8e6319dee90"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , class  = typename std::enable_if&lt;std::is_convertible&lt;OtherType, Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a9dfa7d06a43760b3550fa8e6319dee90"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; typename <br class="typebreak"/>
std::common_type&lt; Type, <br class="typebreak"/>
OtherType &gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, <br class="typebreak"/>
Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a9dfa7d06a43760b3550fa8e6319dee90">operator|</a> (const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, OtherType, Parameters...&gt; &amp;rhs) const </td></tr>
<tr class="memdesc:a9dfa7d06a43760b3550fa8e6319dee90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise OR.  <a href="#a9dfa7d06a43760b3550fa8e6319dee90"></a><br/></td></tr>
<tr class="separator:a9dfa7d06a43760b3550fa8e6319dee90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0943fd4f6155fcd6410ffaddee1a30c3"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , class  = typename std::enable_if&lt;std::is_convertible&lt;OtherType, Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a0943fd4f6155fcd6410ffaddee1a30c3"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; typename <br class="typebreak"/>
std::common_type&lt; Type, <br class="typebreak"/>
OtherType &gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, <br class="typebreak"/>
Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a0943fd4f6155fcd6410ffaddee1a30c3">operator^</a> (const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, OtherType, Parameters...&gt; &amp;rhs) const </td></tr>
<tr class="memdesc:a0943fd4f6155fcd6410ffaddee1a30c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise XOR.  <a href="#a0943fd4f6155fcd6410ffaddee1a30c3"></a><br/></td></tr>
<tr class="separator:a0943fd4f6155fcd6410ffaddee1a30c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca67dc868dd70423e659b77209e07d9"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , class  = typename std::enable_if&lt;std::is_convertible&lt;OtherType, Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a1ca67dc868dd70423e659b77209e07d9"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; Type, Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a1ca67dc868dd70423e659b77209e07d9">operator&lt;&lt;</a> (const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, OtherType, Parameters...&gt; &amp;rhs) const </td></tr>
<tr class="memdesc:a1ca67dc868dd70423e659b77209e07d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise left shift.  <a href="#a1ca67dc868dd70423e659b77209e07d9"></a><br/></td></tr>
<tr class="separator:a1ca67dc868dd70423e659b77209e07d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6893af67ac504eeb471690a5114a1365"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , class  = typename std::enable_if&lt;std::is_convertible&lt;OtherType, Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a6893af67ac504eeb471690a5114a1365"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; Type, Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a6893af67ac504eeb471690a5114a1365">operator&gt;&gt;</a> (const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, OtherType, Parameters...&gt; &amp;rhs) const </td></tr>
<tr class="memdesc:a6893af67ac504eeb471690a5114a1365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise right shift.  <a href="#a6893af67ac504eeb471690a5114a1365"></a><br/></td></tr>
<tr class="separator:a6893af67ac504eeb471690a5114a1365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b7dd33a216a87e2d8cad3bd06aff45"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , class  = typename std::enable_if&lt;std::is_convertible&lt;OtherType, Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:aa0b7dd33a216a87e2d8cad3bd06aff45"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; bool, Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#aa0b7dd33a216a87e2d8cad3bd06aff45">operator&amp;&amp;</a> (const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, OtherType, Parameters...&gt; &amp;rhs) const </td></tr>
<tr class="memdesc:aa0b7dd33a216a87e2d8cad3bd06aff45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical AND.  <a href="#aa0b7dd33a216a87e2d8cad3bd06aff45"></a><br/></td></tr>
<tr class="separator:aa0b7dd33a216a87e2d8cad3bd06aff45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b7f2ba58c27a4562daa6243d50e67b"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , class  = typename std::enable_if&lt;std::is_convertible&lt;OtherType, Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a69b7f2ba58c27a4562daa6243d50e67b"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; bool, Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a69b7f2ba58c27a4562daa6243d50e67b">operator||</a> (const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, OtherType, Parameters...&gt; &amp;rhs) const </td></tr>
<tr class="memdesc:a69b7f2ba58c27a4562daa6243d50e67b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical OR.  <a href="#a69b7f2ba58c27a4562daa6243d50e67b"></a><br/></td></tr>
<tr class="separator:a69b7f2ba58c27a4562daa6243d50e67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bad4a3e6f2206c1fc71f3f3b26b841b"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , class  = typename std::enable_if&lt;std::is_convertible&lt;OtherType, Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a5bad4a3e6f2206c1fc71f3f3b26b841b"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; bool, Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a5bad4a3e6f2206c1fc71f3f3b26b841b">operator==</a> (const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, OtherType, Parameters...&gt; &amp;rhs) const </td></tr>
<tr class="memdesc:a5bad4a3e6f2206c1fc71f3f3b26b841b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equal to.  <a href="#a5bad4a3e6f2206c1fc71f3f3b26b841b"></a><br/></td></tr>
<tr class="separator:a5bad4a3e6f2206c1fc71f3f3b26b841b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92fdb0640566781b2be44d9e5a13a4f"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , class  = typename std::enable_if&lt;std::is_convertible&lt;OtherType, Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:af92fdb0640566781b2be44d9e5a13a4f"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; bool, Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#af92fdb0640566781b2be44d9e5a13a4f">operator!=</a> (const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, OtherType, Parameters...&gt; &amp;rhs) const </td></tr>
<tr class="memdesc:af92fdb0640566781b2be44d9e5a13a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not equal to.  <a href="#af92fdb0640566781b2be44d9e5a13a4f"></a><br/></td></tr>
<tr class="separator:af92fdb0640566781b2be44d9e5a13a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0b5791efa69c1397ef8af918148ad8"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , class  = typename std::enable_if&lt;std::is_convertible&lt;OtherType, Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a2c0b5791efa69c1397ef8af918148ad8"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; bool, Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a2c0b5791efa69c1397ef8af918148ad8">operator&gt;</a> (const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, OtherType, Parameters...&gt; &amp;rhs) const </td></tr>
<tr class="memdesc:a2c0b5791efa69c1397ef8af918148ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than.  <a href="#a2c0b5791efa69c1397ef8af918148ad8"></a><br/></td></tr>
<tr class="separator:a2c0b5791efa69c1397ef8af918148ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80928ac25f678a002f96c2770ae0459a"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , class  = typename std::enable_if&lt;std::is_convertible&lt;OtherType, Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a80928ac25f678a002f96c2770ae0459a"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; bool, Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a80928ac25f678a002f96c2770ae0459a">operator&lt;</a> (const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, OtherType, Parameters...&gt; &amp;rhs) const </td></tr>
<tr class="memdesc:a80928ac25f678a002f96c2770ae0459a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than.  <a href="#a80928ac25f678a002f96c2770ae0459a"></a><br/></td></tr>
<tr class="separator:a80928ac25f678a002f96c2770ae0459a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a192cbe3a1821bbff180dfe1422a0ecae"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , class  = typename std::enable_if&lt;std::is_convertible&lt;OtherType, Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a192cbe3a1821bbff180dfe1422a0ecae"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; bool, Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a192cbe3a1821bbff180dfe1422a0ecae">operator&gt;=</a> (const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, OtherType, Parameters...&gt; &amp;rhs) const </td></tr>
<tr class="memdesc:a192cbe3a1821bbff180dfe1422a0ecae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than or equal to.  <a href="#a192cbe3a1821bbff180dfe1422a0ecae"></a><br/></td></tr>
<tr class="separator:a192cbe3a1821bbff180dfe1422a0ecae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76839b1c705d389cfacfc9ae8d1b8887"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , class  = typename std::enable_if&lt;std::is_convertible&lt;OtherType, Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a76839b1c705d389cfacfc9ae8d1b8887"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; bool, Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a76839b1c705d389cfacfc9ae8d1b8887">operator&lt;=</a> (const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, OtherType, Parameters...&gt; &amp;rhs) const </td></tr>
<tr class="memdesc:a76839b1c705d389cfacfc9ae8d1b8887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than or equal to.  <a href="#a76839b1c705d389cfacfc9ae8d1b8887"></a><br/></td></tr>
<tr class="separator:a76839b1c705d389cfacfc9ae8d1b8887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Operators : with rhs value</div></td></tr>
<tr class="memitem:aae18798ce202c372877ffad6dd05a6ee"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, Type&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:aae18798ce202c372877ffad6dd05a6ee"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; typename <br class="typebreak"/>
std::common_type&lt; Type, <br class="typebreak"/>
OtherType &gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, <br class="typebreak"/>
Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#aae18798ce202c372877ffad6dd05a6ee">operator+</a> (const OtherType &amp;rhs) const </td></tr>
<tr class="memdesc:aae18798ce202c372877ffad6dd05a6ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition with rhs value.  <a href="#aae18798ce202c372877ffad6dd05a6ee"></a><br/></td></tr>
<tr class="separator:aae18798ce202c372877ffad6dd05a6ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a294a71924f6f57b8e03edcbfb12c0c54"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, Type&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:a294a71924f6f57b8e03edcbfb12c0c54"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; typename <br class="typebreak"/>
std::common_type&lt; Type, <br class="typebreak"/>
OtherType &gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, <br class="typebreak"/>
Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a294a71924f6f57b8e03edcbfb12c0c54">operator-</a> (const OtherType &amp;rhs) const </td></tr>
<tr class="memdesc:a294a71924f6f57b8e03edcbfb12c0c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substraction with rhs value.  <a href="#a294a71924f6f57b8e03edcbfb12c0c54"></a><br/></td></tr>
<tr class="separator:a294a71924f6f57b8e03edcbfb12c0c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d4e3fb0273c6453f4c77654ed39bee"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, Type&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:ab2d4e3fb0273c6453f4c77654ed39bee"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; typename <br class="typebreak"/>
std::common_type&lt; Type, <br class="typebreak"/>
OtherType &gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, <br class="typebreak"/>
Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#ab2d4e3fb0273c6453f4c77654ed39bee">operator*</a> (const OtherType &amp;rhs) const </td></tr>
<tr class="memdesc:ab2d4e3fb0273c6453f4c77654ed39bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication with rhs value.  <a href="#ab2d4e3fb0273c6453f4c77654ed39bee"></a><br/></td></tr>
<tr class="separator:ab2d4e3fb0273c6453f4c77654ed39bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb4d2416e7104066405671d4d6d62337"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, Type&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:abb4d2416e7104066405671d4d6d62337"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; typename <br class="typebreak"/>
std::common_type&lt; Type, <br class="typebreak"/>
OtherType &gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, <br class="typebreak"/>
Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#abb4d2416e7104066405671d4d6d62337">operator/</a> (const OtherType &amp;rhs) const </td></tr>
<tr class="memdesc:abb4d2416e7104066405671d4d6d62337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division with rhs value.  <a href="#abb4d2416e7104066405671d4d6d62337"></a><br/></td></tr>
<tr class="separator:abb4d2416e7104066405671d4d6d62337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed2e71709a1266c0aa35ace9e60db9c"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, Type&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:abed2e71709a1266c0aa35ace9e60db9c"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; typename <br class="typebreak"/>
std::common_type&lt; Type, <br class="typebreak"/>
OtherType &gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, <br class="typebreak"/>
Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#abed2e71709a1266c0aa35ace9e60db9c">operator%</a> (const OtherType &amp;rhs) const </td></tr>
<tr class="memdesc:abed2e71709a1266c0aa35ace9e60db9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modulo with rhs value.  <a href="#abed2e71709a1266c0aa35ace9e60db9c"></a><br/></td></tr>
<tr class="separator:abed2e71709a1266c0aa35ace9e60db9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add90cf869ac9dd08b986be67cfee5221"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, Type&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:add90cf869ac9dd08b986be67cfee5221"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; typename <br class="typebreak"/>
std::common_type&lt; Type, <br class="typebreak"/>
OtherType &gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, <br class="typebreak"/>
Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#add90cf869ac9dd08b986be67cfee5221">operator&amp;</a> (const OtherType &amp;rhs) const </td></tr>
<tr class="memdesc:add90cf869ac9dd08b986be67cfee5221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise AND with rhs value.  <a href="#add90cf869ac9dd08b986be67cfee5221"></a><br/></td></tr>
<tr class="separator:add90cf869ac9dd08b986be67cfee5221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224cb7cb9b2cb80a7719cdee76349204"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, Type&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:a224cb7cb9b2cb80a7719cdee76349204"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; typename <br class="typebreak"/>
std::common_type&lt; Type, <br class="typebreak"/>
OtherType &gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, <br class="typebreak"/>
Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a224cb7cb9b2cb80a7719cdee76349204">operator|</a> (const OtherType &amp;rhs) const </td></tr>
<tr class="memdesc:a224cb7cb9b2cb80a7719cdee76349204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise OR with rhs value.  <a href="#a224cb7cb9b2cb80a7719cdee76349204"></a><br/></td></tr>
<tr class="separator:a224cb7cb9b2cb80a7719cdee76349204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39f76f560714379beb563a6406713ae"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, Type&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:ab39f76f560714379beb563a6406713ae"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; typename <br class="typebreak"/>
std::common_type&lt; Type, <br class="typebreak"/>
OtherType &gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, <br class="typebreak"/>
Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#ab39f76f560714379beb563a6406713ae">operator^</a> (const OtherType &amp;rhs) const </td></tr>
<tr class="memdesc:ab39f76f560714379beb563a6406713ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise XOR with rhs value.  <a href="#ab39f76f560714379beb563a6406713ae"></a><br/></td></tr>
<tr class="separator:ab39f76f560714379beb563a6406713ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5629b7a221887ce68ed18b1da00ad5d6"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, Type&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:a5629b7a221887ce68ed18b1da00ad5d6"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; Type, Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a5629b7a221887ce68ed18b1da00ad5d6">operator&lt;&lt;</a> (const OtherType &amp;rhs) const </td></tr>
<tr class="memdesc:a5629b7a221887ce68ed18b1da00ad5d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise left shift with rhs value.  <a href="#a5629b7a221887ce68ed18b1da00ad5d6"></a><br/></td></tr>
<tr class="separator:a5629b7a221887ce68ed18b1da00ad5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3738d5814db16597b32bdf601685c832"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, Type&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:a3738d5814db16597b32bdf601685c832"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; Type, Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a3738d5814db16597b32bdf601685c832">operator&gt;&gt;</a> (const OtherType &amp;rhs) const </td></tr>
<tr class="memdesc:a3738d5814db16597b32bdf601685c832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise right shift with rhs value.  <a href="#a3738d5814db16597b32bdf601685c832"></a><br/></td></tr>
<tr class="separator:a3738d5814db16597b32bdf601685c832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96cdf853407901fedc50265a84fa5991"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, Type&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:a96cdf853407901fedc50265a84fa5991"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; bool, Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a96cdf853407901fedc50265a84fa5991">operator&amp;&amp;</a> (const OtherType &amp;rhs) const </td></tr>
<tr class="memdesc:a96cdf853407901fedc50265a84fa5991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical AND with rhs value.  <a href="#a96cdf853407901fedc50265a84fa5991"></a><br/></td></tr>
<tr class="separator:a96cdf853407901fedc50265a84fa5991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed99ecd4a86f62923433c8f27a05d3f"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, Type&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:afed99ecd4a86f62923433c8f27a05d3f"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; bool, Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#afed99ecd4a86f62923433c8f27a05d3f">operator||</a> (const OtherType &amp;rhs) const </td></tr>
<tr class="memdesc:afed99ecd4a86f62923433c8f27a05d3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical OR with rhs value.  <a href="#afed99ecd4a86f62923433c8f27a05d3f"></a><br/></td></tr>
<tr class="separator:afed99ecd4a86f62923433c8f27a05d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a3d25716fb6f3056a194db4611398b"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, Type&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:ae8a3d25716fb6f3056a194db4611398b"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; bool, Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#ae8a3d25716fb6f3056a194db4611398b">operator==</a> (const OtherType &amp;rhs) const </td></tr>
<tr class="memdesc:ae8a3d25716fb6f3056a194db4611398b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equal to with rhs value.  <a href="#ae8a3d25716fb6f3056a194db4611398b"></a><br/></td></tr>
<tr class="separator:ae8a3d25716fb6f3056a194db4611398b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745d2383572c87adb83d08e23692aa81"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, Type&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:a745d2383572c87adb83d08e23692aa81"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; bool, Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a745d2383572c87adb83d08e23692aa81">operator!=</a> (const OtherType &amp;rhs) const </td></tr>
<tr class="memdesc:a745d2383572c87adb83d08e23692aa81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not equal to with rhs value.  <a href="#a745d2383572c87adb83d08e23692aa81"></a><br/></td></tr>
<tr class="separator:a745d2383572c87adb83d08e23692aa81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45845efb29eba8ac0742080cb0ca161e"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, Type&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:a45845efb29eba8ac0742080cb0ca161e"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; bool, Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a45845efb29eba8ac0742080cb0ca161e">operator&gt;</a> (const OtherType &amp;rhs) const </td></tr>
<tr class="memdesc:a45845efb29eba8ac0742080cb0ca161e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than with rhs value.  <a href="#a45845efb29eba8ac0742080cb0ca161e"></a><br/></td></tr>
<tr class="separator:a45845efb29eba8ac0742080cb0ca161e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8fc4ac75f3f4c8c9de4083cd07cacb0"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, Type&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:ae8fc4ac75f3f4c8c9de4083cd07cacb0"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; bool, Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#ae8fc4ac75f3f4c8c9de4083cd07cacb0">operator&lt;</a> (const OtherType &amp;rhs) const </td></tr>
<tr class="memdesc:ae8fc4ac75f3f4c8c9de4083cd07cacb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than with rhs value.  <a href="#ae8fc4ac75f3f4c8c9de4083cd07cacb0"></a><br/></td></tr>
<tr class="separator:ae8fc4ac75f3f4c8c9de4083cd07cacb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e18e9b3d7412d5d824eb7c03e01ab62"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, Type&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:a8e18e9b3d7412d5d824eb7c03e01ab62"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; bool, Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a8e18e9b3d7412d5d824eb7c03e01ab62">operator&gt;=</a> (const OtherType &amp;rhs) const </td></tr>
<tr class="memdesc:a8e18e9b3d7412d5d824eb7c03e01ab62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than or equal to with rhs value.  <a href="#a8e18e9b3d7412d5d824eb7c03e01ab62"></a><br/></td></tr>
<tr class="separator:a8e18e9b3d7412d5d824eb7c03e01ab62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c967db7cc9d968dfc7eeb8fc4570f59"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, Type&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:a4c967db7cc9d968dfc7eeb8fc4570f59"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; bool, Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a4c967db7cc9d968dfc7eeb8fc4570f59">operator&lt;=</a> (const OtherType &amp;rhs) const </td></tr>
<tr class="memdesc:a4c967db7cc9d968dfc7eeb8fc4570f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than or equal to with rhs value.  <a href="#a4c967db7cc9d968dfc7eeb8fc4570f59"></a><br/></td></tr>
<tr class="separator:a4c967db7cc9d968dfc7eeb8fc4570f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Operators : unary</div></td></tr>
<tr class="memitem:a47cd06bd12e9a75244bb47949d2ac179"><td class="memItemLeft" align="right" valign="top">Crtp&lt; bool, Parameters...&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a47cd06bd12e9a75244bb47949d2ac179">operator!</a> () const </td></tr>
<tr class="memdesc:a47cd06bd12e9a75244bb47949d2ac179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical NOT.  <a href="#a47cd06bd12e9a75244bb47949d2ac179"></a><br/></td></tr>
<tr class="separator:a47cd06bd12e9a75244bb47949d2ac179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aefc18480c79c379de8ddd9ebd0ac13"><td class="memItemLeft" align="right" valign="top">Crtp&lt; Type, Parameters...&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a6aefc18480c79c379de8ddd9ebd0ac13">operator~</a> () const </td></tr>
<tr class="memdesc:a6aefc18480c79c379de8ddd9ebd0ac13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise NOT.  <a href="#a6aefc18480c79c379de8ddd9ebd0ac13"></a><br/></td></tr>
<tr class="separator:a6aefc18480c79c379de8ddd9ebd0ac13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d653a93df0b5f7f112651044604109"><td class="memItemLeft" align="right" valign="top">Crtp&lt; Type, Parameters...&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a77d653a93df0b5f7f112651044604109">operator+</a> () const </td></tr>
<tr class="memdesc:a77d653a93df0b5f7f112651044604109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer promotion.  <a href="#a77d653a93df0b5f7f112651044604109"></a><br/></td></tr>
<tr class="separator:a77d653a93df0b5f7f112651044604109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a112a6fff4321f8e4ebe7184d4215e17a"><td class="memItemLeft" align="right" valign="top">Crtp&lt; Type, Parameters...&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a112a6fff4321f8e4ebe7184d4215e17a">operator-</a> () const </td></tr>
<tr class="memdesc:a112a6fff4321f8e4ebe7184d4215e17a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additive inverse.  <a href="#a112a6fff4321f8e4ebe7184d4215e17a"></a><br/></td></tr>
<tr class="separator:a112a6fff4321f8e4ebe7184d4215e17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5094efe1b21c12c05543b2ee05f9ae"><td class="memItemLeft" align="right" valign="top">Crtp&lt; Type, Parameters...&gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#acc5094efe1b21c12c05543b2ee05f9ae">operator++</a> ()</td></tr>
<tr class="memdesc:acc5094efe1b21c12c05543b2ee05f9ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment prefix.  <a href="#acc5094efe1b21c12c05543b2ee05f9ae"></a><br/></td></tr>
<tr class="separator:acc5094efe1b21c12c05543b2ee05f9ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3430773a46c0300aaadb38b2ce8e26af"><td class="memItemLeft" align="right" valign="top">Crtp&lt; Type, Parameters...&gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a3430773a46c0300aaadb38b2ce8e26af">operator--</a> ()</td></tr>
<tr class="memdesc:a3430773a46c0300aaadb38b2ce8e26af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement prefix.  <a href="#a3430773a46c0300aaadb38b2ce8e26af"></a><br/></td></tr>
<tr class="separator:a3430773a46c0300aaadb38b2ce8e26af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db772662fda98f47909ed9c5ae6f61e"><td class="memItemLeft" align="right" valign="top">Crtp&lt; Type, Parameters...&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a0db772662fda98f47909ed9c5ae6f61e">operator++</a> (int)</td></tr>
<tr class="memdesc:a0db772662fda98f47909ed9c5ae6f61e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment suffix.  <a href="#a0db772662fda98f47909ed9c5ae6f61e"></a><br/></td></tr>
<tr class="separator:a0db772662fda98f47909ed9c5ae6f61e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb5f5aec44c70c502f6f95c9ef2ac8ff"><td class="memItemLeft" align="right" valign="top">Crtp&lt; Type, Parameters...&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#acb5f5aec44c70c502f6f95c9ef2ac8ff">operator--</a> (int)</td></tr>
<tr class="memdesc:acb5f5aec44c70c502f6f95c9ef2ac8ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement suffix.  <a href="#acb5f5aec44c70c502f6f95c9ef2ac8ff"></a><br/></td></tr>
<tr class="separator:acb5f5aec44c70c502f6f95c9ef2ac8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Access</div></td></tr>
<tr class="memitem:a59fb69180969b012a7ba11981fb9aaf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, <br class="typebreak"/>
Crtp, Type, Parameters...&gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a59fb69180969b012a7ba11981fb9aaf5">operator()</a> ()</td></tr>
<tr class="memdesc:a59fb69180969b012a7ba11981fb9aaf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class access.  <a href="#a59fb69180969b012a7ba11981fb9aaf5"></a><br/></td></tr>
<tr class="separator:a59fb69180969b012a7ba11981fb9aaf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f4f22f100057ebca8f881a6cea2fe0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, <br class="typebreak"/>
Size, Crtp, Type, <br class="typebreak"/>
Parameters...&gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a21f4f22f100057ebca8f881a6cea2fe0">operator()</a> () const </td></tr>
<tr class="memdesc:a21f4f22f100057ebca8f881a6cea2fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Immutable abstract class access.  <a href="#a21f4f22f100057ebca8f881a6cea2fe0"></a><br/></td></tr>
<tr class="separator:a21f4f22f100057ebca8f881a6cea2fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791203245d6c45ee22165b4a0bc11647"><td class="memItemLeft" align="right" valign="top">Type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a791203245d6c45ee22165b4a0bc11647">operator()</a> (const unsigned int i)</td></tr>
<tr class="memdesc:a791203245d6c45ee22165b4a0bc11647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Monodimensional access operator.  <a href="#a791203245d6c45ee22165b4a0bc11647"></a><br/></td></tr>
<tr class="separator:a791203245d6c45ee22165b4a0bc11647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb3ee03be09afd4621c18d49918c8d0e"><td class="memItemLeft" align="right" valign="top">const Type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#aeb3ee03be09afd4621c18d49918c8d0e">operator()</a> (const unsigned int i) const </td></tr>
<tr class="memdesc:aeb3ee03be09afd4621c18d49918c8d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Immutable monodimensional access operator.  <a href="#aeb3ee03be09afd4621c18d49918c8d0e"></a><br/></td></tr>
<tr class="separator:aeb3ee03be09afd4621c18d49918c8d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842eaff610697adbed8b6bb4e403a39f"><td class="memItemLeft" align="right" valign="top">Type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a842eaff610697adbed8b6bb4e403a39f">at</a> (const unsigned int i)</td></tr>
<tr class="memdesc:a842eaff610697adbed8b6bb4e403a39f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Monodimensional access with range-check.  <a href="#a842eaff610697adbed8b6bb4e403a39f"></a><br/></td></tr>
<tr class="separator:a842eaff610697adbed8b6bb4e403a39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293da0f31f6a8db5efb9c9ebb7ff3a81"><td class="memItemLeft" align="right" valign="top">const Type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a293da0f31f6a8db5efb9c9ebb7ff3a81">at</a> (const unsigned int i) const </td></tr>
<tr class="memdesc:a293da0f31f6a8db5efb9c9ebb7ff3a81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Immutable monodimensional access with range-check.  <a href="#a293da0f31f6a8db5efb9c9ebb7ff3a81"></a><br/></td></tr>
<tr class="separator:a293da0f31f6a8db5efb9c9ebb7ff3a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860d99a0104280c072d7b7dbf8d87c27"><td class="memItemLeft" align="right" valign="top">Type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a860d99a0104280c072d7b7dbf8d87c27">front</a> (const unsigned int i=0)</td></tr>
<tr class="memdesc:a860d99a0104280c072d7b7dbf8d87c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Monodimensional access to the i-th element from the beginning.  <a href="#a860d99a0104280c072d7b7dbf8d87c27"></a><br/></td></tr>
<tr class="separator:a860d99a0104280c072d7b7dbf8d87c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afedeae49461374b9a8cd0fe6615b75bf"><td class="memItemLeft" align="right" valign="top">const Type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#afedeae49461374b9a8cd0fe6615b75bf">front</a> (const unsigned int i=0) const </td></tr>
<tr class="memdesc:afedeae49461374b9a8cd0fe6615b75bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Immutable monodimensional access to the i-th element from the beginning.  <a href="#afedeae49461374b9a8cd0fe6615b75bf"></a><br/></td></tr>
<tr class="separator:afedeae49461374b9a8cd0fe6615b75bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d5d72bbbf0c8b41de7ff463eb72606"><td class="memItemLeft" align="right" valign="top">Type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#ae1d5d72bbbf0c8b41de7ff463eb72606">back</a> (const unsigned int i=0)</td></tr>
<tr class="memdesc:ae1d5d72bbbf0c8b41de7ff463eb72606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Monodimensional access to the i-th element from the end.  <a href="#ae1d5d72bbbf0c8b41de7ff463eb72606"></a><br/></td></tr>
<tr class="separator:ae1d5d72bbbf0c8b41de7ff463eb72606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3efc84b306bb29fdcc1c13b0bb46e603"><td class="memItemLeft" align="right" valign="top">const Type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a3efc84b306bb29fdcc1c13b0bb46e603">back</a> (const unsigned int i=0) const </td></tr>
<tr class="memdesc:a3efc84b306bb29fdcc1c13b0bb46e603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Immutable monodimensional access to the i-th element from the end.  <a href="#a3efc84b306bb29fdcc1c13b0bb46e603"></a><br/></td></tr>
<tr class="separator:a3efc84b306bb29fdcc1c13b0bb46e603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc47c0b28180723f001d6c2dce89a78"><td class="memItemLeft" align="right" valign="top">Type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a3cc47c0b28180723f001d6c2dce89a78">cycle</a> (const int i)</td></tr>
<tr class="memdesc:a3cc47c0b28180723f001d6c2dce89a78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cyclic monodimensional access to the contents.  <a href="#a3cc47c0b28180723f001d6c2dce89a78"></a><br/></td></tr>
<tr class="separator:a3cc47c0b28180723f001d6c2dce89a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42143d4ae441b0a39d6632a40c34dcbc"><td class="memItemLeft" align="right" valign="top">const Type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a42143d4ae441b0a39d6632a40c34dcbc">cycle</a> (const int i) const </td></tr>
<tr class="memdesc:a42143d4ae441b0a39d6632a40c34dcbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Immutable cyclic monodimensional access to the contents.  <a href="#a42143d4ae441b0a39d6632a40c34dcbc"></a><br/></td></tr>
<tr class="separator:a42143d4ae441b0a39d6632a40c34dcbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Assignment</div></td></tr>
<tr class="memitem:aa026b0cb951858dfbebaf4df9d02dd28"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , class... Misc, class  = typename std::enable_if&lt;std::is_convertible&lt;OtherType, Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:aa026b0cb951858dfbebaf4df9d02dd28"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; Type, Parameters...&gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#aa026b0cb951858dfbebaf4df9d02dd28">assign</a> (const std::initializer_list&lt; OtherType &gt; &amp;source, const Misc &amp;...misc)</td></tr>
<tr class="memdesc:aa026b0cb951858dfbebaf4df9d02dd28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer list assignment.  <a href="#aa026b0cb951858dfbebaf4df9d02dd28"></a><br/></td></tr>
<tr class="separator:aa026b0cb951858dfbebaf4df9d02dd28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeecd6ce10ed87346885bf4c7aeef7ae6"><td class="memTemplParams" colspan="2">template&lt;class... Misc&gt; </td></tr>
<tr class="memitem:aeecd6ce10ed87346885bf4c7aeef7ae6"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; Type, Parameters...&gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#aeecd6ce10ed87346885bf4c7aeef7ae6">assign</a> (const Misc &amp;...misc)</td></tr>
<tr class="memdesc:aeecd6ce10ed87346885bf4c7aeef7ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic assignment.  <a href="#aeecd6ce10ed87346885bf4c7aeef7ae6"></a><br/></td></tr>
<tr class="separator:aeecd6ce10ed87346885bf4c7aeef7ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff1b6067431758a205c3cb71c38f6011"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , class... Misc, class  = typename std::enable_if&lt;std::is_convertible&lt;OtherType, Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:aff1b6067431758a205c3cb71c38f6011"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; Type, Parameters...&gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#aff1b6067431758a205c3cb71c38f6011">fill</a> (const std::initializer_list&lt; OtherType &gt; &amp;source, const Misc &amp;...misc)</td></tr>
<tr class="memdesc:aff1b6067431758a205c3cb71c38f6011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer list fill.  <a href="#aff1b6067431758a205c3cb71c38f6011"></a><br/></td></tr>
<tr class="separator:aff1b6067431758a205c3cb71c38f6011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc085a9ed9cf363095eb42adf323b533"><td class="memTemplParams" colspan="2">template&lt;class... Misc&gt; </td></tr>
<tr class="memitem:abc085a9ed9cf363095eb42adf323b533"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; Type, Parameters...&gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#abc085a9ed9cf363095eb42adf323b533">fill</a> (const Misc &amp;...misc)</td></tr>
<tr class="memdesc:abc085a9ed9cf363095eb42adf323b533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic fill.  <a href="#abc085a9ed9cf363095eb42adf323b533"></a><br/></td></tr>
<tr class="separator:abc085a9ed9cf363095eb42adf323b533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae322d5931112d91c3f24529e6c1e1559"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , class... Misc, class  = typename std::enable_if&lt;std::is_convertible&lt;OtherType, Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ae322d5931112d91c3f24529e6c1e1559"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; Type, Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#ae322d5931112d91c3f24529e6c1e1559">replace</a> (const std::initializer_list&lt; OtherType &gt; &amp;source, const Misc &amp;...misc)</td></tr>
<tr class="memdesc:ae322d5931112d91c3f24529e6c1e1559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer list replace.  <a href="#ae322d5931112d91c3f24529e6c1e1559"></a><br/></td></tr>
<tr class="separator:ae322d5931112d91c3f24529e6c1e1559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81bc8121599b9da4425a5d73eb65dec4"><td class="memTemplParams" colspan="2">template&lt;class... Misc&gt; </td></tr>
<tr class="memitem:a81bc8121599b9da4425a5d73eb65dec4"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; Type, Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a81bc8121599b9da4425a5d73eb65dec4">replace</a> (const Misc &amp;...misc)</td></tr>
<tr class="memdesc:a81bc8121599b9da4425a5d73eb65dec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic replace.  <a href="#a81bc8121599b9da4425a5d73eb65dec4"></a><br/></td></tr>
<tr class="separator:a81bc8121599b9da4425a5d73eb65dec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68070ddd4235454ca5fae28888353a87"><td class="memTemplParams" colspan="2">template&lt;class GenericType &gt; </td></tr>
<tr class="memitem:a68070ddd4235454ca5fae28888353a87"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; Type, Parameters...&gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a68070ddd4235454ca5fae28888353a87">put</a> (const GenericType &amp;source, const unsigned int pos, const unsigned int num=1)</td></tr>
<tr class="memdesc:a68070ddd4235454ca5fae28888353a87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put an element in the container.  <a href="#a68070ddd4235454ca5fae28888353a87"></a><br/></td></tr>
<tr class="separator:a68070ddd4235454ca5fae28888353a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb350662a8c17a5476b331d23917b084"><td class="memTemplParams" colspan="2">template&lt;class GenericType &gt; </td></tr>
<tr class="memitem:acb350662a8c17a5476b331d23917b084"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; Type, Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#acb350662a8c17a5476b331d23917b084">change</a> (const GenericType &amp;source, const unsigned int pos, const unsigned int num=1)</td></tr>
<tr class="memdesc:acb350662a8c17a5476b331d23917b084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change an element of the container.  <a href="#acb350662a8c17a5476b331d23917b084"></a><br/></td></tr>
<tr class="separator:acb350662a8c17a5476b331d23917b084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Management</div></td></tr>
<tr class="memitem:ae15629a58700e638e2a4546742cf09f6"><td class="memItemLeft" align="right" valign="top">Crtp&lt; Type, Parameters...&gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#ae15629a58700e638e2a4546742cf09f6">reserve</a> (const unsigned int n)</td></tr>
<tr class="memdesc:ae15629a58700e638e2a4546742cf09f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve new space for the container.  <a href="#ae15629a58700e638e2a4546742cf09f6"></a><br/></td></tr>
<tr class="separator:ae15629a58700e638e2a4546742cf09f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4fdc2ce798bc99edc1a874a90bbfe5"><td class="memItemLeft" align="right" valign="top">Crtp&lt; Type, Parameters...&gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#abc4fdc2ce798bc99edc1a874a90bbfe5">clear</a> ()</td></tr>
<tr class="memdesc:abc4fdc2ce798bc99edc1a874a90bbfe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear contents.  <a href="#abc4fdc2ce798bc99edc1a874a90bbfe5"></a><br/></td></tr>
<tr class="separator:abc4fdc2ce798bc99edc1a874a90bbfe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d036d08b09e0f8ec903c7c6442db2b"><td class="memTemplParams" colspan="2">template&lt;class... Location&gt; </td></tr>
<tr class="memitem:aa2d036d08b09e0f8ec903c7c6442db2b"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; Type, Parameters...&gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#aa2d036d08b09e0f8ec903c7c6442db2b">nullify</a> (const Location &amp;...location)</td></tr>
<tr class="memdesc:aa2d036d08b09e0f8ec903c7c6442db2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set elements to their default values.  <a href="#aa2d036d08b09e0f8ec903c7c6442db2b"></a><br/></td></tr>
<tr class="separator:aa2d036d08b09e0f8ec903c7c6442db2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf8d5dc7fd3290eff136f1262342e8b"><td class="memTemplParams" colspan="2">template&lt;class... Location&gt; </td></tr>
<tr class="memitem:a8bf8d5dc7fd3290eff136f1262342e8b"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; Type, Parameters...&gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a8bf8d5dc7fd3290eff136f1262342e8b">swap</a> (<a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters...&gt; &amp;rhs, const Location &amp;...location)</td></tr>
<tr class="memdesc:a8bf8d5dc7fd3290eff136f1262342e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap elements by copy.  <a href="#a8bf8d5dc7fd3290eff136f1262342e8b"></a><br/></td></tr>
<tr class="separator:a8bf8d5dc7fd3290eff136f1262342e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c61ea6878c48725951cce33147cd22"><td class="memItemLeft" align="right" valign="top">Crtp&lt; Type, Parameters...&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a15c61ea6878c48725951cce33147cd22">copy</a> () const </td></tr>
<tr class="memdesc:a15c61ea6878c48725951cce33147cd22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy.  <a href="#a15c61ea6878c48725951cce33147cd22"></a><br/></td></tr>
<tr class="separator:a15c61ea6878c48725951cce33147cd22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d731d6d65b0c6779f8bfa098743817"><td class="memTemplParams" colspan="2">template&lt;typename OtherType  = Type, class  = typename std::enable_if&lt;std::is_convertible&lt;OtherType, Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ad3d731d6d65b0c6779f8bfa098743817"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; OtherType, Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#ad3d731d6d65b0c6779f8bfa098743817">cast</a> () const </td></tr>
<tr class="memdesc:ad3d731d6d65b0c6779f8bfa098743817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast to a different data type.  <a href="#ad3d731d6d65b0c6779f8bfa098743817"></a><br/></td></tr>
<tr class="separator:ad3d731d6d65b0c6779f8bfa098743817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Comparison</div></td></tr>
<tr class="memitem:a584d26a12db2398aeb579281f0891397"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a584d26a12db2398aeb579281f0891397">null</a> () const </td></tr>
<tr class="memdesc:a584d26a12db2398aeb579281f0891397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether all elements are null.  <a href="#a584d26a12db2398aeb579281f0891397"></a><br/></td></tr>
<tr class="separator:a584d26a12db2398aeb579281f0891397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17daca1d726cd6249fcf435c8f36fe6b"><td class="memTemplParams" colspan="2">template&lt;class GenericType &gt; </td></tr>
<tr class="memitem:a17daca1d726cd6249fcf435c8f36fe6b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a17daca1d726cd6249fcf435c8f36fe6b">eq</a> (const GenericType &amp;rhs) const </td></tr>
<tr class="memdesc:a17daca1d726cd6249fcf435c8f36fe6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare for equality.  <a href="#a17daca1d726cd6249fcf435c8f36fe6b"></a><br/></td></tr>
<tr class="separator:a17daca1d726cd6249fcf435c8f36fe6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88432eac2ca07cc75a2c3dd3c068ac0c"><td class="memTemplParams" colspan="2">template&lt;class GenericType &gt; </td></tr>
<tr class="memitem:a88432eac2ca07cc75a2c3dd3c068ac0c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a88432eac2ca07cc75a2c3dd3c068ac0c">ne</a> (const GenericType &amp;rhs) const </td></tr>
<tr class="memdesc:a88432eac2ca07cc75a2c3dd3c068ac0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare for difference.  <a href="#a88432eac2ca07cc75a2c3dd3c068ac0c"></a><br/></td></tr>
<tr class="separator:a88432eac2ca07cc75a2c3dd3c068ac0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Statistics</div></td></tr>
<tr class="memitem:a4a0074acfae82d0eec6843eacae83f9b"><td class="memTemplParams" colspan="2">template&lt;class Mask  = std::true_type, class  = typename std::enable_if&lt;(std::is_base_of&lt;Vectorizer, Mask&gt;::value) || (std::is_same&lt;std::true_type, Mask&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:a4a0074acfae82d0eec6843eacae83f9b"><td class="memTemplItemLeft" align="right" valign="top">const Type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a4a0074acfae82d0eec6843eacae83f9b">min</a> (const Mask &amp;bitmask=Mask()) const </td></tr>
<tr class="memdesc:a4a0074acfae82d0eec6843eacae83f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum element.  <a href="#a4a0074acfae82d0eec6843eacae83f9b"></a><br/></td></tr>
<tr class="separator:a4a0074acfae82d0eec6843eacae83f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d815869f22555a895bfb1cb50bfe6da"><td class="memTemplParams" colspan="2">template&lt;class Mask  = std::true_type, class  = typename std::enable_if&lt;(std::is_base_of&lt;Vectorizer, Mask&gt;::value) || (std::is_same&lt;std::true_type, Mask&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:a9d815869f22555a895bfb1cb50bfe6da"><td class="memTemplItemLeft" align="right" valign="top">const Type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a9d815869f22555a895bfb1cb50bfe6da">max</a> (const Mask &amp;bitmask=Mask()) const </td></tr>
<tr class="memdesc:a9d815869f22555a895bfb1cb50bfe6da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum element.  <a href="#a9d815869f22555a895bfb1cb50bfe6da"></a><br/></td></tr>
<tr class="separator:a9d815869f22555a895bfb1cb50bfe6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Application</div></td></tr>
<tr class="memitem:a3561a958f2f2e9335a75183752b06513"><td class="memTemplParams" colspan="2">template&lt;typename Return  = Type, class Function , class... Args, class  = typename std::enable_if&lt;!std::is_base_of&lt;Vectorizer, typename std::decay&lt;Function&gt;::type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a3561a958f2f2e9335a75183752b06513"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; Type, Parameters...&gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a3561a958f2f2e9335a75183752b06513">modify</a> (Function &amp;&amp;f, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a3561a958f2f2e9335a75183752b06513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modification by a function object.  <a href="#a3561a958f2f2e9335a75183752b06513"></a><br/></td></tr>
<tr class="separator:a3561a958f2f2e9335a75183752b06513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab491736cf47709fa98a58a2232662204"><td class="memTemplParams" colspan="2">template&lt;typename Return  = Type, class Mask , class Function , class... Args, class  = typename std::enable_if&lt;(std::is_base_of&lt;Vectorizer, Mask&gt;::value) &amp;&amp; (!std::is_base_of&lt;Vectorizer, typename std::decay&lt;Function&gt;::type&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:ab491736cf47709fa98a58a2232662204"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; Type, Parameters...&gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#ab491736cf47709fa98a58a2232662204">modify</a> (const Mask &amp;bitmask, Function &amp;&amp;f, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:ab491736cf47709fa98a58a2232662204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Masked modification by a function object.  <a href="#ab491736cf47709fa98a58a2232662204"></a><br/></td></tr>
<tr class="separator:ab491736cf47709fa98a58a2232662204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba0cf8fddea6caac41800e7fc43889f"><td class="memTemplParams" colspan="2">template&lt;typename Return  = Type, class Function , class... Args, class  = typename std::enable_if&lt;!std::is_base_of&lt;Vectorizer, typename std::decay&lt;Function&gt;::type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a9ba0cf8fddea6caac41800e7fc43889f"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; Return, Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a9ba0cf8fddea6caac41800e7fc43889f">apply</a> (Function &amp;&amp;f, Args &amp;&amp;...args) const </td></tr>
<tr class="memdesc:a9ba0cf8fddea6caac41800e7fc43889f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Application of a function object.  <a href="#a9ba0cf8fddea6caac41800e7fc43889f"></a><br/></td></tr>
<tr class="separator:a9ba0cf8fddea6caac41800e7fc43889f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68064fa87e05d4bb75e776c85afea35d"><td class="memTemplParams" colspan="2">template&lt;typename Return  = Type, class Mask , class Function , class... Args, class  = typename std::enable_if&lt;(std::is_base_of&lt;Vectorizer, Mask&gt;::value) &amp;&amp; (!std::is_base_of&lt;Vectorizer, typename std::decay&lt;Function&gt;::type&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:a68064fa87e05d4bb75e776c85afea35d"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; Return, Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a68064fa87e05d4bb75e776c85afea35d">apply</a> (const Mask &amp;bitmask, Function &amp;&amp;f, Args &amp;&amp;...args) const </td></tr>
<tr class="memdesc:a68064fa87e05d4bb75e776c85afea35d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Masked application of a function object.  <a href="#a68064fa87e05d4bb75e776c85afea35d"></a><br/></td></tr>
<tr class="separator:a68064fa87e05d4bb75e776c85afea35d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b48485c0550dcdf495ef70b4c36c09"><td class="memTemplParams" colspan="2">template&lt;typename Return  = Type, class Function  = std::plus&lt;Type&gt;, class  = typename std::enable_if&lt;!std::is_base_of&lt;Vectorizer, typename std::decay&lt;Function&gt;::type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ae9b48485c0550dcdf495ef70b4c36c09"><td class="memTemplItemLeft" align="right" valign="top">Return&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#ae9b48485c0550dcdf495ef70b4c36c09">reduce</a> (Function &amp;&amp;f=Function(), const Return &amp;init=Return()) const </td></tr>
<tr class="memdesc:ae9b48485c0550dcdf495ef70b4c36c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduction by a function object.  <a href="#ae9b48485c0550dcdf495ef70b4c36c09"></a><br/></td></tr>
<tr class="separator:ae9b48485c0550dcdf495ef70b4c36c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada52aff0e57fd3d7b464ed89f0a382dc"><td class="memTemplParams" colspan="2">template&lt;typename Return  = Type, class Mask , class Function  = std::plus&lt;Type&gt;, class  = typename std::enable_if&lt;(std::is_base_of&lt;Vectorizer, Mask&gt;::value) &amp;&amp; (!std::is_base_of&lt;Vectorizer, typename std::decay&lt;Function&gt;::type&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:ada52aff0e57fd3d7b464ed89f0a382dc"><td class="memTemplItemLeft" align="right" valign="top">Return&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#ada52aff0e57fd3d7b464ed89f0a382dc">reduce</a> (const Mask &amp;bitmask, Function &amp;&amp;f=Function(), const Return &amp;init=Return()) const </td></tr>
<tr class="memdesc:ada52aff0e57fd3d7b464ed89f0a382dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduction by a function object.  <a href="#ada52aff0e57fd3d7b464ed89f0a382dc"></a><br/></td></tr>
<tr class="separator:ada52aff0e57fd3d7b464ed89f0a382dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9bfeab0127573058117a760e29d6fc6"><td class="memTemplParams" colspan="2">template&lt;typename Result  = void, class Function , class Arg , class... Args, typename Return  = typename std::conditional&lt;std::is_void&lt;Result&gt;::value, typename std::common_type&lt;Type, Arg, Args...&gt;::type, Result&gt;::type&gt; </td></tr>
<tr class="memitem:af9bfeab0127573058117a760e29d6fc6"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; Return, Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#af9bfeab0127573058117a760e29d6fc6">combine</a> (Function &amp;&amp;f, const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, Arg, Parameters...&gt; &amp;arg, const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, Args, Parameters...&gt; &amp;...args) const </td></tr>
<tr class="memdesc:af9bfeab0127573058117a760e29d6fc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combination by a function object.  <a href="#af9bfeab0127573058117a760e29d6fc6"></a><br/></td></tr>
<tr class="separator:af9bfeab0127573058117a760e29d6fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31f97a4d517c0b50f6b00ec569bbdb1"><td class="memTemplParams" colspan="2">template&lt;typename Return  = Type, class Function &gt; </td></tr>
<tr class="memitem:af31f97a4d517c0b50f6b00ec569bbdb1"><td class="memTemplItemLeft" align="right" valign="top">Crtp&lt; Return, Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#af31f97a4d517c0b50f6b00ec569bbdb1">combine</a> (Function &amp;&amp;) const </td></tr>
<tr class="memdesc:af31f97a4d517c0b50f6b00ec569bbdb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unique combination by a function object.  <a href="#af31f97a4d517c0b50f6b00ec569bbdb1"></a><br/></td></tr>
<tr class="separator:af31f97a4d517c0b50f6b00ec569bbdb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Count</div></td></tr>
<tr class="memitem:ad80642295ec9673ab0843eb453a9b972"><td class="memTemplParams" colspan="2">template&lt;class Reference  = bool, class Mask  = std::true_type, class  = typename std::enable_if&lt;((std::is_convertible&lt;Type, Reference&gt;::value) || (std::is_base_of&lt;Vectorizer, Reference&gt;::value)) &amp;&amp; ((std::is_base_of&lt;Vectorizer, Mask&gt;::value) || (std::is_same&lt;std::true_type, Mask&gt;::value))&gt;::type&gt; </td></tr>
<tr class="memitem:ad80642295ec9673ab0843eb453a9b972"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#ad80642295ec9673ab0843eb453a9b972">count</a> (const Reference &amp;r=true, const Mask &amp;bitmask=Mask()) const </td></tr>
<tr class="memdesc:ad80642295ec9673ab0843eb453a9b972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count values.  <a href="#ad80642295ec9673ab0843eb453a9b972"></a><br/></td></tr>
<tr class="separator:ad80642295ec9673ab0843eb453a9b972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17209e21d93cf648d3428c79da6827b6"><td class="memTemplParams" colspan="2">template&lt;class Function , class Mask  = std::true_type, class  = typename std::enable_if&lt;((!std::is_convertible&lt;Type, typename std::decay&lt;Function&gt;::type&gt;::value) &amp;&amp; (!std::is_base_of&lt;Vectorizer, typename std::decay&lt;Function&gt;::type&gt;::value)) &amp;&amp; ((std::is_base_of&lt;Vectorizer, Mask&gt;::value) || (std::is_same&lt;std::true_type, Mask&gt;::value))&gt;::type&gt; </td></tr>
<tr class="memitem:a17209e21d93cf648d3428c79da6827b6"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a17209e21d93cf648d3428c79da6827b6">count</a> (Function &amp;&amp;f, const Mask &amp;bitmask=Mask()) const </td></tr>
<tr class="memdesc:a17209e21d93cf648d3428c79da6827b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count with predicate.  <a href="#a17209e21d93cf648d3428c79da6827b6"></a><br/></td></tr>
<tr class="separator:a17209e21d93cf648d3428c79da6827b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73db982b65b3486bf0a8d8f9819074bb"><td class="memTemplParams" colspan="2">template&lt;class Reference  = bool, class Mask  = std::true_type, class  = typename std::enable_if&lt;((std::is_convertible&lt;Type, Reference&gt;::value) || (std::is_base_of&lt;Vectorizer, Reference&gt;::value)) &amp;&amp; ((std::is_base_of&lt;Vectorizer, Mask&gt;::value) || (std::is_same&lt;std::true_type, Mask&gt;::value))&gt;::type&gt; </td></tr>
<tr class="memitem:a73db982b65b3486bf0a8d8f9819074bb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a73db982b65b3486bf0a8d8f9819074bb">all</a> (const Reference &amp;r=true, const Mask &amp;bitmask=Mask()) const </td></tr>
<tr class="memdesc:a73db982b65b3486bf0a8d8f9819074bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">All values equal.  <a href="#a73db982b65b3486bf0a8d8f9819074bb"></a><br/></td></tr>
<tr class="separator:a73db982b65b3486bf0a8d8f9819074bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f53cb6cecd0fa137baec7d459a54446"><td class="memTemplParams" colspan="2">template&lt;class Function , class Mask  = std::true_type, class  = typename std::enable_if&lt;((!std::is_convertible&lt;Type, typename std::decay&lt;Function&gt;::type&gt;::value) &amp;&amp; (!std::is_base_of&lt;Vectorizer, typename std::decay&lt;Function&gt;::type&gt;::value)) &amp;&amp; ((std::is_base_of&lt;Vectorizer, Mask&gt;::value) || (std::is_same&lt;std::true_type, Mask&gt;::value))&gt;::type&gt; </td></tr>
<tr class="memitem:a4f53cb6cecd0fa137baec7d459a54446"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a4f53cb6cecd0fa137baec7d459a54446">all</a> (Function &amp;&amp;f, const Mask &amp;bitmask=Mask()) const </td></tr>
<tr class="memdesc:a4f53cb6cecd0fa137baec7d459a54446"><td class="mdescLeft">&#160;</td><td class="mdescRight">All values satisfying the predicate.  <a href="#a4f53cb6cecd0fa137baec7d459a54446"></a><br/></td></tr>
<tr class="separator:a4f53cb6cecd0fa137baec7d459a54446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7948842eae5d264383ec3b3a125f66fd"><td class="memTemplParams" colspan="2">template&lt;class Reference  = bool, class Mask  = std::true_type, class  = typename std::enable_if&lt;((std::is_convertible&lt;Type, Reference&gt;::value) || (std::is_base_of&lt;Vectorizer, Reference&gt;::value)) &amp;&amp; ((std::is_base_of&lt;Vectorizer, Mask&gt;::value) || (std::is_same&lt;std::true_type, Mask&gt;::value))&gt;::type&gt; </td></tr>
<tr class="memitem:a7948842eae5d264383ec3b3a125f66fd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a7948842eae5d264383ec3b3a125f66fd">any</a> (const Reference &amp;r=true, const Mask &amp;bitmask=Mask()) const </td></tr>
<tr class="memdesc:a7948842eae5d264383ec3b3a125f66fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any value equal.  <a href="#a7948842eae5d264383ec3b3a125f66fd"></a><br/></td></tr>
<tr class="separator:a7948842eae5d264383ec3b3a125f66fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d11dea2ad7e727d05ba44fe3c507d65"><td class="memTemplParams" colspan="2">template&lt;class Function , class Mask  = std::true_type, class  = typename std::enable_if&lt;((!std::is_convertible&lt;Type, typename std::decay&lt;Function&gt;::type&gt;::value) &amp;&amp; (!std::is_base_of&lt;Vectorizer, typename std::decay&lt;Function&gt;::type&gt;::value)) &amp;&amp; ((std::is_base_of&lt;Vectorizer, Mask&gt;::value) || (std::is_same&lt;std::true_type, Mask&gt;::value))&gt;::type&gt; </td></tr>
<tr class="memitem:a7d11dea2ad7e727d05ba44fe3c507d65"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a7d11dea2ad7e727d05ba44fe3c507d65">any</a> (Function &amp;&amp;f, const Mask &amp;bitmask=Mask()) const </td></tr>
<tr class="memdesc:a7d11dea2ad7e727d05ba44fe3c507d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any value satisfying the predicate.  <a href="#a7d11dea2ad7e727d05ba44fe3c507d65"></a><br/></td></tr>
<tr class="separator:a7d11dea2ad7e727d05ba44fe3c507d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d72ba1d3a6d7cdaf384d0bad8eba11"><td class="memTemplParams" colspan="2">template&lt;class Reference  = bool, class Mask  = std::true_type, class  = typename std::enable_if&lt;((std::is_convertible&lt;Type, Reference&gt;::value) || (std::is_base_of&lt;Vectorizer, Reference&gt;::value)) &amp;&amp; ((std::is_base_of&lt;Vectorizer, Mask&gt;::value) || (std::is_same&lt;std::true_type, Mask&gt;::value))&gt;::type&gt; </td></tr>
<tr class="memitem:a69d72ba1d3a6d7cdaf384d0bad8eba11"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a69d72ba1d3a6d7cdaf384d0bad8eba11">none</a> (const Reference &amp;r=true, const Mask &amp;bitmask=Mask()) const </td></tr>
<tr class="memdesc:a69d72ba1d3a6d7cdaf384d0bad8eba11"><td class="mdescLeft">&#160;</td><td class="mdescRight">No value equal.  <a href="#a69d72ba1d3a6d7cdaf384d0bad8eba11"></a><br/></td></tr>
<tr class="separator:a69d72ba1d3a6d7cdaf384d0bad8eba11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f67d8c8a6733e73b5f26b3c3345173c"><td class="memTemplParams" colspan="2">template&lt;class Function , class Mask  = std::true_type, class  = typename std::enable_if&lt;((!std::is_convertible&lt;Type, typename std::decay&lt;Function&gt;::type&gt;::value) &amp;&amp; (!std::is_base_of&lt;Vectorizer, typename std::decay&lt;Function&gt;::type&gt;::value)) &amp;&amp; ((std::is_base_of&lt;Vectorizer, Mask&gt;::value) || (std::is_same&lt;std::true_type, Mask&gt;::value))&gt;::type&gt; </td></tr>
<tr class="memitem:a8f67d8c8a6733e73b5f26b3c3345173c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a8f67d8c8a6733e73b5f26b3c3345173c">none</a> (Function &amp;&amp;f, const Mask &amp;bitmask=Mask()) const </td></tr>
<tr class="memdesc:a8f67d8c8a6733e73b5f26b3c3345173c"><td class="mdescLeft">&#160;</td><td class="mdescRight">No value satisfying the predicate.  <a href="#a8f67d8c8a6733e73b5f26b3c3345173c"></a><br/></td></tr>
<tr class="separator:a8f67d8c8a6733e73b5f26b3c3345173c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmagrathea_1_1Vectorizer"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmagrathea_1_1Vectorizer')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmagrathea_1_1Vectorizer.html">magrathea::Vectorizer</a></td></tr>
<tr class="memitem:a83ebb071ab30dce7af155d3c0e597fb9 inherit pub_methods_classmagrathea_1_1Vectorizer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmagrathea_1_1Vectorizer.html">Vectorizer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#a83ebb071ab30dce7af155d3c0e597fb9">operator[]</a> (const unsigned int i)</td></tr>
<tr class="memdesc:a83ebb071ab30dce7af155d3c0e597fb9 inherit pub_methods_classmagrathea_1_1Vectorizer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the element.  <a href="#a83ebb071ab30dce7af155d3c0e597fb9"></a><br/></td></tr>
<tr class="separator:a83ebb071ab30dce7af155d3c0e597fb9 inherit pub_methods_classmagrathea_1_1Vectorizer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa058daf8b240bb587b80888ab88340c7 inherit pub_methods_classmagrathea_1_1Vectorizer"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmagrathea_1_1Vectorizer.html">Vectorizer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#aa058daf8b240bb587b80888ab88340c7">operator[]</a> (const unsigned int i) const </td></tr>
<tr class="memdesc:aa058daf8b240bb587b80888ab88340c7 inherit pub_methods_classmagrathea_1_1Vectorizer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Immutable direct access to the element.  <a href="#aa058daf8b240bb587b80888ab88340c7"></a><br/></td></tr>
<tr class="separator:aa058daf8b240bb587b80888ab88340c7 inherit pub_methods_classmagrathea_1_1Vectorizer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3c5369c91276766e0197fa33ae4951 inherit pub_methods_classmagrathea_1_1Vectorizer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmagrathea_1_1Vectorizer.html">Vectorizer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#afe3c5369c91276766e0197fa33ae4951">resize</a> (const unsigned int n)</td></tr>
<tr class="memdesc:afe3c5369c91276766e0197fa33ae4951 inherit pub_methods_classmagrathea_1_1Vectorizer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the container.  <a href="#afe3c5369c91276766e0197fa33ae4951"></a><br/></td></tr>
<tr class="separator:afe3c5369c91276766e0197fa33ae4951 inherit pub_methods_classmagrathea_1_1Vectorizer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b54f2b5f17c2054f99e03c7c4614558 inherit pub_methods_classmagrathea_1_1Vectorizer"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#a3b54f2b5f17c2054f99e03c7c4614558">size</a> () const </td></tr>
<tr class="memdesc:a3b54f2b5f17c2054f99e03c7c4614558 inherit pub_methods_classmagrathea_1_1Vectorizer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the container.  <a href="#a3b54f2b5f17c2054f99e03c7c4614558"></a><br/></td></tr>
<tr class="separator:a3b54f2b5f17c2054f99e03c7c4614558 inherit pub_methods_classmagrathea_1_1Vectorizer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e30cc7971bfbcf7b21f993b56c0644e inherit pub_methods_classmagrathea_1_1Vectorizer"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#a2e30cc7971bfbcf7b21f993b56c0644e">constant</a> () const </td></tr>
<tr class="memdesc:a2e30cc7971bfbcf7b21f993b56c0644e inherit pub_methods_classmagrathea_1_1Vectorizer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether the container has a constant size.  <a href="#a2e30cc7971bfbcf7b21f993b56c0644e"></a><br/></td></tr>
<tr class="separator:a2e30cc7971bfbcf7b21f993b56c0644e inherit pub_methods_classmagrathea_1_1Vectorizer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5100fafcacd2c835380dbe0403422ec inherit pub_methods_classmagrathea_1_1Vectorizer"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#ab5100fafcacd2c835380dbe0403422ec">boolean</a> () const </td></tr>
<tr class="memdesc:ab5100fafcacd2c835380dbe0403422ec inherit pub_methods_classmagrathea_1_1Vectorizer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether the container has a boolean type.  <a href="#ab5100fafcacd2c835380dbe0403422ec"></a><br/></td></tr>
<tr class="separator:ab5100fafcacd2c835380dbe0403422ec inherit pub_methods_classmagrathea_1_1Vectorizer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7815b5c9e9ff56064306e7d07dae5bb7 inherit pub_methods_classmagrathea_1_1Vectorizer"><td class="memItemLeft" align="right" valign="top">std::array&lt; unsigned int, 0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#a7815b5c9e9ff56064306e7d07dae5bb7">parameters</a> () const </td></tr>
<tr class="memdesc:a7815b5c9e9ff56064306e7d07dae5bb7 inherit pub_methods_classmagrathea_1_1Vectorizer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the template parameters.  <a href="#a7815b5c9e9ff56064306e7d07dae5bb7"></a><br/></td></tr>
<tr class="separator:a7815b5c9e9ff56064306e7d07dae5bb7 inherit pub_methods_classmagrathea_1_1Vectorizer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46ebf417fa856107cb9b84db9939f76 inherit pub_methods_classmagrathea_1_1Vectorizer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#af46ebf417fa856107cb9b84db9939f76">type</a> () const </td></tr>
<tr class="memdesc:af46ebf417fa856107cb9b84db9939f76 inherit pub_methods_classmagrathea_1_1Vectorizer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the data type.  <a href="#af46ebf417fa856107cb9b84db9939f76"></a><br/></td></tr>
<tr class="separator:af46ebf417fa856107cb9b84db9939f76 inherit pub_methods_classmagrathea_1_1Vectorizer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Static vectorization</div></td></tr>
<tr class="memitem:a6fe290c124a079e831805e7272cef4e9"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a6fe290c124a079e831805e7272cef4e9">size</a> ()</td></tr>
<tr class="memdesc:a6fe290c124a079e831805e7272cef4e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the container.  <a href="#a6fe290c124a079e831805e7272cef4e9"></a><br/></td></tr>
<tr class="separator:a6fe290c124a079e831805e7272cef4e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd144433ff6622ecc6de294e63ebdd9"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a6fd144433ff6622ecc6de294e63ebdd9">constant</a> ()</td></tr>
<tr class="memdesc:a6fd144433ff6622ecc6de294e63ebdd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether the container has a constant size.  <a href="#a6fd144433ff6622ecc6de294e63ebdd9"></a><br/></td></tr>
<tr class="separator:a6fd144433ff6622ecc6de294e63ebdd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a697a4f8ce9376695ed71dd1ca89cdd75"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a697a4f8ce9376695ed71dd1ca89cdd75">boolean</a> ()</td></tr>
<tr class="memdesc:a697a4f8ce9376695ed71dd1ca89cdd75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether the container has a boolean type.  <a href="#a697a4f8ce9376695ed71dd1ca89cdd75"></a><br/></td></tr>
<tr class="separator:a697a4f8ce9376695ed71dd1ca89cdd75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92fa50efed3f2e5175472ece1aaf8ae5"><td class="memItemLeft" align="right" valign="top">static constexpr std::array<br class="typebreak"/>
&lt; Kind, sizeof...(Parameters)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a92fa50efed3f2e5175472ece1aaf8ae5">parameters</a> ()</td></tr>
<tr class="memdesc:a92fa50efed3f2e5175472ece1aaf8ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the template parameters.  <a href="#a92fa50efed3f2e5175472ece1aaf8ae5"></a><br/></td></tr>
<tr class="separator:a92fa50efed3f2e5175472ece1aaf8ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28c393a3896a3e839008c35d56b10a54"><td class="memItemLeft" align="right" valign="top">static Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a> ()</td></tr>
<tr class="memdesc:a28c393a3896a3e839008c35d56b10a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the data type.  <a href="#a28c393a3896a3e839008c35d56b10a54"></a><br/></td></tr>
<tr class="separator:a28c393a3896a3e839008c35d56b10a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Size</div></td></tr>
<tr class="memitem:a2a7178a1eb856275555049c9ec5df656"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a2a7178a1eb856275555049c9ec5df656">empty</a> ()</td></tr>
<tr class="memdesc:a2a7178a1eb856275555049c9ec5df656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether the container is empty.  <a href="#a2a7178a1eb856275555049c9ec5df656"></a><br/></td></tr>
<tr class="separator:a2a7178a1eb856275555049c9ec5df656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ffe27d8a71e308c00b3b3f2a85e1be5"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a0ffe27d8a71e308c00b3b3f2a85e1be5">capacity</a> ()</td></tr>
<tr class="memdesc:a0ffe27d8a71e308c00b3b3f2a85e1be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the capacity of the container.  <a href="#a0ffe27d8a71e308c00b3b3f2a85e1be5"></a><br/></td></tr>
<tr class="separator:a0ffe27d8a71e308c00b3b3f2a85e1be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab06780534568f370bf271ee8eedadccf"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#ab06780534568f370bf271ee8eedadccf">tbytes</a> ()</td></tr>
<tr class="memdesc:ab06780534568f370bf271ee8eedadccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the data type.  <a href="#ab06780534568f370bf271ee8eedadccf"></a><br/></td></tr>
<tr class="separator:ab06780534568f370bf271ee8eedadccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b5f40970d8e4f5481041f2f79d34fc"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned long <br class="typebreak"/>
long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#ab2b5f40970d8e4f5481041f2f79d34fc">bytes</a> ()</td></tr>
<tr class="memdesc:ab2b5f40970d8e4f5481041f2f79d34fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size in bytes.  <a href="#ab2b5f40970d8e4f5481041f2f79d34fc"></a><br/></td></tr>
<tr class="separator:ab2b5f40970d8e4f5481041f2f79d34fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa027feb6ed321fd9cd855e0cdb0207b5"><td class="memItemLeft" align="right" valign="top">static unsigned long long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#aa027feb6ed321fd9cd855e0cdb0207b5">space</a> ()</td></tr>
<tr class="memdesc:aa027feb6ed321fd9cd855e0cdb0207b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum available space.  <a href="#aa027feb6ed321fd9cd855e0cdb0207b5"></a><br/></td></tr>
<tr class="separator:aa027feb6ed321fd9cd855e0cdb0207b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Predefined</div></td></tr>
<tr class="memitem:a5283a8f67f6b68c9bad13f6f25b76df7"><td class="memItemLeft" align="right" valign="top">static Crtp&lt; bool, Parameters...&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a5283a8f67f6b68c9bad13f6f25b76df7">mask</a> (const bool value=true)</td></tr>
<tr class="memdesc:a5283a8f67f6b68c9bad13f6f25b76df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default mask creation.  <a href="#a5283a8f67f6b68c9bad13f6f25b76df7"></a><br/></td></tr>
<tr class="separator:a5283a8f67f6b68c9bad13f6f25b76df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a962b3baa77ee6fb4ab2a43f98c8f1"><td class="memTemplParams" colspan="2">template&lt;class Container , class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, Container&gt;::value) &amp;&amp; (std::is_convertible&lt;typename std::remove_reference&lt;decltype(std::declval&lt;Container&gt;()[0])&gt;::type, bool&gt;::value) &amp;&amp; ((std::is_void&lt;decltype(std::declval&lt;Container&gt;().flip())&gt;::value) || (std::is_reference&lt;decltype(std::declval&lt;Container&gt;().flip())&gt;::value))&gt;::type&gt; </td></tr>
<tr class="memitem:a39a962b3baa77ee6fb4ab2a43f98c8f1"><td class="memTemplItemLeft" align="right" valign="top">static Crtp&lt; bool, Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a39a962b3baa77ee6fb4ab2a43f98c8f1">mask</a> (const Container &amp;container)</td></tr>
<tr class="memdesc:a39a962b3baa77ee6fb4ab2a43f98c8f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard boolean container mask creation.  <a href="#a39a962b3baa77ee6fb4ab2a43f98c8f1"></a><br/></td></tr>
<tr class="separator:a39a962b3baa77ee6fb4ab2a43f98c8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9650665d8e8027a898b46c16940bad2d"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , class... Misc, class  = typename std::enable_if&lt;std::is_convertible&lt;OtherType, bool&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a9650665d8e8027a898b46c16940bad2d"><td class="memTemplItemLeft" align="right" valign="top">static Crtp&lt; bool, Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a9650665d8e8027a898b46c16940bad2d">mask</a> (const std::initializer_list&lt; OtherType &gt; &amp;source, const Misc &amp;...misc)</td></tr>
<tr class="memdesc:a9650665d8e8027a898b46c16940bad2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer list mask creation.  <a href="#a9650665d8e8027a898b46c16940bad2d"></a><br/></td></tr>
<tr class="separator:a9650665d8e8027a898b46c16940bad2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2b9766936bb0f20b743e23aeccf685"><td class="memTemplParams" colspan="2">template&lt;class... Misc, class  = typename std::enable_if&lt;sizeof...(Misc) != 0&gt;::type&gt; </td></tr>
<tr class="memitem:a7c2b9766936bb0f20b743e23aeccf685"><td class="memTemplItemLeft" align="right" valign="top">static Crtp&lt; bool, Parameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a7c2b9766936bb0f20b743e23aeccf685">mask</a> (const Misc &amp;...misc)</td></tr>
<tr class="memdesc:a7c2b9766936bb0f20b743e23aeccf685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic mask creation.  <a href="#a7c2b9766936bb0f20b743e23aeccf685"></a><br/></td></tr>
<tr class="separator:a7c2b9766936bb0f20b743e23aeccf685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Test</div></td></tr>
<tr class="memitem:af2e6bb70574c2b1bbec83b3769dcab8a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#af2e6bb70574c2b1bbec83b3769dcab8a">example</a> ()</td></tr>
<tr class="memdesc:af2e6bb70574c2b1bbec83b3769dcab8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Example function.  <a href="#af2e6bb70574c2b1bbec83b3769dcab8a"></a><br/></td></tr>
<tr class="separator:af2e6bb70574c2b1bbec83b3769dcab8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classmagrathea_1_1Vectorizer"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classmagrathea_1_1Vectorizer')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classmagrathea_1_1Vectorizer.html">magrathea::Vectorizer</a></td></tr>
<tr class="memitem:a9c5d14ef63c3245c6e3ba161e5efdf95 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memTemplParams" colspan="2">template&lt;bool Exception = true, class FirstType , class SecondType , class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, FirstType&gt;::value) || (!std::is_base_of&lt;Vectorizer, SecondType&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:a9c5d14ef63c3245c6e3ba161e5efdf95 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memTemplItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#a9c5d14ef63c3245c6e3ba161e5efdf95">check</a> (const FirstType &amp;, const SecondType &amp;)</td></tr>
<tr class="memdesc:a9c5d14ef63c3245c6e3ba161e5efdf95 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check compatibility with at least one non-vectorized type.  <a href="#a9c5d14ef63c3245c6e3ba161e5efdf95"></a><br/></td></tr>
<tr class="separator:a9c5d14ef63c3245c6e3ba161e5efdf95 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a8845625441b2b7ca940542c5a42ea inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memTemplParams" colspan="2">template&lt;bool Exception = true, class FirstType , class SecondType , class  = typename std::enable_if&lt;(std::is_base_of&lt;Vectorizer, FirstType&gt;::value) &amp;&amp; (std::is_base_of&lt;Vectorizer, SecondType&gt;::value)&gt;::type, class  = typename std::enable_if&lt;(FirstType::constant()) &amp;&amp; (SecondType::constant())&gt;::type&gt; </td></tr>
<tr class="memitem:a46a8845625441b2b7ca940542c5a42ea inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memTemplItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#a46a8845625441b2b7ca940542c5a42ea">check</a> (const FirstType &amp;, const SecondType &amp;)</td></tr>
<tr class="separator:a46a8845625441b2b7ca940542c5a42ea inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cbb51491c2e83e5cedeced2d5945cde inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memTemplParams" colspan="2">template&lt;bool Exception = true, class FirstType , class SecondType , class  = typename std::enable_if&lt;(std::is_base_of&lt;Vectorizer, FirstType&gt;::value) &amp;&amp; (std::is_base_of&lt;Vectorizer, SecondType&gt;::value)&gt;::type, class  = typename std::enable_if&lt;(!FirstType::constant()) || (!SecondType::constant())&gt;::type, class  = void&gt; </td></tr>
<tr class="memitem:a8cbb51491c2e83e5cedeced2d5945cde inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#a8cbb51491c2e83e5cedeced2d5945cde">check</a> (const FirstType &amp;first, const SecondType &amp;second)</td></tr>
<tr class="separator:a8cbb51491c2e83e5cedeced2d5945cde inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d9b9d79268199cbac2906cffd22c0d4 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memTemplParams" colspan="2">template&lt;typename IntegralType , IntegralType Value, typename DummyType  = unsigned int, class  = typename std::enable_if&lt;(std::is_integral&lt;IntegralType&gt;::value) &amp;&amp; (std::is_convertible&lt;DummyType, unsigned int&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:a8d9b9d79268199cbac2906cffd22c0d4 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memTemplItemLeft" align="right" valign="top">static constexpr IntegralType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#a8d9b9d79268199cbac2906cffd22c0d4">get</a> (const std::integral_constant&lt; IntegralType, Value &gt;, const DummyType=DummyType())</td></tr>
<tr class="memdesc:a8d9b9d79268199cbac2906cffd22c0d4 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integral constant getter.  <a href="#a8d9b9d79268199cbac2906cffd22c0d4"></a><br/></td></tr>
<tr class="separator:a8d9b9d79268199cbac2906cffd22c0d4 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a89b7c95b5067316ad946aaab3d5686 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename DummyType  = unsigned int, class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, DataType&gt;::value) &amp;&amp; (std::is_convertible&lt;DummyType, unsigned int&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:a7a89b7c95b5067316ad946aaab3d5686 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memTemplItemLeft" align="right" valign="top">static DataType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#a7a89b7c95b5067316ad946aaab3d5686">get</a> (DataType &amp;source, const DummyType=DummyType())</td></tr>
<tr class="memdesc:a7a89b7c95b5067316ad946aaab3d5686 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-vectorized getter.  <a href="#a7a89b7c95b5067316ad946aaab3d5686"></a><br/></td></tr>
<tr class="separator:a7a89b7c95b5067316ad946aaab3d5686 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a63af59c59b04cbbe01a3447a7ac552 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename DummyType  = unsigned int, class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, DataType&gt;::value) &amp;&amp; (std::is_convertible&lt;DummyType, unsigned int&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:a9a63af59c59b04cbbe01a3447a7ac552 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memTemplItemLeft" align="right" valign="top">static const DataType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#a9a63af59c59b04cbbe01a3447a7ac552">get</a> (const DataType &amp;source, const DummyType=DummyType())</td></tr>
<tr class="memdesc:a9a63af59c59b04cbbe01a3447a7ac552 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Immutable non-vectorized getter.  <a href="#a9a63af59c59b04cbbe01a3447a7ac552"></a><br/></td></tr>
<tr class="separator:a9a63af59c59b04cbbe01a3447a7ac552 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af077b83bc7bc9d07e59895cf3df6641e inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memTemplParams" colspan="2">template&lt;class VectorizedType , class  = typename std::enable_if&lt;std::is_base_of&lt;Vectorizer, VectorizedType&gt;::value&gt;::type, typename DataType  = typename std::remove_reference&lt;decltype(VectorizedType::type())&gt;::type&gt; </td></tr>
<tr class="memitem:af077b83bc7bc9d07e59895cf3df6641e inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memTemplItemLeft" align="right" valign="top">static DataType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#af077b83bc7bc9d07e59895cf3df6641e">get</a> (VectorizedType &amp;source, const unsigned int i)</td></tr>
<tr class="memdesc:af077b83bc7bc9d07e59895cf3df6641e inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector element getter.  <a href="#af077b83bc7bc9d07e59895cf3df6641e"></a><br/></td></tr>
<tr class="separator:af077b83bc7bc9d07e59895cf3df6641e inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3ae98c035c1f3004ee2f88f6179066 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memTemplParams" colspan="2">template&lt;class VectorizedType , class  = typename std::enable_if&lt;std::is_base_of&lt;Vectorizer, VectorizedType&gt;::value&gt;::type, typename DataType  = typename std::remove_reference&lt;decltype(VectorizedType::type())&gt;::type&gt; </td></tr>
<tr class="memitem:a3a3ae98c035c1f3004ee2f88f6179066 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memTemplItemLeft" align="right" valign="top">static const DataType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#a3a3ae98c035c1f3004ee2f88f6179066">get</a> (const VectorizedType &amp;source, const unsigned int i)</td></tr>
<tr class="memdesc:a3a3ae98c035c1f3004ee2f88f6179066 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Immutable vector element getter.  <a href="#a3a3ae98c035c1f3004ee2f88f6179066"></a><br/></td></tr>
<tr class="separator:a3a3ae98c035c1f3004ee2f88f6179066 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67836bbf5aced8fee531fd2caf839f15 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memTemplParams" colspan="2">template&lt;class VectorizedType , class  = typename std::enable_if&lt;std::is_base_of&lt;Vectorizer, VectorizedType&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a67836bbf5aced8fee531fd2caf839f15 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memTemplItemLeft" align="right" valign="top">static VectorizedType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#a67836bbf5aced8fee531fd2caf839f15">set</a> (VectorizedType &amp;destination)</td></tr>
<tr class="memdesc:a67836bbf5aced8fee531fd2caf839f15 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty setter.  <a href="#a67836bbf5aced8fee531fd2caf839f15"></a><br/></td></tr>
<tr class="separator:a67836bbf5aced8fee531fd2caf839f15 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa586478d9b24b19586ff1d6dfdff5b68 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memTemplParams" colspan="2">template&lt;class VectorizedType , class  = typename std::enable_if&lt;std::is_base_of&lt;Vectorizer, VectorizedType&gt;::value&gt;::type, class GenericType &gt; </td></tr>
<tr class="memitem:aa586478d9b24b19586ff1d6dfdff5b68 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memTemplItemLeft" align="right" valign="top">static VectorizedType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#aa586478d9b24b19586ff1d6dfdff5b68">set</a> (VectorizedType &amp;destination, const GenericType &amp;source)</td></tr>
<tr class="memdesc:aa586478d9b24b19586ff1d6dfdff5b68 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy setter.  <a href="#aa586478d9b24b19586ff1d6dfdff5b68"></a><br/></td></tr>
<tr class="separator:aa586478d9b24b19586ff1d6dfdff5b68 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab181cd6d6a7afb777ebab551cc36bc33 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memTemplParams" colspan="2">template&lt;class VectorizedType , class  = typename std::enable_if&lt;std::is_base_of&lt;Vectorizer, VectorizedType&gt;::value&gt;::type, class GenericType , class First , class Second , class... Others, class  = typename std::enable_if&lt;(sizeof...(Others) != 0) &amp;&amp; (sizeof...(Others) != 1)&gt;::type&gt; </td></tr>
<tr class="memitem:ab181cd6d6a7afb777ebab551cc36bc33 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memTemplItemLeft" align="right" valign="top">static VectorizedType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#ab181cd6d6a7afb777ebab551cc36bc33">set</a> (VectorizedType &amp;destination, const GenericType &amp;source, const First &amp;first, const Second &amp;second, const Others &amp;...others)</td></tr>
<tr class="memdesc:ab181cd6d6a7afb777ebab551cc36bc33 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variadic setter.  <a href="#ab181cd6d6a7afb777ebab551cc36bc33"></a><br/></td></tr>
<tr class="separator:ab181cd6d6a7afb777ebab551cc36bc33 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acccf60d696c7fdba17a8ff7bf0efa5de inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memTemplParams" colspan="2">template&lt;class VectorizedType , class  = typename std::enable_if&lt;std::is_base_of&lt;Vectorizer, VectorizedType&gt;::value&gt;::type, class GenericType , typename SizeType  = std::true_type, class  = typename std::enable_if&lt;(std::is_same&lt;SizeType, std::true_type&gt;::value) || (std::is_convertible&lt;SizeType, unsigned int&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:acccf60d696c7fdba17a8ff7bf0efa5de inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memTemplItemLeft" align="right" valign="top">static VectorizedType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#acccf60d696c7fdba17a8ff7bf0efa5de">set</a> (VectorizedType &amp;destination, const GenericType &amp;source, const unsigned int pos, const SizeType num=SizeType())</td></tr>
<tr class="memdesc:acccf60d696c7fdba17a8ff7bf0efa5de inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial setter.  <a href="#acccf60d696c7fdba17a8ff7bf0efa5de"></a><br/></td></tr>
<tr class="separator:acccf60d696c7fdba17a8ff7bf0efa5de inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3453b370f7c850f2ab17f20d0d3fb33 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memTemplParams" colspan="2">template&lt;class VectorizedType , class  = typename std::enable_if&lt;std::is_base_of&lt;Vectorizer, VectorizedType&gt;::value&gt;::type, typename DataType  = typename std::remove_reference&lt;decltype(VectorizedType::type())&gt;::type, typename SizeType  = std::true_type, class  = typename std::enable_if&lt;(std::is_convertible&lt;DataType, typename std::remove_reference&lt;decltype(std::declval&lt;VectorizedType&gt;()[0])&gt;::type&gt;::value) &amp;&amp; ((std::is_same&lt;SizeType, std::true_type&gt;::value) || (std::is_convertible&lt;SizeType, unsigned int&gt;::value))&gt;::type&gt; </td></tr>
<tr class="memitem:af3453b370f7c850f2ab17f20d0d3fb33 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memTemplItemLeft" align="right" valign="top">static VectorizedType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#af3453b370f7c850f2ab17f20d0d3fb33">set</a> (VectorizedType &amp;destination, const std::initializer_list&lt; DataType &gt; &amp;source, const unsigned int pos=0, const SizeType num=SizeType())</td></tr>
<tr class="memdesc:af3453b370f7c850f2ab17f20d0d3fb33 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial list setter.  <a href="#af3453b370f7c850f2ab17f20d0d3fb33"></a><br/></td></tr>
<tr class="separator:af3453b370f7c850f2ab17f20d0d3fb33 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0dd17adf7a9cc87583510b0ed84cde8 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memTemplParams" colspan="2">template&lt;class VectorizedType , class  = typename std::enable_if&lt;std::is_base_of&lt;Vectorizer, VectorizedType&gt;::value&gt;::type, typename IteratorType , typename SizeType  = std::true_type, class  = typename std::enable_if&lt;(std::is_same&lt;SizeType, std::true_type&gt;::value) || (std::is_convertible&lt;SizeType, unsigned int&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:ac0dd17adf7a9cc87583510b0ed84cde8 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memTemplItemLeft" align="right" valign="top">static VectorizedType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#ac0dd17adf7a9cc87583510b0ed84cde8">set</a> (VectorizedType &amp;destination, const IteratorType &amp;first, const IteratorType &amp;last, const unsigned int pos=0, const SizeType num=SizeType(), typename std::iterator_traits&lt; IteratorType &gt;::iterator_category *=nullptr)</td></tr>
<tr class="memdesc:ac0dd17adf7a9cc87583510b0ed84cde8 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial range setter.  <a href="#ac0dd17adf7a9cc87583510b0ed84cde8"></a><br/></td></tr>
<tr class="separator:ac0dd17adf7a9cc87583510b0ed84cde8 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea3e9a7f164f31f1f8f9b7ab3abe12c inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memTemplParams" colspan="2">template&lt;class VectorizedType , class  = typename std::enable_if&lt;std::is_base_of&lt;Vectorizer, VectorizedType&gt;::value&gt;::type, class GenericType , class MaskType , typename DummyType  = unsigned int, class  = typename std::enable_if&lt;(std::is_base_of&lt;Vectorizer, MaskType&gt;::value) &amp;&amp; (std::is_convertible&lt;DummyType, unsigned int&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:a5ea3e9a7f164f31f1f8f9b7ab3abe12c inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memTemplItemLeft" align="right" valign="top">static VectorizedType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#a5ea3e9a7f164f31f1f8f9b7ab3abe12c">set</a> (VectorizedType &amp;destination, const GenericType &amp;source, const MaskType &amp;mask, const DummyType=DummyType())</td></tr>
<tr class="memdesc:a5ea3e9a7f164f31f1f8f9b7ab3abe12c inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Masked setter.  <a href="#a5ea3e9a7f164f31f1f8f9b7ab3abe12c"></a><br/></td></tr>
<tr class="separator:a5ea3e9a7f164f31f1f8f9b7ab3abe12c inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc7d73a284fc36d87653df867ef6e00 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memTemplParams" colspan="2">template&lt;class VectorizedType , class  = typename std::enable_if&lt;std::is_base_of&lt;Vectorizer, VectorizedType&gt;::value&gt;::type, typename DataType  = typename std::remove_reference&lt;decltype(VectorizedType::type())&gt;::type, class MaskType , typename DummyType  = unsigned int, class  = typename std::enable_if&lt;(std::is_base_of&lt;Vectorizer, MaskType&gt;::value) &amp;&amp; (std::is_convertible&lt;DummyType, unsigned int&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:aacc7d73a284fc36d87653df867ef6e00 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memTemplItemLeft" align="right" valign="top">static VectorizedType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#aacc7d73a284fc36d87653df867ef6e00">set</a> (VectorizedType &amp;destination, const std::initializer_list&lt; DataType &gt; &amp;source, const MaskType &amp;mask, const DummyType=DummyType())</td></tr>
<tr class="memdesc:aacc7d73a284fc36d87653df867ef6e00 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Masked list setter.  <a href="#aacc7d73a284fc36d87653df867ef6e00"></a><br/></td></tr>
<tr class="separator:aacc7d73a284fc36d87653df867ef6e00 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6c5228f8e7f3bba38d57886a4ef51a inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memTemplParams" colspan="2">template&lt;class VectorizedType , class  = typename std::enable_if&lt;std::is_base_of&lt;Vectorizer, VectorizedType&gt;::value&gt;::type, typename IteratorType , class MaskType , typename DummyType  = unsigned int, class  = typename std::enable_if&lt;(std::is_base_of&lt;Vectorizer, MaskType&gt;::value) &amp;&amp; (std::is_convertible&lt;DummyType, unsigned int&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:a0f6c5228f8e7f3bba38d57886a4ef51a inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memTemplItemLeft" align="right" valign="top">static VectorizedType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#a0f6c5228f8e7f3bba38d57886a4ef51a">set</a> (VectorizedType &amp;destination, const IteratorType &amp;first, const IteratorType &amp;last, const MaskType &amp;mask, const DummyType=DummyType(), typename std::iterator_traits&lt; IteratorType &gt;::iterator_category *=nullptr)</td></tr>
<tr class="memdesc:a0f6c5228f8e7f3bba38d57886a4ef51a inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Masked range setter.  <a href="#a0f6c5228f8e7f3bba38d57886a4ef51a"></a><br/></td></tr>
<tr class="separator:a0f6c5228f8e7f3bba38d57886a4ef51a inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302758cf072c56ea44519a41c2b70171 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#a302758cf072c56ea44519a41c2b70171">example</a> ()</td></tr>
<tr class="memdesc:a302758cf072c56ea44519a41c2b70171 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Example function.  <a href="#a302758cf072c56ea44519a41c2b70171"></a><br/></td></tr>
<tr class="separator:a302758cf072c56ea44519a41c2b70171 inherit pub_static_methods_classmagrathea_1_1Vectorizer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Protected lifecycle</div></td></tr>
<tr class="memitem:a5d421da12b047916b58fc13c6ebb7971"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a5d421da12b047916b58fc13c6ebb7971">~StaticVectorizer</a> ()</td></tr>
<tr class="memdesc:a5d421da12b047916b58fc13c6ebb7971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protected destructor.  <a href="#a5d421da12b047916b58fc13c6ebb7971"></a><br/></td></tr>
<tr class="separator:a5d421da12b047916b58fc13c6ebb7971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classmagrathea_1_1Vectorizer"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classmagrathea_1_1Vectorizer')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classmagrathea_1_1Vectorizer.html">magrathea::Vectorizer</a></td></tr>
<tr class="memitem:ab42248d231900ce89e17405a9e751535 inherit pro_methods_classmagrathea_1_1Vectorizer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html#ab42248d231900ce89e17405a9e751535">~Vectorizer</a> ()</td></tr>
<tr class="memdesc:ab42248d231900ce89e17405a9e751535 inherit pro_methods_classmagrathea_1_1Vectorizer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protected destructor.  <a href="#ab42248d231900ce89e17405a9e751535"></a><br/></td></tr>
<tr class="separator:ab42248d231900ce89e17405a9e751535 inherit pro_methods_classmagrathea_1_1Vectorizer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Operators : with lhs value</div></td></tr>
<tr class="memitem:a8b6774aab42c9363c5820c74ccc0a02e"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class &gt; </td></tr>
<tr class="memitem:a8b6774aab42c9363c5820c74ccc0a02e"><td class="memTemplItemLeft" align="right" valign="top">SelfCrtp&lt; typename <br class="typebreak"/>
std::common_type&lt; SelfType, <br class="typebreak"/>
OtherType &gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, <br class="typebreak"/>
SelfParameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a8b6774aab42c9363c5820c74ccc0a02e">operator+</a> (const OtherType &amp;lhs, const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;rhs)</td></tr>
<tr class="memdesc:a8b6774aab42c9363c5820c74ccc0a02e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition with lhs value.  <a href="#a8b6774aab42c9363c5820c74ccc0a02e"></a><br/></td></tr>
<tr class="separator:a8b6774aab42c9363c5820c74ccc0a02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca40e03311c4e8c24e77ce2532b68d7"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class &gt; </td></tr>
<tr class="memitem:a7ca40e03311c4e8c24e77ce2532b68d7"><td class="memTemplItemLeft" align="right" valign="top">SelfCrtp&lt; typename <br class="typebreak"/>
std::common_type&lt; SelfType, <br class="typebreak"/>
OtherType &gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, <br class="typebreak"/>
SelfParameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a7ca40e03311c4e8c24e77ce2532b68d7">operator-</a> (const OtherType &amp;lhs, const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;rhs)</td></tr>
<tr class="memdesc:a7ca40e03311c4e8c24e77ce2532b68d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substraction with lhs value.  <a href="#a7ca40e03311c4e8c24e77ce2532b68d7"></a><br/></td></tr>
<tr class="separator:a7ca40e03311c4e8c24e77ce2532b68d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3569cddd30a871d7e2b3dde8e5edecc7"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class &gt; </td></tr>
<tr class="memitem:a3569cddd30a871d7e2b3dde8e5edecc7"><td class="memTemplItemLeft" align="right" valign="top">SelfCrtp&lt; typename <br class="typebreak"/>
std::common_type&lt; SelfType, <br class="typebreak"/>
OtherType &gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, <br class="typebreak"/>
SelfParameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a3569cddd30a871d7e2b3dde8e5edecc7">operator*</a> (const OtherType &amp;lhs, const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;rhs)</td></tr>
<tr class="memdesc:a3569cddd30a871d7e2b3dde8e5edecc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication with lhs value.  <a href="#a3569cddd30a871d7e2b3dde8e5edecc7"></a><br/></td></tr>
<tr class="separator:a3569cddd30a871d7e2b3dde8e5edecc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6fb0e0d7f699355cbaf6698d0b66c4"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class &gt; </td></tr>
<tr class="memitem:a5e6fb0e0d7f699355cbaf6698d0b66c4"><td class="memTemplItemLeft" align="right" valign="top">SelfCrtp&lt; typename <br class="typebreak"/>
std::common_type&lt; SelfType, <br class="typebreak"/>
OtherType &gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, <br class="typebreak"/>
SelfParameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a5e6fb0e0d7f699355cbaf6698d0b66c4">operator/</a> (const OtherType &amp;lhs, const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;rhs)</td></tr>
<tr class="memdesc:a5e6fb0e0d7f699355cbaf6698d0b66c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division with lhs value.  <a href="#a5e6fb0e0d7f699355cbaf6698d0b66c4"></a><br/></td></tr>
<tr class="separator:a5e6fb0e0d7f699355cbaf6698d0b66c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5662ba4d3f881341cc797968af9fa41"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class &gt; </td></tr>
<tr class="memitem:aa5662ba4d3f881341cc797968af9fa41"><td class="memTemplItemLeft" align="right" valign="top">SelfCrtp&lt; typename <br class="typebreak"/>
std::common_type&lt; SelfType, <br class="typebreak"/>
OtherType &gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, <br class="typebreak"/>
SelfParameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#aa5662ba4d3f881341cc797968af9fa41">operator%</a> (const OtherType &amp;lhs, const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;rhs)</td></tr>
<tr class="memdesc:aa5662ba4d3f881341cc797968af9fa41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modulo with lhs value.  <a href="#aa5662ba4d3f881341cc797968af9fa41"></a><br/></td></tr>
<tr class="separator:aa5662ba4d3f881341cc797968af9fa41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca1e5aa41c2048a2543030ce7456354"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class &gt; </td></tr>
<tr class="memitem:afca1e5aa41c2048a2543030ce7456354"><td class="memTemplItemLeft" align="right" valign="top">SelfCrtp&lt; typename <br class="typebreak"/>
std::common_type&lt; SelfType, <br class="typebreak"/>
OtherType &gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, <br class="typebreak"/>
SelfParameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#afca1e5aa41c2048a2543030ce7456354">operator&amp;</a> (const OtherType &amp;lhs, const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;rhs)</td></tr>
<tr class="memdesc:afca1e5aa41c2048a2543030ce7456354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise AND with lhs value.  <a href="#afca1e5aa41c2048a2543030ce7456354"></a><br/></td></tr>
<tr class="separator:afca1e5aa41c2048a2543030ce7456354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c589260c56e0aa83231d668b5b8bf8"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class &gt; </td></tr>
<tr class="memitem:af8c589260c56e0aa83231d668b5b8bf8"><td class="memTemplItemLeft" align="right" valign="top">SelfCrtp&lt; typename <br class="typebreak"/>
std::common_type&lt; SelfType, <br class="typebreak"/>
OtherType &gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, <br class="typebreak"/>
SelfParameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#af8c589260c56e0aa83231d668b5b8bf8">operator|</a> (const OtherType &amp;lhs, const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;rhs)</td></tr>
<tr class="memdesc:af8c589260c56e0aa83231d668b5b8bf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise OR with lhs value.  <a href="#af8c589260c56e0aa83231d668b5b8bf8"></a><br/></td></tr>
<tr class="separator:af8c589260c56e0aa83231d668b5b8bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a22c5599a1abe3672de5342dd8bef0"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class &gt; </td></tr>
<tr class="memitem:a00a22c5599a1abe3672de5342dd8bef0"><td class="memTemplItemLeft" align="right" valign="top">SelfCrtp&lt; typename <br class="typebreak"/>
std::common_type&lt; SelfType, <br class="typebreak"/>
OtherType &gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, <br class="typebreak"/>
SelfParameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a00a22c5599a1abe3672de5342dd8bef0">operator^</a> (const OtherType &amp;lhs, const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;rhs)</td></tr>
<tr class="memdesc:a00a22c5599a1abe3672de5342dd8bef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise XOR with lhs value.  <a href="#a00a22c5599a1abe3672de5342dd8bef0"></a><br/></td></tr>
<tr class="separator:a00a22c5599a1abe3672de5342dd8bef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6962dd6aa68898e5b0656c7d1db54efd"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class &gt; </td></tr>
<tr class="memitem:a6962dd6aa68898e5b0656c7d1db54efd"><td class="memTemplItemLeft" align="right" valign="top">SelfCrtp&lt; OtherType, <br class="typebreak"/>
SelfParameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a6962dd6aa68898e5b0656c7d1db54efd">operator&lt;&lt;</a> (const OtherType &amp;lhs, const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;rhs)</td></tr>
<tr class="memdesc:a6962dd6aa68898e5b0656c7d1db54efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise left shift with lhs value.  <a href="#a6962dd6aa68898e5b0656c7d1db54efd"></a><br/></td></tr>
<tr class="separator:a6962dd6aa68898e5b0656c7d1db54efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea24bc9e8e6d2db161ea115bc587446"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class &gt; </td></tr>
<tr class="memitem:a4ea24bc9e8e6d2db161ea115bc587446"><td class="memTemplItemLeft" align="right" valign="top">SelfCrtp&lt; OtherType, <br class="typebreak"/>
SelfParameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a4ea24bc9e8e6d2db161ea115bc587446">operator&gt;&gt;</a> (const OtherType &amp;lhs, const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;rhs)</td></tr>
<tr class="memdesc:a4ea24bc9e8e6d2db161ea115bc587446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise right shift with lhs value.  <a href="#a4ea24bc9e8e6d2db161ea115bc587446"></a><br/></td></tr>
<tr class="separator:a4ea24bc9e8e6d2db161ea115bc587446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae2fc75417259acf41fd1d84ffb5469b"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class &gt; </td></tr>
<tr class="memitem:aae2fc75417259acf41fd1d84ffb5469b"><td class="memTemplItemLeft" align="right" valign="top">SelfCrtp&lt; bool, SelfParameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#aae2fc75417259acf41fd1d84ffb5469b">operator&amp;&amp;</a> (const OtherType &amp;lhs, const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;rhs)</td></tr>
<tr class="memdesc:aae2fc75417259acf41fd1d84ffb5469b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical AND with lhs value.  <a href="#aae2fc75417259acf41fd1d84ffb5469b"></a><br/></td></tr>
<tr class="separator:aae2fc75417259acf41fd1d84ffb5469b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324a2459dcb212c2e79f7bdccebe80d2"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class &gt; </td></tr>
<tr class="memitem:a324a2459dcb212c2e79f7bdccebe80d2"><td class="memTemplItemLeft" align="right" valign="top">SelfCrtp&lt; bool, SelfParameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a324a2459dcb212c2e79f7bdccebe80d2">operator||</a> (const OtherType &amp;lhs, const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;rhs)</td></tr>
<tr class="memdesc:a324a2459dcb212c2e79f7bdccebe80d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical OR with lhs value.  <a href="#a324a2459dcb212c2e79f7bdccebe80d2"></a><br/></td></tr>
<tr class="separator:a324a2459dcb212c2e79f7bdccebe80d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae434f3dcb55f00b2c92e63385f9e5b42"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class &gt; </td></tr>
<tr class="memitem:ae434f3dcb55f00b2c92e63385f9e5b42"><td class="memTemplItemLeft" align="right" valign="top">SelfCrtp&lt; bool, SelfParameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#ae434f3dcb55f00b2c92e63385f9e5b42">operator==</a> (const OtherType &amp;lhs, const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;rhs)</td></tr>
<tr class="memdesc:ae434f3dcb55f00b2c92e63385f9e5b42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equal to with lhs value.  <a href="#ae434f3dcb55f00b2c92e63385f9e5b42"></a><br/></td></tr>
<tr class="separator:ae434f3dcb55f00b2c92e63385f9e5b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bfc60393edce795fa5bd2b3bb339ef5"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class &gt; </td></tr>
<tr class="memitem:a8bfc60393edce795fa5bd2b3bb339ef5"><td class="memTemplItemLeft" align="right" valign="top">SelfCrtp&lt; bool, SelfParameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a8bfc60393edce795fa5bd2b3bb339ef5">operator!=</a> (const OtherType &amp;lhs, const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;rhs)</td></tr>
<tr class="memdesc:a8bfc60393edce795fa5bd2b3bb339ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not equal to with lhs value.  <a href="#a8bfc60393edce795fa5bd2b3bb339ef5"></a><br/></td></tr>
<tr class="separator:a8bfc60393edce795fa5bd2b3bb339ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1004dafefb091d626f80081672cbab19"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class &gt; </td></tr>
<tr class="memitem:a1004dafefb091d626f80081672cbab19"><td class="memTemplItemLeft" align="right" valign="top">SelfCrtp&lt; bool, SelfParameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a1004dafefb091d626f80081672cbab19">operator&gt;</a> (const OtherType &amp;lhs, const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;rhs)</td></tr>
<tr class="memdesc:a1004dafefb091d626f80081672cbab19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than with lhs value.  <a href="#a1004dafefb091d626f80081672cbab19"></a><br/></td></tr>
<tr class="separator:a1004dafefb091d626f80081672cbab19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60adf27d2657f948be21910673c6304"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class &gt; </td></tr>
<tr class="memitem:af60adf27d2657f948be21910673c6304"><td class="memTemplItemLeft" align="right" valign="top">SelfCrtp&lt; bool, SelfParameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#af60adf27d2657f948be21910673c6304">operator&lt;</a> (const OtherType &amp;lhs, const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;rhs)</td></tr>
<tr class="memdesc:af60adf27d2657f948be21910673c6304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than with lhs value.  <a href="#af60adf27d2657f948be21910673c6304"></a><br/></td></tr>
<tr class="separator:af60adf27d2657f948be21910673c6304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eff4653f0b8a216af1547f5094980a1"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class &gt; </td></tr>
<tr class="memitem:a7eff4653f0b8a216af1547f5094980a1"><td class="memTemplItemLeft" align="right" valign="top">SelfCrtp&lt; bool, SelfParameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a7eff4653f0b8a216af1547f5094980a1">operator&gt;=</a> (const OtherType &amp;lhs, const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;rhs)</td></tr>
<tr class="memdesc:a7eff4653f0b8a216af1547f5094980a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than or equal to with lhs value.  <a href="#a7eff4653f0b8a216af1547f5094980a1"></a><br/></td></tr>
<tr class="separator:a7eff4653f0b8a216af1547f5094980a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56bd8400d219fc4e39c5973a1db97c71"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class &gt; </td></tr>
<tr class="memitem:a56bd8400d219fc4e39c5973a1db97c71"><td class="memTemplItemLeft" align="right" valign="top">SelfCrtp&lt; bool, SelfParameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a56bd8400d219fc4e39c5973a1db97c71">operator&lt;=</a> (const OtherType &amp;lhs, const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;rhs)</td></tr>
<tr class="memdesc:a56bd8400d219fc4e39c5973a1db97c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than or equal to with lhs value.  <a href="#a56bd8400d219fc4e39c5973a1db97c71"></a><br/></td></tr>
<tr class="separator:a56bd8400d219fc4e39c5973a1db97c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Stream</div></td></tr>
<tr class="memitem:abe6a86f2659fddc66d572f8fb8f7d452"><td class="memTemplParams" colspan="2">template&lt;typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters&gt; </td></tr>
<tr class="memitem:abe6a86f2659fddc66d572f8fb8f7d452"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#abe6a86f2659fddc66d572f8fb8f7d452">operator&lt;&lt;</a> (std::ostream &amp;lhs, const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;rhs)</td></tr>
<tr class="memdesc:abe6a86f2659fddc66d572f8fb8f7d452"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream operator.  <a href="#abe6a86f2659fddc66d572f8fb8f7d452"></a><br/></td></tr>
<tr class="separator:abe6a86f2659fddc66d572f8fb8f7d452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8948c3cd04e4f435ed0b8a3f243e75"><td class="memTemplParams" colspan="2">template&lt;typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters&gt; </td></tr>
<tr class="memitem:a6d8948c3cd04e4f435ed0b8a3f243e75"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a6d8948c3cd04e4f435ed0b8a3f243e75">operator&gt;&gt;</a> (std::istream &amp;lhs, <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;rhs)</td></tr>
<tr class="memdesc:a6d8948c3cd04e4f435ed0b8a3f243e75"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="exceptionInput.html" title="Input utilities for raytracing.">Input</a> stream operator.  <a href="#a6d8948c3cd04e4f435ed0b8a3f243e75"></a><br/></td></tr>
<tr class="separator:a6d8948c3cd04e4f435ed0b8a3f243e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type, Kind... Parameters&gt;<br/>
class magrathea::StaticVectorizer&lt; Kind, Size, Crtp, Type, Parameters &gt;</h3>

<p>Helper class for generic constant size vectorization. </p>
<p>Provides vectorization for constant size containers thanks to the curiously recurring template pattern (CRTP) trick. To use it, one has to derive from this class and pass the derived class itself as the CRTP parameter. The derived classes have to satisfy the conditions required by the <a class="el" href="classmagrathea_1_1Vectorizer.html" title="Helper base class for generic vectorization.">Vectorizer</a> base class and have to implement the following functions required by CRTP : </p>
<ul>
<li>
<code><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a4b5d5e63c27e77f1d734f80d7ca3d2df" title="Direct access to the element.">operator[](const unsigned int)</a></code></li>
</ul>
<p>One can also modify members like <code>operator()</code> to change the behaviour of the function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Kind</td><td>Kind of arguments. </td></tr>
    <tr><td class="paramname">Size</td><td>Number of elements. </td></tr>
    <tr><td class="paramname">Crtp</td><td>Derived CRTP class. </td></tr>
    <tr><td class="paramname">Type</td><td>Data type. </td></tr>
    <tr><td class="paramname">Parameters</td><td>List of parameters. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5d421da12b047916b58fc13c6ebb7971"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::~<a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Protected destructor. </p>
<p>Does nothing. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a73db982b65b3486bf0a8d8f9819074bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;class Reference , class Mask , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::all </td>
          <td>(</td>
          <td class="paramtype">const Reference &amp;&#160;</td>
          <td class="paramname"><em>r</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mask &amp;&#160;</td>
          <td class="paramname"><em>bitmask</em> = <code>Mask()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All values equal. </p>
<p>Checks if the comparison with the provided reference returns true for all elements in the specified region. Note that before any comparison, the values in the container are casted to the reference data type. With no argument, this function returns true if the whole contents is non-null (true). It returns true if the container is empty. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Reference</td><td>(Reference type.) </td></tr>
    <tr><td class="paramname">Mask</td><td>(Mask type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>Reference for comparison : value or vectorized container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bitmask</td><td>Boolean mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Copy of the boolean result. </dd></dl>

</div>
</div>
<a class="anchor" id="a4f53cb6cecd0fa137baec7d459a54446"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;class Function , class Mask , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::all </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mask &amp;&#160;</td>
          <td class="paramname"><em>bitmask</em> = <code>Mask()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All values satisfying the predicate. </p>
<p>Checks if the unary predicate returns true for all elements in the specified region. It returns true if the container is empty. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Function</td><td>(Function type : <code>bool(Type)</code>.) </td></tr>
    <tr><td class="paramname">Mask</td><td>(Mask type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Predicate <code>bool(Type)</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bitmask</td><td>Boolean mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Copy of the boolean result. </dd></dl>

</div>
</div>
<a class="anchor" id="a7948842eae5d264383ec3b3a125f66fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;class Reference , class Mask , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::any </td>
          <td>(</td>
          <td class="paramtype">const Reference &amp;&#160;</td>
          <td class="paramname"><em>r</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mask &amp;&#160;</td>
          <td class="paramname"><em>bitmask</em> = <code>Mask()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Any value equal. </p>
<p>Checks if the comparison with the provided reference returns true for any element in the specified region. Note that before any comparison, the values in the container are casted to the reference data type. With no argument, this function returns true if the whole contents is non-null (true). It returns false if the container is empty. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Reference</td><td>(Reference type.) </td></tr>
    <tr><td class="paramname">Mask</td><td>(Mask type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>Reference for comparison : value or vectorized container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bitmask</td><td>Boolean mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Copy of the boolean result. </dd></dl>

</div>
</div>
<a class="anchor" id="a7d11dea2ad7e727d05ba44fe3c507d65"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;class Function , class Mask , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::any </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mask &amp;&#160;</td>
          <td class="paramname"><em>bitmask</em> = <code>Mask()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Any value satisfying the predicate. </p>
<p>Checks if the unary predicate returns true for any element in the specified region. It returns false if the container is empty. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Function</td><td>(Function type : <code>bool(Type)</code>.) </td></tr>
    <tr><td class="paramname">Mask</td><td>(Mask type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Predicate <code>bool(Type)</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bitmask</td><td>Boolean mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Copy of the boolean result. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ba0cf8fddea6caac41800e7fc43889f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename Return , class Function , class... Args, class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; Return, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Application of a function object. </p>
<p>Applies a function object to each element of the container and returns a copy of the result. For a result <code>y</code>, an element <code>x</code>, a function <code>f</code> and for extra arguments <code>args...</code>, an equivalent expression is : <code>y = f(x, args...)</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Return</td><td>Return type. </td></tr>
    <tr><td class="paramname">Function</td><td>(Function type : <code>Return(Type, Args...)</code>.) </td></tr>
    <tr><td class="paramname">Args</td><td>(Extra types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Function object <code>Return(Type, Args...)</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Extra arguments of the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Copy. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The size of the extra arguments is not checked. </dd></dl>

</div>
</div>
<a class="anchor" id="a68064fa87e05d4bb75e776c85afea35d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename Return , class Mask , class Function, class... Args, class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; Return, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const Mask &amp;&#160;</td>
          <td class="paramname"><em>bitmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Masked application of a function object. </p>
<p>Applies a function object to each element of the container where the mask is true and returns a copy of the result. For a result <code>y</code>, an element <code>x</code>, a function <code>f</code> and for extra arguments <code>args...</code>, an equivalent expression is : <code>y = f(x, args...)</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Return</td><td>Return type. </td></tr>
    <tr><td class="paramname">Mask</td><td>(Mask type.) </td></tr>
    <tr><td class="paramname">Function</td><td>(Function type : <code>Return(Type, Args...)</code>.) </td></tr>
    <tr><td class="paramname">Args</td><td>(Extra types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitmask</td><td>Boolean mask. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Function object <code>Return(Type, Args...)</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Extra arguments of the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Copy. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The size of the extra arguments is not checked. </dd></dl>

</div>
</div>
<a class="anchor" id="aa026b0cb951858dfbebaf4df9d02dd28"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , class... Misc, class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; Type, Parameters...&gt; &amp; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; OtherType &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Misc &amp;...&#160;</td>
          <td class="paramname"><em>misc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializer list assignment. </p>
<p>Provides an assignment from an initializer list equivalent to a call to a constructor. Before any operation, the contents is reinitialized to its default value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
    <tr><td class="paramname">Misc</td><td>(<a class="el" href="classMiscellaneous.html">Miscellaneous</a> types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>Source of the copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">misc</td><td><a class="el" href="classMiscellaneous.html">Miscellaneous</a> arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Self reference. </dd></dl>

</div>
</div>
<a class="anchor" id="aeecd6ce10ed87346885bf4c7aeef7ae6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;class... Misc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; Type, Parameters...&gt; &amp; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const Misc &amp;...&#160;</td>
          <td class="paramname"><em>misc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic assignment. </p>
<p>Provides a generic assignment equivalent to a call to a constructor. Before any operation, the contents is reinitialized to its default value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Misc</td><td>(<a class="el" href="classMiscellaneous.html">Miscellaneous</a> types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">misc</td><td><a class="el" href="classMiscellaneous.html">Miscellaneous</a> arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Self reference. </dd></dl>

</div>
</div>
<a class="anchor" id="a842eaff610697adbed8b6bb4e403a39f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type &amp; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Monodimensional access with range-check. </p>
<p>Provides a monodimensional access to the element with a range-check. Due to the check this function is slower than the <code>[]</code> or the <code>()</code> operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Element index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>Out of range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a293da0f31f6a8db5efb9c9ebb7ff3a81"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Type &amp; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Immutable monodimensional access with range-check. </p>
<p>Provides a monodimensional access to the element with a range-check. Due to the check this function is slower than the <code>[]</code> or the <code>()</code> operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Element index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Immutable reference to the element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>Out of range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae1d5d72bbbf0c8b41de7ff463eb72606"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type &amp; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::back </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Monodimensional access to the i-th element from the end. </p>
<p>Returns a reference to the i-th last element in the container without doing any range check. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Element index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the element. </dd></dl>

</div>
</div>
<a class="anchor" id="a3efc84b306bb29fdcc1c13b0bb46e603"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Type &amp; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::back </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Immutable monodimensional access to the i-th element from the end. </p>
<p>Returns a reference to the i-th last element in the container without doing any range check. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Element index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Immutable reference to the element. </dd></dl>

</div>
</div>
<a class="anchor" id="a697a4f8ce9376695ed71dd1ca89cdd75"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::boolean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get whether the container has a boolean type. </p>
<p>Returns true if the container has a boolean type, false otherwise. This function is required by the vectorization mechanism. </p>
<dl class="section return"><dt>Returns</dt><dd>Copy of true if the container has a boolean type. </dd></dl>

</div>
</div>
<a class="anchor" id="ab2b5f40970d8e4f5481041f2f79d34fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned long long int <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::bytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size in bytes. </p>
<p>Returns the total size in bytes which is the number of elements multiplied by the size in bytes of an element. This does not take into account alignment bytes : to get the real memory imprint use the <code>sizeof()</code> function. </p>
<dl class="section return"><dt>Returns</dt><dd>Copy of the size in bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="a0ffe27d8a71e308c00b3b3f2a85e1be5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned int <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the capacity of the container. </p>
<p>Returns the capacity of the container, which is equal to its size. </p>
<dl class="section return"><dt>Returns</dt><dd>Copy of the capacity. </dd></dl>

</div>
</div>
<a class="anchor" id="ad3d731d6d65b0c6779f8bfa098743817"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; OtherType, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::cast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast to a different data type. </p>
<p>Returns a copy of the container converted to another data type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>Other data type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Copy. </dd></dl>

</div>
</div>
<a class="anchor" id="acb350662a8c17a5476b331d23917b084"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;class GenericType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; Type, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::change </td>
          <td>(</td>
          <td class="paramtype">const GenericType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>num</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change an element of the container. </p>
<p>Provides a single element assignment to modify the contents. This function is well suited for chaining assignment. This is equivalent to the <code><a class="el" href="classmagrathea_1_1StaticVectorizer.html#a68070ddd4235454ca5fae28888353a87" title="Put an element in the container.">put()</a></code> function but it operates on a copy and not on the container itself. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GenericType</td><td>(Value or vectorized type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>Source of the copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>Starting position of the copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>Number of elements to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Self reference. </dd></dl>

</div>
</div>
<a class="anchor" id="abc4fdc2ce798bc99edc1a874a90bbfe5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; Type, Parameters...&gt; &amp; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear contents. </p>
<p>Clear the whole contents and sets the size to zero. </p>
<dl class="section return"><dt>Returns</dt><dd>Self reference. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>The container cannot be resized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af9bfeab0127573058117a760e29d6fc6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename Result , class Function , class Arg , class... Args, typename Return &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; Return, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::combine </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, Arg, Parameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, Args, Parameters...&gt; &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combination by a function object. </p>
<p>Combines several vectorized containers using a function object. It is equivalent to a transversal reduction operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Result</td><td>Specified return type. </td></tr>
    <tr><td class="paramname">Function</td><td>(Function type : <code>Return(Return, Type)</code>.) </td></tr>
    <tr><td class="paramname">Arg</td><td>(First argument type.) </td></tr>
    <tr><td class="paramname">Args</td><td>(Other argument types.) </td></tr>
    <tr><td class="paramname">Return</td><td>Return type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Function object <code>Return(Return, Type)</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>First argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Other arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Copy. </dd></dl>

</div>
</div>
<a class="anchor" id="af31f97a4d517c0b50f6b00ec569bbdb1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename Return , class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; Return, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::combine </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unique combination by a function object. </p>
<p>Does nothing. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Return</td><td>Return type. </td></tr>
    <tr><td class="paramname">Function</td><td>(Function type : <code>Return(Return, Type)</code>.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a6fd144433ff6622ecc6de294e63ebdd9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::constant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get whether the container has a constant size. </p>
<p>Returns true if the container has a constant size, false otherwise. This function is required by the vectorization mechanism. </p>
<dl class="section return"><dt>Returns</dt><dd>Copy of true. </dd></dl>

</div>
</div>
<a class="anchor" id="a15c61ea6878c48725951cce33147cd22"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; Type, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy. </p>
<p>Returns a copy of the container. </p>
<dl class="section return"><dt>Returns</dt><dd>Copy. </dd></dl>

</div>
</div>
<a class="anchor" id="ad80642295ec9673ab0843eb453a9b972"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;class Reference , class Mask , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const Reference &amp;&#160;</td>
          <td class="paramname"><em>r</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mask &amp;&#160;</td>
          <td class="paramname"><em>bitmask</em> = <code>Mask()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count values. </p>
<p>Count the number of valid comparisons with the provided reference in the specified region. Note that before any comparison, the values in the container are casted to the reference data type. With no argument, this function counts the number of non-null values (true) in the container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Reference</td><td>(Reference type.) </td></tr>
    <tr><td class="paramname">Mask</td><td>(Mask type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>Reference for comparison : value or vectorized container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bitmask</td><td>Boolean mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Copy of the valid counts. </dd></dl>

</div>
</div>
<a class="anchor" id="a17209e21d93cf648d3428c79da6827b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;class Function , class Mask , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::count </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mask &amp;&#160;</td>
          <td class="paramname"><em>bitmask</em> = <code>Mask()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count with predicate. </p>
<p>Count the numbers of times the predicate is true in the specified region. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Function</td><td>(Function type : <code>bool(Type)</code>.) </td></tr>
    <tr><td class="paramname">Mask</td><td>(Mask type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Predicate <code>bool(Type)</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bitmask</td><td>Boolean mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Copy of the valid counts. </dd></dl>

</div>
</div>
<a class="anchor" id="a3cc47c0b28180723f001d6c2dce89a78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type &amp; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::cycle </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cyclic monodimensional access to the contents. </p>
<p>Provides a cyclic access to the contents, using the index modulo. Negative indexes are supported. It allows to iterate several times over the contents just by incrementing the provided index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Element index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the element. </dd></dl>

</div>
</div>
<a class="anchor" id="a42143d4ae441b0a39d6632a40c34dcbc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Type &amp; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::cycle </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Immutable cyclic monodimensional access to the contents. </p>
<p>Provides a cyclic access to the contents, using the index modulo. Negative indexes are supported. It allows to iterate several times over the contents just by incrementing the provided index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Element index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Immutable reference to the element. </dd></dl>

</div>
</div>
<a class="anchor" id="a2a7178a1eb856275555049c9ec5df656"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get whether the container is empty. </p>
<p>Returns the result of the comparison between the size and zero. </p>
<dl class="section return"><dt>Returns</dt><dd>Copy of the result of the test. </dd></dl>

</div>
</div>
<a class="anchor" id="a17daca1d726cd6249fcf435c8f36fe6b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;class GenericType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::eq </td>
          <td>(</td>
          <td class="paramtype">const GenericType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare for equality. </p>
<p>Returns true if all elements of the containers are equal, returns false otherwise. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GenericType</td><td>(Value or vectorized type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Copy of the result. </dd></dl>

</div>
</div>
<a class="anchor" id="af2e6bb70574c2b1bbec83b3769dcab8a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::example </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Example function. </p>
<p>Tests and demonstrates the use of <a class="el" href="classmagrathea_1_1StaticVectorizer.html" title="Helper class for generic constant size vectorization.">StaticVectorizer</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if no error. </dd></dl>

</div>
</div>
<a class="anchor" id="aff1b6067431758a205c3cb71c38f6011"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , class... Misc, class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; Type, Parameters...&gt; &amp; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; OtherType &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Misc &amp;...&#160;</td>
          <td class="paramname"><em>misc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializer list fill. </p>
<p>Fills the contents using the <code><a class="el" href="classmagrathea_1_1Vectorizer.html#a67836bbf5aced8fee531fd2caf839f15" title="Empty setter.">set()</a></code> function and without reinitializing the contents before any operation. This is equivalent to the <code><a class="el" href="classmagrathea_1_1StaticVectorizer.html#ae322d5931112d91c3f24529e6c1e1559" title="Initializer list replace.">replace()</a></code> function but it operates on the container itself and not on a copy. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
    <tr><td class="paramname">Misc</td><td>(<a class="el" href="classMiscellaneous.html">Miscellaneous</a> types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>Source of the copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">misc</td><td><a class="el" href="classMiscellaneous.html">Miscellaneous</a> arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Self reference. </dd></dl>

</div>
</div>
<a class="anchor" id="abc085a9ed9cf363095eb42adf323b533"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;class... Misc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; Type, Parameters...&gt; &amp; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">const Misc &amp;...&#160;</td>
          <td class="paramname"><em>misc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic fill. </p>
<p>Fills the contents using the <code><a class="el" href="classmagrathea_1_1Vectorizer.html#a67836bbf5aced8fee531fd2caf839f15" title="Empty setter.">set()</a></code> function and without reinitializing the contents before any operation. This is equivalent to the <code><a class="el" href="classmagrathea_1_1StaticVectorizer.html#ae322d5931112d91c3f24529e6c1e1559" title="Initializer list replace.">replace()</a></code> function but it operates on the container itself and not on a copy. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Misc</td><td>(<a class="el" href="classMiscellaneous.html">Miscellaneous</a> types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">misc</td><td><a class="el" href="classMiscellaneous.html">Miscellaneous</a> arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Self reference. </dd></dl>

</div>
</div>
<a class="anchor" id="a860d99a0104280c072d7b7dbf8d87c27"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type &amp; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::front </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Monodimensional access to the i-th element from the beginning. </p>
<p>Returns a reference to the i-th first element in the container without doing any range check. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Element index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the element. </dd></dl>

</div>
</div>
<a class="anchor" id="afedeae49461374b9a8cd0fe6615b75bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Type &amp; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::front </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Immutable monodimensional access to the i-th element from the beginning. </p>
<p>Returns a reference to the i-th first element in the container without doing any range check. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Element index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Immutable reference to the element. </dd></dl>

</div>
</div>
<a class="anchor" id="a5283a8f67f6b68c9bad13f6f25b76df7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; bool, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::mask </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>value</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default mask creation. </p>
<p>Creates a mask from a boolean value, which is true per default. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Boolean value used to create the mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a39a962b3baa77ee6fb4ab2a43f98c8f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;class Container , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; bool, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::mask </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Standard boolean container mask creation. </p>
<p>Creates a mask from a standard boolean container, which can be a <code>std::bitset</code> or a <code>std::vector&lt;bool&gt;</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>(Boolean container type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>Boolean container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a9650665d8e8027a898b46c16940bad2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , class... Misc, class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; bool, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::mask </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; OtherType &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Misc &amp;...&#160;</td>
          <td class="paramname"><em>misc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializer list mask creation. </p>
<p>Creates a mask from an initializer list by calling the associated constructor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
    <tr><td class="paramname">Misc</td><td>(<a class="el" href="classMiscellaneous.html">Miscellaneous</a> types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>Source of the copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">misc</td><td><a class="el" href="classMiscellaneous.html">Miscellaneous</a> arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a7c2b9766936bb0f20b743e23aeccf685"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;class... Misc, class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; bool, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::mask </td>
          <td>(</td>
          <td class="paramtype">const Misc &amp;...&#160;</td>
          <td class="paramname"><em>misc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic mask creation. </p>
<p>Creates a mask from generic arguments by calling the associated constructor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Misc</td><td>(<a class="el" href="classMiscellaneous.html">Miscellaneous</a> types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">misc</td><td><a class="el" href="classMiscellaneous.html">Miscellaneous</a> arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a9d815869f22555a895bfb1cb50bfe6da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;class Mask , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Type &amp; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::max </td>
          <td>(</td>
          <td class="paramtype">const Mask &amp;&#160;</td>
          <td class="paramname"><em>bitmask</em> = <code>Mask()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum element. </p>
<p>Returns a reference to the maximum element of the container or masked container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Mask</td><td>(Mask type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitmask</td><td>Boolean mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Immutable reference to the element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>Empty search. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4a0074acfae82d0eec6843eacae83f9b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;class Mask , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Type &amp; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::min </td>
          <td>(</td>
          <td class="paramtype">const Mask &amp;&#160;</td>
          <td class="paramname"><em>bitmask</em> = <code>Mask()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum element. </p>
<p>Returns a reference to the minimum element of the container or masked container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Mask</td><td>(Mask type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitmask</td><td>Boolean mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Immutable reference to the element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>Empty search. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3561a958f2f2e9335a75183752b06513"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename Return , class Function , class... Args, class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; Type, Parameters...&gt; &amp; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::modify </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modification by a function object. </p>
<p>Modifies the container by applying a function object to each element. For an element <code>x</code>, a function <code>f</code> and for extra arguments <code>args...</code>, an equivalent expression is : <code>x = f(x, args...)</code>. The return type is used as an internal cast before affectation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Return</td><td>Return type. </td></tr>
    <tr><td class="paramname">Function</td><td>(Function type : <code>Type(Type, Args...)</code>.) </td></tr>
    <tr><td class="paramname">Args</td><td>(Extra types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Function object <code>Type(Type, Args...)</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Extra arguments of the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Self reference. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The size of the extra arguments is not checked. </dd></dl>

</div>
</div>
<a class="anchor" id="ab491736cf47709fa98a58a2232662204"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename Return , class Mask , class Function, class... Args, class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; Type, Parameters...&gt; &amp; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::modify </td>
          <td>(</td>
          <td class="paramtype">const Mask &amp;&#160;</td>
          <td class="paramname"><em>bitmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Masked modification by a function object. </p>
<p>Modifies the container by applying a function object to each element where the mask is true. For an element <code>x</code>, a function <code>f</code> and for extra arguments <code>args... </code>, an equivalent expression is : <code>x = f(x, args...) </code>. The return type is used as an internal cast before affectation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Return</td><td>Return type. </td></tr>
    <tr><td class="paramname">Mask</td><td>(Mask type.) </td></tr>
    <tr><td class="paramname">Function</td><td>(Function type : <code>Type(Type, Args...)</code>.) </td></tr>
    <tr><td class="paramname">Args</td><td>(Extra types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitmask</td><td>Boolean mask. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Function object <code>Type(Type, Args...)</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Extra arguments of the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Self reference. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The size of the extra arguments is not checked. </dd></dl>

</div>
</div>
<a class="anchor" id="a88432eac2ca07cc75a2c3dd3c068ac0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;class GenericType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::ne </td>
          <td>(</td>
          <td class="paramtype">const GenericType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare for difference. </p>
<p>Returns true if at least one element is different in the two containers, returns false otherwise. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GenericType</td><td>(Value or vectorized type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Copy of the result. </dd></dl>

</div>
</div>
<a class="anchor" id="a69d72ba1d3a6d7cdaf384d0bad8eba11"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;class Reference , class Mask , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::none </td>
          <td>(</td>
          <td class="paramtype">const Reference &amp;&#160;</td>
          <td class="paramname"><em>r</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mask &amp;&#160;</td>
          <td class="paramname"><em>bitmask</em> = <code>Mask()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>No value equal. </p>
<p>Checks if the comparison with the provided reference returns true for no element in the specified region. Note that before any comparison, the values in the container are casted to the reference data type. With no argument, this function returns true if the whole contents is null (false). It returns true if the container is empty. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Reference</td><td>(Reference type.) </td></tr>
    <tr><td class="paramname">Mask</td><td>(Mask type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>Reference for comparison : value or vectorized container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bitmask</td><td>Boolean mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Copy of the boolean result. </dd></dl>

</div>
</div>
<a class="anchor" id="a8f67d8c8a6733e73b5f26b3c3345173c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;class Function , class Mask , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::none </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mask &amp;&#160;</td>
          <td class="paramname"><em>bitmask</em> = <code>Mask()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>No value satisfying the predicate. </p>
<p>Checks if the unary predicate returns true for no element in the specified region. It returns true if the container is empty. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Function</td><td>(Function type : <code>bool(Type)</code>.) </td></tr>
    <tr><td class="paramname">Mask</td><td>(Mask type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Predicate <code>bool(Type)</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bitmask</td><td>Boolean mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Copy of the boolean result. </dd></dl>

</div>
</div>
<a class="anchor" id="a584d26a12db2398aeb579281f0891397"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::null </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether all elements are null. </p>
<p>Returns true if all elements are set to their default value, returns false otherwise. </p>
<dl class="section return"><dt>Returns</dt><dd>Copy of the result of the test. </dd></dl>

</div>
</div>
<a class="anchor" id="aa2d036d08b09e0f8ec903c7c6442db2b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;class... Location&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; Type, Parameters...&gt; &amp; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::nullify </td>
          <td>(</td>
          <td class="paramtype">const Location &amp;...&#160;</td>
          <td class="paramname"><em>location</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set elements to their default values. </p>
<p>Sets the specified elements to their default value using the <code><a class="el" href="classmagrathea_1_1Vectorizer.html#a67836bbf5aced8fee531fd2caf839f15" title="Empty setter.">set()</a></code> function for the provided location. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Location</td><td>(Mask or position specifiers.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">location</td><td>Boolean mask or starting position and number of elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Self reference. </dd></dl>

</div>
</div>
<a class="anchor" id="a47cd06bd12e9a75244bb47949d2ac179"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; bool, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator! </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Logical NOT. </p>
<p>Applies the logical NOT operator to each element. </p>
<dl class="section return"><dt>Returns</dt><dd>Boolean copy. </dd></dl>

</div>
</div>
<a class="anchor" id="af92fdb0640566781b2be44d9e5a13a4f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; bool, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a47cd06bd12e9a75244bb47949d2ac179">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, OtherType, Parameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Not equal to. </p>
<p>Applies the not equal to operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a745d2383572c87adb83d08e23692aa81"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; bool, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a47cd06bd12e9a75244bb47949d2ac179">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Not equal to with rhs value. </p>
<p>Applies the not equal to operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean copy. </dd></dl>

</div>
</div>
<a class="anchor" id="add2236077d26b29ce7b03a3990d4f16e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; typename std::common_type&lt; Type, OtherType &gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, OtherType, Parameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modulo. </p>
<p>Applies the modulo operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Common type copy. </dd></dl>

</div>
</div>
<a class="anchor" id="abed2e71709a1266c0aa35ace9e60db9c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; typename std::common_type&lt; Type, OtherType &gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator% </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modulo with rhs value. </p>
<p>Applies the modulo operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Common type copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a47c9e3e893460b9955602af8e30ef60c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;class GenericType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; Type, Parameters...&gt; &amp; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator%= </td>
          <td>(</td>
          <td class="paramtype">const GenericType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modulo assignment. </p>
<p>Applies the modulo assignment operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GenericType</td><td>(Value or vectorized type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Self reference </dd></dl>

</div>
</div>
<a class="anchor" id="a8a87d64ccefc340329bbd5cc1ddb9717"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; typename std::common_type&lt; Type, OtherType &gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, OtherType, Parameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise AND. </p>
<p>Applies the bitwise AND operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Common type copy. </dd></dl>

</div>
</div>
<a class="anchor" id="add90cf869ac9dd08b986be67cfee5221"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; typename std::common_type&lt; Type, OtherType &gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise AND with rhs value. </p>
<p>Applies the bitwise AND operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Common type copy. </dd></dl>

</div>
</div>
<a class="anchor" id="aa0b7dd33a216a87e2d8cad3bd06aff45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; bool, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, OtherType, Parameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Logical AND. </p>
<p>Applies the logical AND operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a96cdf853407901fedc50265a84fa5991"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; bool, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Logical AND with rhs value. </p>
<p>Applies the logical AND operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean copy. </dd></dl>

</div>
</div>
<a class="anchor" id="ab4d6cd5651a735815e1af42ab3ea21a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;class GenericType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; Type, Parameters...&gt; &amp; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype">const GenericType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise AND assignment. </p>
<p>Applies the bitwise AND assignment operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GenericType</td><td>(Value or vectorized type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Self reference </dd></dl>

</div>
</div>
<a class="anchor" id="a59fb69180969b012a7ba11981fb9aaf5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters...&gt; &amp; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator() </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Abstract class access. </p>
<p>Casts to the abstract class. </p>
<dl class="section return"><dt>Returns</dt><dd>Self reference. </dd></dl>

</div>
</div>
<a class="anchor" id="a21f4f22f100057ebca8f881a6cea2fe0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters...&gt; &amp; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator() </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Immutable abstract class access. </p>
<p>Casts to the abstract class. </p>
<dl class="section return"><dt>Returns</dt><dd>Immutable self reference. </dd></dl>

</div>
</div>
<a class="anchor" id="a791203245d6c45ee22165b4a0bc11647"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type &amp; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Monodimensional access operator. </p>
<p>Provides a monodimensional access to the element. For a monodimensional array, it is equivalent to the <code>[]</code> operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Element index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the element. </dd></dl>

</div>
</div>
<a class="anchor" id="aeb3ee03be09afd4621c18d49918c8d0e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Type &amp; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Immutable monodimensional access operator. </p>
<p>Provides a monodimensional access to the element. For a monodimensional array, it is equivalent to the <code>[]</code> operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Element index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Immutable reference to the element. </dd></dl>

</div>
</div>
<a class="anchor" id="a915d0b7778501174f122a8497fb46387"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; typename std::common_type&lt; Type, OtherType &gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, OtherType, Parameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication. </p>
<p>Applies the multiplication operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Common type copy. </dd></dl>

</div>
</div>
<a class="anchor" id="ab2d4e3fb0273c6453f4c77654ed39bee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; typename std::common_type&lt; Type, OtherType &gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication with rhs value. </p>
<p>Applies the multiplication operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Common type copy. </dd></dl>

</div>
</div>
<a class="anchor" id="ae5ba80f798f95863f6e13d72d154b934"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;class GenericType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; Type, Parameters...&gt; &amp; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const GenericType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication assignment. </p>
<p>Applies the multiplication assignment operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GenericType</td><td>(Value or vectorized type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Self reference </dd></dl>

</div>
</div>
<a class="anchor" id="a567b025704b733cbd38dc5504102dfca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; typename std::common_type&lt; Type, OtherType &gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, OtherType, Parameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition. </p>
<p>Applies the addition operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Common type copy. </dd></dl>

</div>
</div>
<a class="anchor" id="aae18798ce202c372877ffad6dd05a6ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; typename std::common_type&lt; Type, OtherType &gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition with rhs value. </p>
<p>Applies the addition operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Common type copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a77d653a93df0b5f7f112651044604109"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; Type, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator+ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integer promotion. </p>
<p>Applies the integer promotion operator to each element. </p>
<dl class="section return"><dt>Returns</dt><dd>Copy. </dd></dl>

</div>
</div>
<a class="anchor" id="acc5094efe1b21c12c05543b2ee05f9ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; Type, Parameters...&gt; &amp; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment prefix. </p>
<p>Applies the increment prefix operator to each element. </p>
<dl class="section return"><dt>Returns</dt><dd>Self reference. </dd></dl>

</div>
</div>
<a class="anchor" id="a0db772662fda98f47909ed9c5ae6f61e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; Type, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment suffix. </p>
<p>Applies the increment suffix operator to each element. </p>
<dl class="section return"><dt>Returns</dt><dd>Copy. </dd></dl>

</div>
</div>
<a class="anchor" id="adeebb70a5bf1d4fe1e3c86fbd0830e1a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;class GenericType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; Type, Parameters...&gt; &amp; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const GenericType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment. </p>
<p>Applies the addition assignment operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GenericType</td><td>(Value or vectorized type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Self reference </dd></dl>

</div>
</div>
<a class="anchor" id="a9323dd009e06bac4ff6c426217a11443"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; typename std::common_type&lt; Type, OtherType &gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, OtherType, Parameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substraction. </p>
<p>Applies the substraction operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Common type copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a294a71924f6f57b8e03edcbfb12c0c54"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; typename std::common_type&lt; Type, OtherType &gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substraction with rhs value. </p>
<p>Applies the substraction operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Common type copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a112a6fff4321f8e4ebe7184d4215e17a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; Type, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Additive inverse. </p>
<p>Applies the additive inverse operator to each element. </p>
<dl class="section return"><dt>Returns</dt><dd>Copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a3430773a46c0300aaadb38b2ce8e26af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; Type, Parameters...&gt; &amp; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator-- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrement prefix. </p>
<p>Applies the decrement prefix operator to each element. </p>
<dl class="section return"><dt>Returns</dt><dd>Self reference. </dd></dl>

</div>
</div>
<a class="anchor" id="acb5f5aec44c70c502f6f95c9ef2ac8ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; Type, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator-- </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrement suffix. </p>
<p>Applies the decrement suffix operator to each element. </p>
<dl class="section return"><dt>Returns</dt><dd>Copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a1eb336da47554c90ce21eb1bba271630"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;class GenericType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; Type, Parameters...&gt; &amp; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const GenericType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substraction assignment. </p>
<p>Applies the substraction assignment operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GenericType</td><td>(Value or vectorized type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Self reference </dd></dl>

</div>
</div>
<a class="anchor" id="a37c01771117232fb2ba44a73682f7d2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; typename std::common_type&lt; Type, OtherType &gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, OtherType, Parameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division. </p>
<p>Applies the division operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Common type copy. </dd></dl>

</div>
</div>
<a class="anchor" id="abb4d2416e7104066405671d4d6d62337"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; typename std::common_type&lt; Type, OtherType &gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator/ </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division with rhs value. </p>
<p>Applies the division operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Common type copy. </dd></dl>

</div>
</div>
<a class="anchor" id="ac0d79a23a4ef654dd107c1682a5fa8d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;class GenericType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; Type, Parameters...&gt; &amp; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const GenericType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division assignment. </p>
<p>Applies the division assignment operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GenericType</td><td>(Value or vectorized type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Self reference </dd></dl>

</div>
</div>
<a class="anchor" id="a80928ac25f678a002f96c2770ae0459a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; bool, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, OtherType, Parameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less than. </p>
<p>Applies the less than operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean copy. </dd></dl>

</div>
</div>
<a class="anchor" id="ae8fc4ac75f3f4c8c9de4083cd07cacb0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; bool, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less than with rhs value. </p>
<p>Applies the less than operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ca67dc868dd70423e659b77209e07d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; Type, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, OtherType, Parameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise left shift. </p>
<p>Applies the bitwise left shift operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a5629b7a221887ce68ed18b1da00ad5d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; Type, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise left shift with rhs value. </p>
<p>Applies the bitwise left shift operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a22eee562fea2e47fceb1a28f045d684a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;class GenericType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; Type, Parameters...&gt; &amp; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator&lt;&lt;= </td>
          <td>(</td>
          <td class="paramtype">const GenericType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise left shift assignment. </p>
<p>Applies the bitwise left shift assignment operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GenericType</td><td>(Value or vectorized type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Self reference </dd></dl>

</div>
</div>
<a class="anchor" id="a76839b1c705d389cfacfc9ae8d1b8887"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; bool, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, OtherType, Parameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less than or equal to. </p>
<p>Applies the less than or equal to operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a4c967db7cc9d968dfc7eeb8fc4570f59"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; bool, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less than or equal to with rhs value. </p>
<p>Applies the less than or equal to operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a53c433b861ee583956eeed639868cda0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type, Kind... Parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; Type, Parameters...&gt; &amp; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<p>Copies the contents of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Self reference. </dd></dl>

</div>
</div>
<a class="anchor" id="aa0f365bb136ebe481ebadbc939379300"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; Type, Parameters...&gt; &amp; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; OtherType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializer list assignment operator. </p>
<p>Provides an initializer list assignment. The assignment is delegated to the <code><a class="el" href="classmagrathea_1_1Vectorizer.html#a67836bbf5aced8fee531fd2caf839f15" title="Empty setter.">set()</a></code> helper function thanks to the following call : <code>set(*this, rhs)</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Self reference. </dd></dl>

</div>
</div>
<a class="anchor" id="a7f80b1a26224671bcc94082b329703d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;class Misc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; Type, Parameters...&gt; &amp; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const Misc &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<p>Provides a generic assignment. The assignment is delegated to the <code><a class="el" href="classmagrathea_1_1Vectorizer.html#a67836bbf5aced8fee531fd2caf839f15" title="Empty setter.">set()</a></code> helper function. Conversion assignment, value assignment and assignment are provided through this function thanks to the following call : <code>set(*this, misc...)</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Misc</td><td>(<a class="el" href="classMiscellaneous.html">Miscellaneous</a> type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Self reference. </dd></dl>

</div>
</div>
<a class="anchor" id="a5bad4a3e6f2206c1fc71f3f3b26b841b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; bool, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, OtherType, Parameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equal to. </p>
<p>Applies the equal to operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean copy. </dd></dl>

</div>
</div>
<a class="anchor" id="ae8a3d25716fb6f3056a194db4611398b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; bool, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equal to with rhs value. </p>
<p>Applies the equal to operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a2c0b5791efa69c1397ef8af918148ad8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; bool, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, OtherType, Parameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater than. </p>
<p>Applies the greater than operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a45845efb29eba8ac0742080cb0ca161e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; bool, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater than with rhs value. </p>
<p>Applies the greater than operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a192cbe3a1821bbff180dfe1422a0ecae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; bool, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, OtherType, Parameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater than or equal to. </p>
<p>Applies the greater than or equal to operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a8e18e9b3d7412d5d824eb7c03e01ab62"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; bool, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater than or equal to with rhs value. </p>
<p>Applies the greater than or equal to operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a6893af67ac504eeb471690a5114a1365"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; Type, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, OtherType, Parameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise right shift. </p>
<p>Applies the bitwise right shift operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a3738d5814db16597b32bdf601685c832"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; Type, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise right shift with rhs value. </p>
<p>Applies the bitwise right shift operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Copy. </dd></dl>

</div>
</div>
<a class="anchor" id="af997b81383cd6fda10a5c816ab5fa066"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;class GenericType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; Type, Parameters...&gt; &amp; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator&gt;&gt;= </td>
          <td>(</td>
          <td class="paramtype">const GenericType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise right shift assignment. </p>
<p>Applies the bitwise right shift assignment operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GenericType</td><td>(Value or vectorized type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Self reference </dd></dl>

</div>
</div>
<a class="anchor" id="a4b5d5e63c27e77f1d734f80d7ca3d2df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type &amp; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Direct access to the element. </p>
<p>Provides a direct access to the specified element. This function is required by the vectorization mechanism. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Index of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the element. </dd></dl>

</div>
</div>
<a class="anchor" id="adf04553a28c73c6a6d04f2d29c8cdfeb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Type &amp; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Immutable direct access to the element. </p>
<p>Provides a constant direct access to the specified element. This function is required by the vectorization mechanism. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Index of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Immutable reference to the element. </dd></dl>

</div>
</div>
<a class="anchor" id="a0943fd4f6155fcd6410ffaddee1a30c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; typename std::common_type&lt; Type, OtherType &gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator^ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, OtherType, Parameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise XOR. </p>
<p>Applies the bitwise XOR operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Common type copy. </dd></dl>

</div>
</div>
<a class="anchor" id="ab39f76f560714379beb563a6406713ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; typename std::common_type&lt; Type, OtherType &gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator^ </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise XOR with rhs value. </p>
<p>Applies the bitwise XOR operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Common type copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a38a45a8f2b81d90168197a26dac6fb0f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;class GenericType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; Type, Parameters...&gt; &amp; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator^= </td>
          <td>(</td>
          <td class="paramtype">const GenericType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise XOR assignment. </p>
<p>Applies the bitwise XOR assignment operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GenericType</td><td>(Value or vectorized type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Self reference </dd></dl>

</div>
</div>
<a class="anchor" id="a9dfa7d06a43760b3550fa8e6319dee90"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; typename std::common_type&lt; Type, OtherType &gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, OtherType, Parameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise OR. </p>
<p>Applies the bitwise OR operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Common type copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a224cb7cb9b2cb80a7719cdee76349204"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; typename std::common_type&lt; Type, OtherType &gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator| </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise OR with rhs value. </p>
<p>Applies the bitwise OR operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Common type copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a19c8eb2274664155f9b714200544247b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;class GenericType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; Type, Parameters...&gt; &amp; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator|= </td>
          <td>(</td>
          <td class="paramtype">const GenericType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise OR assignment. </p>
<p>Applies the bitwise OR assignment operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GenericType</td><td>(Value or vectorized type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Self reference </dd></dl>

</div>
</div>
<a class="anchor" id="a69b7f2ba58c27a4562daa6243d50e67b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; bool, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator|| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, OtherType, Parameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Logical OR. </p>
<p>Applies the logical OR operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean copy. </dd></dl>

</div>
</div>
<a class="anchor" id="afed99ecd4a86f62923433c8f27a05d3f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; bool, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator|| </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Logical OR with rhs value. </p>
<p>Applies the logical OR operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a6aefc18480c79c379de8ddd9ebd0ac13"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; Type, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise NOT. </p>
<p>Applies the bitwise NOT operator to each element. </p>
<dl class="section return"><dt>Returns</dt><dd>Copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a92fa50efed3f2e5175472ece1aaf8ae5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::array&lt; Kind, sizeof...(Parameters)&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::parameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the template parameters. </p>
<p>Returns an array containing the template parameters. </p>
<dl class="section return"><dt>Returns</dt><dd>Copy of an array of parameters. </dd></dl>

</div>
</div>
<a class="anchor" id="a68070ddd4235454ca5fae28888353a87"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;class GenericType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; Type, Parameters...&gt; &amp; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::put </td>
          <td>(</td>
          <td class="paramtype">const GenericType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>num</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put an element in the container. </p>
<p>Provides a single element assignment to modify the contents. This function is well suited for chaining assignment. This is equivalent to the <code><a class="el" href="classmagrathea_1_1StaticVectorizer.html#acb350662a8c17a5476b331d23917b084" title="Change an element of the container.">change()</a></code> function but it operates on the container itself and not on a copy. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GenericType</td><td>(Value or vectorized type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>Source of the copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>Starting position of the copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>Number of elements to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Self reference. </dd></dl>

</div>
</div>
<a class="anchor" id="ae9b48485c0550dcdf495ef70b4c36c09"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename Return , class Function , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Return <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::reduce </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>Function()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Return &amp;&#160;</td>
          <td class="paramname"><em>init</em> = <code>Return()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduction by a function object. </p>
<p>Reduces the contents using a binary function object initialized to the <code>init</code> value. For each reduced element <code>x</code>, the equivalent expression is <code>result = f(result, x)</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Return</td><td>Return type. </td></tr>
    <tr><td class="paramname">Function</td><td>(Function type : <code>Return(Return, Type)</code>.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Function object <code>Return(Return, Type)</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">init</td><td>Initial value for the reduction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Copy of the result. </dd></dl>

</div>
</div>
<a class="anchor" id="ada52aff0e57fd3d7b464ed89f0a382dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename Return , class Mask , class Function , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Return <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::reduce </td>
          <td>(</td>
          <td class="paramtype">const Mask &amp;&#160;</td>
          <td class="paramname"><em>bitmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>Function()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Return &amp;&#160;</td>
          <td class="paramname"><em>init</em> = <code>Return()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduction by a function object. </p>
<p>Reduces the contents using a binary function object initialized to the <code>init</code> value where the mask is true. For each reduced element <code>x</code>, the equivalent expression is <code>result = f(result, x)</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Return</td><td>Return type. </td></tr>
    <tr><td class="paramname">Mask</td><td>(Mask type.) </td></tr>
    <tr><td class="paramname">Function</td><td>(Function type : <code>Return(Return, Type)</code>.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitmask</td><td>Boolean mask. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Function object <code>Return(Return, Type)</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">init</td><td>Initial value for the reduction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Copy of the result. </dd></dl>

</div>
</div>
<a class="anchor" id="ae322d5931112d91c3f24529e6c1e1559"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , class... Misc, class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; Type, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; OtherType &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Misc &amp;...&#160;</td>
          <td class="paramname"><em>misc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializer list replace. </p>
<p>Replaces the contents using the <code><a class="el" href="classmagrathea_1_1Vectorizer.html#a67836bbf5aced8fee531fd2caf839f15" title="Empty setter.">set()</a></code> function and without reinitializing the contents before any operation. This is equivalent to the <code><a class="el" href="classmagrathea_1_1StaticVectorizer.html#aff1b6067431758a205c3cb71c38f6011" title="Initializer list fill.">fill()</a></code> function but it operates on a copy and not on the container itself. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
    <tr><td class="paramname">Misc</td><td>(<a class="el" href="classMiscellaneous.html">Miscellaneous</a> types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>Source of the copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">misc</td><td><a class="el" href="classMiscellaneous.html">Miscellaneous</a> arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Self reference. </dd></dl>

</div>
</div>
<a class="anchor" id="a81bc8121599b9da4425a5d73eb65dec4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;class... Misc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; Type, Parameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">const Misc &amp;...&#160;</td>
          <td class="paramname"><em>misc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic replace. </p>
<p>Replaces the contents using the <code><a class="el" href="classmagrathea_1_1Vectorizer.html#a67836bbf5aced8fee531fd2caf839f15" title="Empty setter.">set()</a></code> function and without reinitializing the contents before any operation. This is equivalent to the <code><a class="el" href="classmagrathea_1_1StaticVectorizer.html#aff1b6067431758a205c3cb71c38f6011" title="Initializer list fill.">fill()</a></code> function but it operates on a copy and not on the container itself. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Misc</td><td>(<a class="el" href="classMiscellaneous.html">Miscellaneous</a> types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">misc</td><td><a class="el" href="classMiscellaneous.html">Miscellaneous</a> arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Self reference. </dd></dl>

</div>
</div>
<a class="anchor" id="ae15629a58700e638e2a4546742cf09f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; Type, Parameters...&gt; &amp; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserve new space for the container. </p>
<p>Reserves new space for the container in order to optimize future resize calls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>New size for reservation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Self reference. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>The container cannot be resized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a41dd9d48122248b8ee10d1ef372cd560"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; Type, Parameters...&gt; &amp; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize the container. </p>
<p>Resizes the container and returns a reference to it. This function is required by the vectorization mechanism. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>New size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Self reference. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>The container cannot be resized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6fe290c124a079e831805e7272cef4e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned int <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the container. </p>
<p>Returns the current number of elements. This function is required by the vectorization mechanism. </p>
<dl class="section return"><dt>Returns</dt><dd>Copy of the size. </dd></dl>

</div>
</div>
<a class="anchor" id="aa027feb6ed321fd9cd855e0cdb0207b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long int <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::space </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the maximum available space. </p>
<p>Returns the <code>max_size()</code> of a <code>std::vector</code> of the same type. </p>
<dl class="section return"><dt>Returns</dt><dd>Copy of the maximum size. </dd></dl>

</div>
</div>
<a class="anchor" id="a8bf8d5dc7fd3290eff136f1262342e8b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type, Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;class... Location&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Crtp&lt; Type, Parameters...&gt; &amp; <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Location &amp;...&#160;</td>
          <td class="paramname"><em>location</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap elements by copy. </p>
<p>Swaps the elements of the two containers by copy at the provided location and returns a reference to the left-hand side. The resulting operation is not optimal because it implies a temporary copy. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Location</td><td>(Mask or position specifiers.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">location</td><td>Boolean mask or starting position and number of elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Self reference. </dd></dl>

</div>
</div>
<a class="anchor" id="ab06780534568f370bf271ee8eedadccf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned int <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::tbytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the data type. </p>
<p>Returns the size of the element type in bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>Copy of the size of the data type. </dd></dl>

</div>
</div>
<a class="anchor" id="a28c393a3896a3e839008c35d56b10a54"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind , unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type , Kind... Parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type <a class="el" href="classmagrathea_1_1StaticVectorizer.html">magrathea::StaticVectorizer</a>&lt; Kind, Size, Crtp, Type, Parameters &gt;::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the data type. </p>
<p>Returns a copy of the default value of the data type. </p>
<dl class="section return"><dt>Returns</dt><dd>Copy of the default value of the data type. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a8bfc60393edce795fa5bd2b3bb339ef5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type, Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SelfCrtp&lt;bool, SelfParameters...&gt; <a class="el" href="classmagrathea_1_1StaticVectorizer.html#a47cd06bd12e9a75244bb47949d2ac179">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Not equal to with lhs value. </p>
<p>Applies the not equal to operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
    <tr><td class="paramname">SelfKind</td><td>(Kind of arguments.) </td></tr>
    <tr><td class="paramname">SelfSize</td><td>(Number of elements.) </td></tr>
    <tr><td class="paramname">SelfCrtp</td><td>(Derived CRTP class.) </td></tr>
    <tr><td class="paramname">SelfType</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">SelfParameters</td><td>(List of parameters.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean copy. </dd></dl>

</div>
</div>
<a class="anchor" id="aa5662ba4d3f881341cc797968af9fa41"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type, Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SelfCrtp&lt;typename std::common_type&lt;SelfType, OtherType&gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, SelfParameters...&gt; operator% </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modulo with lhs value. </p>
<p>Applies the modulo operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
    <tr><td class="paramname">SelfKind</td><td>(Kind of arguments.) </td></tr>
    <tr><td class="paramname">SelfSize</td><td>(Number of elements.) </td></tr>
    <tr><td class="paramname">SelfCrtp</td><td>(Derived CRTP class.) </td></tr>
    <tr><td class="paramname">SelfType</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">SelfParameters</td><td>(List of parameters.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Common type copy. </dd></dl>

</div>
</div>
<a class="anchor" id="afca1e5aa41c2048a2543030ce7456354"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type, Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SelfCrtp&lt;typename std::common_type&lt;SelfType, OtherType&gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, SelfParameters...&gt; operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise AND with lhs value. </p>
<p>Applies the bitwise AND operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
    <tr><td class="paramname">SelfKind</td><td>(Kind of arguments.) </td></tr>
    <tr><td class="paramname">SelfSize</td><td>(Number of elements.) </td></tr>
    <tr><td class="paramname">SelfCrtp</td><td>(Derived CRTP class.) </td></tr>
    <tr><td class="paramname">SelfType</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">SelfParameters</td><td>(List of parameters.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Common type copy. </dd></dl>

</div>
</div>
<a class="anchor" id="aae2fc75417259acf41fd1d84ffb5469b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type, Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SelfCrtp&lt;bool, SelfParameters...&gt; operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Logical AND with lhs value. </p>
<p>Applies the logical AND operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
    <tr><td class="paramname">SelfKind</td><td>(Kind of arguments.) </td></tr>
    <tr><td class="paramname">SelfSize</td><td>(Number of elements.) </td></tr>
    <tr><td class="paramname">SelfCrtp</td><td>(Derived CRTP class.) </td></tr>
    <tr><td class="paramname">SelfType</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">SelfParameters</td><td>(List of parameters.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a3569cddd30a871d7e2b3dde8e5edecc7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type, Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SelfCrtp&lt;typename std::common_type&lt;SelfType, OtherType&gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, SelfParameters...&gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication with lhs value. </p>
<p>Applies the multiplication operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
    <tr><td class="paramname">SelfKind</td><td>(Kind of arguments.) </td></tr>
    <tr><td class="paramname">SelfSize</td><td>(Number of elements.) </td></tr>
    <tr><td class="paramname">SelfCrtp</td><td>(Derived CRTP class.) </td></tr>
    <tr><td class="paramname">SelfType</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">SelfParameters</td><td>(List of parameters.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Common type copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a8b6774aab42c9363c5820c74ccc0a02e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type, Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SelfCrtp&lt;typename std::common_type&lt;SelfType, OtherType&gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, SelfParameters...&gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition with lhs value. </p>
<p>Applies the addition operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
    <tr><td class="paramname">SelfKind</td><td>(Kind of arguments.) </td></tr>
    <tr><td class="paramname">SelfSize</td><td>(Number of elements.) </td></tr>
    <tr><td class="paramname">SelfCrtp</td><td>(Derived CRTP class.) </td></tr>
    <tr><td class="paramname">SelfType</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">SelfParameters</td><td>(List of parameters.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Common type copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a7ca40e03311c4e8c24e77ce2532b68d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type, Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SelfCrtp&lt;typename std::common_type&lt;SelfType, OtherType&gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, SelfParameters...&gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substraction with lhs value. </p>
<p>Applies the substraction operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
    <tr><td class="paramname">SelfKind</td><td>(Kind of arguments.) </td></tr>
    <tr><td class="paramname">SelfSize</td><td>(Number of elements.) </td></tr>
    <tr><td class="paramname">SelfCrtp</td><td>(Derived CRTP class.) </td></tr>
    <tr><td class="paramname">SelfType</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">SelfParameters</td><td>(List of parameters.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Common type copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a5e6fb0e0d7f699355cbaf6698d0b66c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type, Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SelfCrtp&lt;typename std::common_type&lt;SelfType, OtherType&gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, SelfParameters...&gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division with lhs value. </p>
<p>Applies the division operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
    <tr><td class="paramname">SelfKind</td><td>(Kind of arguments.) </td></tr>
    <tr><td class="paramname">SelfSize</td><td>(Number of elements.) </td></tr>
    <tr><td class="paramname">SelfCrtp</td><td>(Derived CRTP class.) </td></tr>
    <tr><td class="paramname">SelfType</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">SelfParameters</td><td>(List of parameters.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Common type copy. </dd></dl>

</div>
</div>
<a class="anchor" id="af60adf27d2657f948be21910673c6304"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type, Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SelfCrtp&lt;bool, SelfParameters...&gt; operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less than with lhs value. </p>
<p>Applies the less than operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
    <tr><td class="paramname">SelfKind</td><td>(Kind of arguments.) </td></tr>
    <tr><td class="paramname">SelfSize</td><td>(Number of elements.) </td></tr>
    <tr><td class="paramname">SelfCrtp</td><td>(Derived CRTP class.) </td></tr>
    <tr><td class="paramname">SelfType</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">SelfParameters</td><td>(List of parameters.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a6962dd6aa68898e5b0656c7d1db54efd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type, Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SelfCrtp&lt;OtherType, SelfParameters...&gt; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise left shift with lhs value. </p>
<p>Applies the bitwise left shift operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
    <tr><td class="paramname">SelfKind</td><td>(Kind of arguments.) </td></tr>
    <tr><td class="paramname">SelfSize</td><td>(Number of elements.) </td></tr>
    <tr><td class="paramname">SelfCrtp</td><td>(Derived CRTP class.) </td></tr>
    <tr><td class="paramname">SelfType</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">SelfParameters</td><td>(List of parameters.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Copy. </dd></dl>

</div>
</div>
<a class="anchor" id="abe6a86f2659fddc66d572f8fb8f7d452"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type, Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream operator. </p>
<p>Adds each element to the stream using the <code><a class="el" href="classmagrathea_1_1StaticVectorizer.html#aff1b6067431758a205c3cb71c38f6011" title="Initializer list fill.">fill()</a></code> character as a separator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SelfKind</td><td>(Kind of arguments.) </td></tr>
    <tr><td class="paramname">SelfSize</td><td>(Number of elements.) </td></tr>
    <tr><td class="paramname">SelfCrtp</td><td>(Derived CRTP class.) </td></tr>
    <tr><td class="paramname">SelfType</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">SelfParameters</td><td>(List of parameters.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lhs</td><td>Left-hand side stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream. </dd></dl>

</div>
</div>
<a class="anchor" id="a56bd8400d219fc4e39c5973a1db97c71"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type, Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SelfCrtp&lt;bool, SelfParameters...&gt; operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less than or equal to with lhs value. </p>
<p>Applies the less than or equal to operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
    <tr><td class="paramname">SelfKind</td><td>(Kind of arguments.) </td></tr>
    <tr><td class="paramname">SelfSize</td><td>(Number of elements.) </td></tr>
    <tr><td class="paramname">SelfCrtp</td><td>(Derived CRTP class.) </td></tr>
    <tr><td class="paramname">SelfType</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">SelfParameters</td><td>(List of parameters.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean copy. </dd></dl>

</div>
</div>
<a class="anchor" id="ae434f3dcb55f00b2c92e63385f9e5b42"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type, Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SelfCrtp&lt;bool, SelfParameters...&gt; operator== </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equal to with lhs value. </p>
<p>Applies the equal to operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
    <tr><td class="paramname">SelfKind</td><td>(Kind of arguments.) </td></tr>
    <tr><td class="paramname">SelfSize</td><td>(Number of elements.) </td></tr>
    <tr><td class="paramname">SelfCrtp</td><td>(Derived CRTP class.) </td></tr>
    <tr><td class="paramname">SelfType</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">SelfParameters</td><td>(List of parameters.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a1004dafefb091d626f80081672cbab19"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type, Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SelfCrtp&lt;bool, SelfParameters...&gt; operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater than with lhs value. </p>
<p>Applies the greater than operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
    <tr><td class="paramname">SelfKind</td><td>(Kind of arguments.) </td></tr>
    <tr><td class="paramname">SelfSize</td><td>(Number of elements.) </td></tr>
    <tr><td class="paramname">SelfCrtp</td><td>(Derived CRTP class.) </td></tr>
    <tr><td class="paramname">SelfType</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">SelfParameters</td><td>(List of parameters.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a7eff4653f0b8a216af1547f5094980a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type, Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SelfCrtp&lt;bool, SelfParameters...&gt; operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater than or equal to with lhs value. </p>
<p>Applies the greater than or equal to operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
    <tr><td class="paramname">SelfKind</td><td>(Kind of arguments.) </td></tr>
    <tr><td class="paramname">SelfSize</td><td>(Number of elements.) </td></tr>
    <tr><td class="paramname">SelfCrtp</td><td>(Derived CRTP class.) </td></tr>
    <tr><td class="paramname">SelfType</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">SelfParameters</td><td>(List of parameters.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a4ea24bc9e8e6d2db161ea115bc587446"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type, Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SelfCrtp&lt;OtherType, SelfParameters...&gt; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise right shift with lhs value. </p>
<p>Applies the bitwise right shift operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
    <tr><td class="paramname">SelfKind</td><td>(Kind of arguments.) </td></tr>
    <tr><td class="paramname">SelfSize</td><td>(Number of elements.) </td></tr>
    <tr><td class="paramname">SelfCrtp</td><td>(Derived CRTP class.) </td></tr>
    <tr><td class="paramname">SelfType</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">SelfParameters</td><td>(List of parameters.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a6d8948c3cd04e4f435ed0b8a3f243e75"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type, Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="exceptionInput.html" title="Input utilities for raytracing.">Input</a> stream operator. </p>
<p>Fills each element from the stream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SelfKind</td><td>(Kind of arguments.) </td></tr>
    <tr><td class="paramname">SelfSize</td><td>(Number of elements.) </td></tr>
    <tr><td class="paramname">SelfCrtp</td><td>(Derived CRTP class.) </td></tr>
    <tr><td class="paramname">SelfType</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">SelfParameters</td><td>(List of parameters.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lhs</td><td>Left-hand side stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="exceptionInput.html" title="Input utilities for raytracing.">Input</a> stream. </dd></dl>

</div>
</div>
<a class="anchor" id="a00a22c5599a1abe3672de5342dd8bef0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type, Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SelfCrtp&lt;typename std::common_type&lt;SelfType, OtherType&gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, SelfParameters...&gt; operator^ </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise XOR with lhs value. </p>
<p>Applies the bitwise XOR operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
    <tr><td class="paramname">SelfKind</td><td>(Kind of arguments.) </td></tr>
    <tr><td class="paramname">SelfSize</td><td>(Number of elements.) </td></tr>
    <tr><td class="paramname">SelfCrtp</td><td>(Derived CRTP class.) </td></tr>
    <tr><td class="paramname">SelfType</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">SelfParameters</td><td>(List of parameters.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Common type copy. </dd></dl>

</div>
</div>
<a class="anchor" id="af8c589260c56e0aa83231d668b5b8bf8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type, Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SelfCrtp&lt;typename std::common_type&lt;SelfType, OtherType&gt;::<a class="el" href="classmagrathea_1_1StaticVectorizer.html#a28c393a3896a3e839008c35d56b10a54">type</a>, SelfParameters...&gt; operator| </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise OR with lhs value. </p>
<p>Applies the bitwise OR operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
    <tr><td class="paramname">SelfKind</td><td>(Kind of arguments.) </td></tr>
    <tr><td class="paramname">SelfSize</td><td>(Number of elements.) </td></tr>
    <tr><td class="paramname">SelfCrtp</td><td>(Derived CRTP class.) </td></tr>
    <tr><td class="paramname">SelfType</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">SelfParameters</td><td>(List of parameters.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Common type copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a324a2459dcb212c2e79f7bdccebe80d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kind, unsigned int Size, template&lt; typename, Kind...&gt; class Crtp, typename Type, Kind... Parameters&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SelfCrtp&lt;bool, SelfParameters...&gt; operator|| </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Logical OR with lhs value. </p>
<p>Applies the logical OR operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
    <tr><td class="paramname">SelfKind</td><td>(Kind of arguments.) </td></tr>
    <tr><td class="paramname">SelfSize</td><td>(Number of elements.) </td></tr>
    <tr><td class="paramname">SelfCrtp</td><td>(Derived CRTP class.) </td></tr>
    <tr><td class="paramname">SelfType</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">SelfParameters</td><td>(List of parameters.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean copy. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/data/home/mbreton/magrathea_pathfinder/src/magrathea/<a class="el" href="staticvectorizer_8h_source.html">staticvectorizer.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 6 2021 17:41:41 for MAGRATHEA/PATHFINDER by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
