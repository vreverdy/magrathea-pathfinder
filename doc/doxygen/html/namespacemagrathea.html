<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>MAGRATHEA/PATHFINDER: magrathea Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MAGRATHEA/PATHFINDER
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">magrathea Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">exception &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1AboutInstitute.html">AboutInstitute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about an institution or an organization.  <a href="exceptionmagrathea_1_1AboutInstitute.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">exception &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1AboutLicense.html">AboutLicense</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about the license of a code.  <a href="exceptionmagrathea_1_1AboutLicense.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">exception &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1AboutObject.html">AboutObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic about object with information on something.  <a href="exceptionmagrathea_1_1AboutObject.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">exception &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1AboutPeople.html">AboutPeople</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about a developer, an author, or a contributor.  <a href="exceptionmagrathea_1_1AboutPeople.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1AbstractAboutObject.html">AbstractAboutObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tuple abstraction of generic about object.  <a href="classmagrathea_1_1AbstractAboutObject.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1AbstractContents.html">AbstractContents</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tuple abstraction of numerical simulation contents.  <a href="classmagrathea_1_1AbstractContents.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1AbstractHyperCube.html">AbstractHyperCube</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract function provider for n-dimensional cubes.  <a href="classmagrathea_1_1AbstractHyperCube.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1AbstractHyperSphere.html">AbstractHyperSphere</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract function provider for n-dimensional spheres.  <a href="classmagrathea_1_1AbstractHyperSphere.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1AbstractNArray.html">AbstractNArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class of n-dimensional mathematical arrays.  <a href="classmagrathea_1_1AbstractNArray.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1AbstractShape.html">AbstractShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common abstraction of n-dimensional shapes.  <a href="classmagrathea_1_1AbstractShape.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1AbstractStep.html">AbstractStep</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstraction of an evolution step.  <a href="classmagrathea_1_1AbstractStep.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1AbstractSubstance.html">AbstractSubstance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tuple abstraction of geometrical substance.  <a href="classmagrathea_1_1AbstractSubstance.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">exception &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1Constant.html">Constant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numerical constant with constexpr constructor.  <a href="exceptionmagrathea_1_1Constant.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">exception &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1Constants.html">Constants</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common mathematical and physical constants.  <a href="exceptionmagrathea_1_1Constants.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">exception &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1Contents.html">Contents</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic implementation of numerical simulation contents.  <a href="exceptionmagrathea_1_1Contents.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">exception &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataHandler.html">DataHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of basic operations on binary data related to IO.  <a href="exceptionmagrathea_1_1DataHandler.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">exception &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataModel.html">DataModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Management of fundamental types representation.  <a href="exceptionmagrathea_1_1DataModel.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">exception &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1DataSize.html">DataSize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="exceptionmagrathea_1_1Wrapper.html" title="Basic value wrapper with getter and setter.">Wrapper</a> of binary data size and manager of unit conversion.  <a href="exceptionmagrathea_1_1DataSize.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">exception &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1EulerianCategory.html">EulerianCategory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Category concept of eulerian : data at a fixed position.  <a href="exceptionmagrathea_1_1EulerianCategory.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">exception &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1Evolution.html">Evolution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizable container of steps dedicated to integration.  <a href="exceptionmagrathea_1_1Evolution.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">exception &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1FileList.html">FileList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of files based on a function or a vector.  <a href="exceptionmagrathea_1_1FileList.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">exception &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1FileSystem.html">FileSystem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global file management.  <a href="exceptionmagrathea_1_1FileSystem.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">exception &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1GridCategory.html">GridCategory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Category concept of grid : data related to the mesh.  <a href="exceptionmagrathea_1_1GridCategory.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">exception &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1HyperCube.html">HyperCube</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">N-dimensional cube.  <a href="exceptionmagrathea_1_1HyperCube.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">exception &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1HyperSphere.html">HyperSphere</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">N-dimensional sphere.  <a href="exceptionmagrathea_1_1HyperSphere.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">exception &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1LagrangianCategory.html">LagrangianCategory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Category concept of lagrangian : data moving with the flow.  <a href="exceptionmagrathea_1_1LagrangianCategory.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">exception &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1NArray.html">NArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic n-dimensional mathematical array.  <a href="exceptionmagrathea_1_1NArray.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">exception &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1Shape.html">Shape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic implementation of shape.  <a href="exceptionmagrathea_1_1Shape.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">exception &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1SimpleHyperOctree.html">SimpleHyperOctree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple hyperoctree based on bit manipulations.  <a href="exceptionmagrathea_1_1SimpleHyperOctree.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">exception &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1SimpleHyperOctreeIndex.html">SimpleHyperOctreeIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple hyperoctree index based on an integer.  <a href="exceptionmagrathea_1_1SimpleHyperOctreeIndex.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">exception &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1StaticVector.html">StaticVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic vectorized constant size container.  <a href="exceptionmagrathea_1_1StaticVector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for generic constant size vectorization.  <a href="classmagrathea_1_1StaticVectorizer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">exception &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1Step.html">Step</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic implementation of an evolution step.  <a href="exceptionmagrathea_1_1Step.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">exception &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1Substance.html">Substance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic implementation of geometrical substance.  <a href="exceptionmagrathea_1_1Substance.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">exception &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1Timer.html">Timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A timer to manage time measurements and benchmarks.  <a href="exceptionmagrathea_1_1Timer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">exception &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1Vectorized.html">Vectorized</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic vectorized container.  <a href="exceptionmagrathea_1_1Vectorized.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmagrathea_1_1Vectorizer.html">Vectorizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper base class for generic vectorization.  <a href="classmagrathea_1_1Vectorizer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">exception &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionmagrathea_1_1Wrapper.html">Wrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic value wrapper with getter and setter.  <a href="exceptionmagrathea_1_1Wrapper.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2ab2e7c5105b8d9de8fba009b17f7fa7"><td class="memTemplParams" colspan="2">template&lt;class SelfCrtp , class... SelfTypes&gt; </td></tr>
<tr class="memitem:a2ab2e7c5105b8d9de8fba009b17f7fa7"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemagrathea.html#a2ab2e7c5105b8d9de8fba009b17f7fa7">operator&lt;&lt;</a> (std::ostream &amp;lhs, const <a class="el" href="classmagrathea_1_1AbstractAboutObject.html">AbstractAboutObject</a>&lt; SelfCrtp, SelfTypes...&gt; &amp;rhs)</td></tr>
<tr class="memdesc:a2ab2e7c5105b8d9de8fba009b17f7fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream operator.  <a href="#a2ab2e7c5105b8d9de8fba009b17f7fa7"></a><br/></td></tr>
<tr class="separator:a2ab2e7c5105b8d9de8fba009b17f7fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8035a6dc27a898c793469300734394c7"><td class="memTemplParams" colspan="2">template&lt;class SelfCrtp , class SelfCategory , class... SelfTypes&gt; </td></tr>
<tr class="memitem:a8035a6dc27a898c793469300734394c7"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemagrathea.html#a8035a6dc27a898c793469300734394c7">operator&lt;&lt;</a> (std::ostream &amp;lhs, const <a class="el" href="classmagrathea_1_1AbstractContents.html">AbstractContents</a>&lt; SelfCrtp, SelfCategory, SelfTypes...&gt; &amp;rhs)</td></tr>
<tr class="memdesc:a8035a6dc27a898c793469300734394c7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream operator.  <a href="#a8035a6dc27a898c793469300734394c7"></a><br/></td></tr>
<tr class="separator:a8035a6dc27a898c793469300734394c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9249ef80a0176ab456b2129ed6b0f715"><td class="memTemplParams" colspan="2">template&lt;class SelfCrtp , class SelfScalar , class SelfArray , class SelfTuple &gt; </td></tr>
<tr class="memitem:a9249ef80a0176ab456b2129ed6b0f715"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemagrathea.html#a9249ef80a0176ab456b2129ed6b0f715">operator&lt;&lt;</a> (std::ostream &amp;lhs, const <a class="el" href="classmagrathea_1_1AbstractStep.html">AbstractStep</a>&lt; SelfCrtp, SelfScalar, SelfArray, SelfTuple &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a9249ef80a0176ab456b2129ed6b0f715"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream operator.  <a href="#a9249ef80a0176ab456b2129ed6b0f715"></a><br/></td></tr>
<tr class="separator:a9249ef80a0176ab456b2129ed6b0f715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c5460d574f739b0b0af990e0e390a5f"><td class="memTemplParams" colspan="2">template&lt;class SelfCrtp , class... SelfTypes&gt; </td></tr>
<tr class="memitem:a6c5460d574f739b0b0af990e0e390a5f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemagrathea.html#a6c5460d574f739b0b0af990e0e390a5f">operator&lt;&lt;</a> (std::ostream &amp;lhs, const <a class="el" href="classmagrathea_1_1AbstractSubstance.html">AbstractSubstance</a>&lt; SelfCrtp, SelfTypes...&gt; &amp;rhs)</td></tr>
<tr class="memdesc:a6c5460d574f739b0b0af990e0e390a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream operator.  <a href="#a6c5460d574f739b0b0af990e0e390a5f"></a><br/></td></tr>
<tr class="separator:a6c5460d574f739b0b0af990e0e390a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f44f282dd621e72f37ef2284bab7c8"><td class="memTemplParams" colspan="2">template&lt;typename SelfType , unsigned int SelfSize&gt; </td></tr>
<tr class="memitem:ad8f44f282dd621e72f37ef2284bab7c8"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemagrathea.html#ad8f44f282dd621e72f37ef2284bab7c8">operator&lt;&lt;</a> (std::ostream &amp;lhs, const <a class="el" href="exceptionmagrathea_1_1Constant.html">Constant</a>&lt; SelfType, SelfSize &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ad8f44f282dd621e72f37ef2284bab7c8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream operator.  <a href="#ad8f44f282dd621e72f37ef2284bab7c8"></a><br/></td></tr>
<tr class="separator:ad8f44f282dd621e72f37ef2284bab7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7589507913b63d5bf438e636ea48d3b8"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemagrathea.html#a7589507913b63d5bf438e636ea48d3b8">operator&lt;&lt;</a> (std::ostream &amp;lhs, const <a class="el" href="exceptionmagrathea_1_1DataModel.html">DataModel</a> &amp;rhs)</td></tr>
<tr class="memdesc:a7589507913b63d5bf438e636ea48d3b8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream operator.  <a href="#a7589507913b63d5bf438e636ea48d3b8"></a><br/></td></tr>
<tr class="separator:a7589507913b63d5bf438e636ea48d3b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb66b9e9208594fe09e39845df8c0f73"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemagrathea.html#afb66b9e9208594fe09e39845df8c0f73">operator&lt;&lt;</a> (std::ostream &amp;lhs, const <a class="el" href="exceptionmagrathea_1_1DataSize.html">DataSize</a> &amp;rhs)</td></tr>
<tr class="memdesc:afb66b9e9208594fe09e39845df8c0f73"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream operator.  <a href="#afb66b9e9208594fe09e39845df8c0f73"></a><br/></td></tr>
<tr class="separator:afb66b9e9208594fe09e39845df8c0f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0290637ad3695043958a42c80bd79519"><td class="memTemplParams" colspan="2">template&lt;class SelfType , class SelfContainer &gt; </td></tr>
<tr class="memitem:a0290637ad3695043958a42c80bd79519"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemagrathea.html#a0290637ad3695043958a42c80bd79519">operator&lt;&lt;</a> (std::ostream &amp;lhs, const <a class="el" href="exceptionmagrathea_1_1Evolution.html">Evolution</a>&lt; SelfType, SelfContainer &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a0290637ad3695043958a42c80bd79519"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream operator.  <a href="#a0290637ad3695043958a42c80bd79519"></a><br/></td></tr>
<tr class="separator:a0290637ad3695043958a42c80bd79519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679190b0b2facf29e17c19f9b2133f96"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemagrathea.html#a679190b0b2facf29e17c19f9b2133f96">operator&lt;&lt;</a> (std::ostream &amp;lhs, const <a class="el" href="exceptionmagrathea_1_1FileList.html">FileList</a> &amp;rhs)</td></tr>
<tr class="memdesc:a679190b0b2facf29e17c19f9b2133f96"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream operator.  <a href="#a679190b0b2facf29e17c19f9b2133f96"></a><br/></td></tr>
<tr class="separator:a679190b0b2facf29e17c19f9b2133f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c4fa7b8129853d9400181732330c75"><td class="memTemplParams" colspan="2">template&lt;typename SelfType , unsigned int SelfDimension, unsigned int SelfBits&gt; </td></tr>
<tr class="memitem:a13c4fa7b8129853d9400181732330c75"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemagrathea.html#a13c4fa7b8129853d9400181732330c75">operator&lt;&lt;</a> (std::ostream &amp;lhs, const <a class="el" href="exceptionmagrathea_1_1SimpleHyperOctreeIndex.html">SimpleHyperOctreeIndex</a>&lt; SelfType, SelfDimension, SelfBits &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a13c4fa7b8129853d9400181732330c75"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream operator.  <a href="#a13c4fa7b8129853d9400181732330c75"></a><br/></td></tr>
<tr class="separator:a13c4fa7b8129853d9400181732330c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953954bed141f42a1bcd833198395f41"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, SelfType&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:a953954bed141f42a1bcd833198395f41"><td class="memTemplItemLeft" align="right" valign="top">SelfCrtp&lt; typename <br class="typebreak"/>
std::common_type&lt; SelfType, <br class="typebreak"/>
OtherType &gt;::type, <br class="typebreak"/>
SelfParameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemagrathea.html#a953954bed141f42a1bcd833198395f41">operator+</a> (const OtherType &amp;lhs, const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;rhs)</td></tr>
<tr class="memdesc:a953954bed141f42a1bcd833198395f41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition with lhs value.  <a href="#a953954bed141f42a1bcd833198395f41"></a><br/></td></tr>
<tr class="separator:a953954bed141f42a1bcd833198395f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a366b62738a6fa7747b6144b1b3702"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, SelfType&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:a56a366b62738a6fa7747b6144b1b3702"><td class="memTemplItemLeft" align="right" valign="top">SelfCrtp&lt; typename <br class="typebreak"/>
std::common_type&lt; SelfType, <br class="typebreak"/>
OtherType &gt;::type, <br class="typebreak"/>
SelfParameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemagrathea.html#a56a366b62738a6fa7747b6144b1b3702">operator-</a> (const OtherType &amp;lhs, const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;rhs)</td></tr>
<tr class="memdesc:a56a366b62738a6fa7747b6144b1b3702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substraction with lhs value.  <a href="#a56a366b62738a6fa7747b6144b1b3702"></a><br/></td></tr>
<tr class="separator:a56a366b62738a6fa7747b6144b1b3702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ac48b0d4f57eff39cd9e0053b98a47"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, SelfType&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:ab6ac48b0d4f57eff39cd9e0053b98a47"><td class="memTemplItemLeft" align="right" valign="top">SelfCrtp&lt; typename <br class="typebreak"/>
std::common_type&lt; SelfType, <br class="typebreak"/>
OtherType &gt;::type, <br class="typebreak"/>
SelfParameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemagrathea.html#ab6ac48b0d4f57eff39cd9e0053b98a47">operator*</a> (const OtherType &amp;lhs, const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;rhs)</td></tr>
<tr class="memdesc:ab6ac48b0d4f57eff39cd9e0053b98a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication with lhs value.  <a href="#ab6ac48b0d4f57eff39cd9e0053b98a47"></a><br/></td></tr>
<tr class="separator:ab6ac48b0d4f57eff39cd9e0053b98a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4a187c4aa140e2690c28b2e00575cc"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, SelfType&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:ade4a187c4aa140e2690c28b2e00575cc"><td class="memTemplItemLeft" align="right" valign="top">SelfCrtp&lt; typename <br class="typebreak"/>
std::common_type&lt; SelfType, <br class="typebreak"/>
OtherType &gt;::type, <br class="typebreak"/>
SelfParameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemagrathea.html#ade4a187c4aa140e2690c28b2e00575cc">operator/</a> (const OtherType &amp;lhs, const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;rhs)</td></tr>
<tr class="memdesc:ade4a187c4aa140e2690c28b2e00575cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division with lhs value.  <a href="#ade4a187c4aa140e2690c28b2e00575cc"></a><br/></td></tr>
<tr class="separator:ade4a187c4aa140e2690c28b2e00575cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa101299f75a0597451ac95a02f5031e1"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, SelfType&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:aa101299f75a0597451ac95a02f5031e1"><td class="memTemplItemLeft" align="right" valign="top">SelfCrtp&lt; typename <br class="typebreak"/>
std::common_type&lt; SelfType, <br class="typebreak"/>
OtherType &gt;::type, <br class="typebreak"/>
SelfParameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemagrathea.html#aa101299f75a0597451ac95a02f5031e1">operator%</a> (const OtherType &amp;lhs, const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;rhs)</td></tr>
<tr class="memdesc:aa101299f75a0597451ac95a02f5031e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modulo with lhs value.  <a href="#aa101299f75a0597451ac95a02f5031e1"></a><br/></td></tr>
<tr class="separator:aa101299f75a0597451ac95a02f5031e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd24aa869c1cae4d82bea7d72e79381"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, SelfType&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:a4fd24aa869c1cae4d82bea7d72e79381"><td class="memTemplItemLeft" align="right" valign="top">SelfCrtp&lt; typename <br class="typebreak"/>
std::common_type&lt; SelfType, <br class="typebreak"/>
OtherType &gt;::type, <br class="typebreak"/>
SelfParameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemagrathea.html#a4fd24aa869c1cae4d82bea7d72e79381">operator&amp;</a> (const OtherType &amp;lhs, const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;rhs)</td></tr>
<tr class="memdesc:a4fd24aa869c1cae4d82bea7d72e79381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise AND with lhs value.  <a href="#a4fd24aa869c1cae4d82bea7d72e79381"></a><br/></td></tr>
<tr class="separator:a4fd24aa869c1cae4d82bea7d72e79381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a509316d7acef6deb88f2ec89bdcc9d70"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, SelfType&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:a509316d7acef6deb88f2ec89bdcc9d70"><td class="memTemplItemLeft" align="right" valign="top">SelfCrtp&lt; typename <br class="typebreak"/>
std::common_type&lt; SelfType, <br class="typebreak"/>
OtherType &gt;::type, <br class="typebreak"/>
SelfParameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemagrathea.html#a509316d7acef6deb88f2ec89bdcc9d70">operator|</a> (const OtherType &amp;lhs, const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;rhs)</td></tr>
<tr class="memdesc:a509316d7acef6deb88f2ec89bdcc9d70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise OR with lhs value.  <a href="#a509316d7acef6deb88f2ec89bdcc9d70"></a><br/></td></tr>
<tr class="separator:a509316d7acef6deb88f2ec89bdcc9d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722f2644135e162e6775db15c084bf00"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, SelfType&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:a722f2644135e162e6775db15c084bf00"><td class="memTemplItemLeft" align="right" valign="top">SelfCrtp&lt; typename <br class="typebreak"/>
std::common_type&lt; SelfType, <br class="typebreak"/>
OtherType &gt;::type, <br class="typebreak"/>
SelfParameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemagrathea.html#a722f2644135e162e6775db15c084bf00">operator^</a> (const OtherType &amp;lhs, const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;rhs)</td></tr>
<tr class="memdesc:a722f2644135e162e6775db15c084bf00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise XOR with lhs value.  <a href="#a722f2644135e162e6775db15c084bf00"></a><br/></td></tr>
<tr class="separator:a722f2644135e162e6775db15c084bf00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe50847f844046c38c7530a7ae7ff7a8"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, SelfType&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:afe50847f844046c38c7530a7ae7ff7a8"><td class="memTemplItemLeft" align="right" valign="top">SelfCrtp&lt; OtherType, <br class="typebreak"/>
SelfParameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemagrathea.html#afe50847f844046c38c7530a7ae7ff7a8">operator&lt;&lt;</a> (const OtherType &amp;lhs, const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;rhs)</td></tr>
<tr class="memdesc:afe50847f844046c38c7530a7ae7ff7a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise left shift with lhs value.  <a href="#afe50847f844046c38c7530a7ae7ff7a8"></a><br/></td></tr>
<tr class="separator:afe50847f844046c38c7530a7ae7ff7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055bad44e7477b054c6756cfff0d7918"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, SelfType&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:a055bad44e7477b054c6756cfff0d7918"><td class="memTemplItemLeft" align="right" valign="top">SelfCrtp&lt; OtherType, <br class="typebreak"/>
SelfParameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemagrathea.html#a055bad44e7477b054c6756cfff0d7918">operator&gt;&gt;</a> (const OtherType &amp;lhs, const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;rhs)</td></tr>
<tr class="memdesc:a055bad44e7477b054c6756cfff0d7918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise right shift with lhs value.  <a href="#a055bad44e7477b054c6756cfff0d7918"></a><br/></td></tr>
<tr class="separator:a055bad44e7477b054c6756cfff0d7918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9461803b62888f1cee4f5391c2c3d01f"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, SelfType&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:a9461803b62888f1cee4f5391c2c3d01f"><td class="memTemplItemLeft" align="right" valign="top">SelfCrtp&lt; bool, SelfParameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemagrathea.html#a9461803b62888f1cee4f5391c2c3d01f">operator&amp;&amp;</a> (const OtherType &amp;lhs, const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;rhs)</td></tr>
<tr class="memdesc:a9461803b62888f1cee4f5391c2c3d01f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical AND with lhs value.  <a href="#a9461803b62888f1cee4f5391c2c3d01f"></a><br/></td></tr>
<tr class="separator:a9461803b62888f1cee4f5391c2c3d01f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a374ca607affe84170a9ce05bcb5c0bee"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, SelfType&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:a374ca607affe84170a9ce05bcb5c0bee"><td class="memTemplItemLeft" align="right" valign="top">SelfCrtp&lt; bool, SelfParameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemagrathea.html#a374ca607affe84170a9ce05bcb5c0bee">operator||</a> (const OtherType &amp;lhs, const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;rhs)</td></tr>
<tr class="memdesc:a374ca607affe84170a9ce05bcb5c0bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical OR with lhs value.  <a href="#a374ca607affe84170a9ce05bcb5c0bee"></a><br/></td></tr>
<tr class="separator:a374ca607affe84170a9ce05bcb5c0bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ce4ee32f8e91922a525e7cd21c0670"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, SelfType&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:a60ce4ee32f8e91922a525e7cd21c0670"><td class="memTemplItemLeft" align="right" valign="top">SelfCrtp&lt; bool, SelfParameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemagrathea.html#a60ce4ee32f8e91922a525e7cd21c0670">operator==</a> (const OtherType &amp;lhs, const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;rhs)</td></tr>
<tr class="memdesc:a60ce4ee32f8e91922a525e7cd21c0670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equal to with lhs value.  <a href="#a60ce4ee32f8e91922a525e7cd21c0670"></a><br/></td></tr>
<tr class="separator:a60ce4ee32f8e91922a525e7cd21c0670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42bbc042bee09e9a3e95f80e412029ca"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, SelfType&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:a42bbc042bee09e9a3e95f80e412029ca"><td class="memTemplItemLeft" align="right" valign="top">SelfCrtp&lt; bool, SelfParameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemagrathea.html#a42bbc042bee09e9a3e95f80e412029ca">operator!=</a> (const OtherType &amp;lhs, const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;rhs)</td></tr>
<tr class="memdesc:a42bbc042bee09e9a3e95f80e412029ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not equal to with lhs value.  <a href="#a42bbc042bee09e9a3e95f80e412029ca"></a><br/></td></tr>
<tr class="separator:a42bbc042bee09e9a3e95f80e412029ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359833aecc50754be7c7b221283a2138"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, SelfType&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:a359833aecc50754be7c7b221283a2138"><td class="memTemplItemLeft" align="right" valign="top">SelfCrtp&lt; bool, SelfParameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemagrathea.html#a359833aecc50754be7c7b221283a2138">operator&gt;</a> (const OtherType &amp;lhs, const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;rhs)</td></tr>
<tr class="memdesc:a359833aecc50754be7c7b221283a2138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than with lhs value.  <a href="#a359833aecc50754be7c7b221283a2138"></a><br/></td></tr>
<tr class="separator:a359833aecc50754be7c7b221283a2138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb6a548d2625b43ca0a0eda0a1fc6dd"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, SelfType&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:aedb6a548d2625b43ca0a0eda0a1fc6dd"><td class="memTemplItemLeft" align="right" valign="top">SelfCrtp&lt; bool, SelfParameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemagrathea.html#aedb6a548d2625b43ca0a0eda0a1fc6dd">operator&lt;</a> (const OtherType &amp;lhs, const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;rhs)</td></tr>
<tr class="memdesc:aedb6a548d2625b43ca0a0eda0a1fc6dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than with lhs value.  <a href="#aedb6a548d2625b43ca0a0eda0a1fc6dd"></a><br/></td></tr>
<tr class="separator:aedb6a548d2625b43ca0a0eda0a1fc6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc88a73a3d47bd5bce68ae97e4c12607"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, SelfType&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:afc88a73a3d47bd5bce68ae97e4c12607"><td class="memTemplItemLeft" align="right" valign="top">SelfCrtp&lt; bool, SelfParameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemagrathea.html#afc88a73a3d47bd5bce68ae97e4c12607">operator&gt;=</a> (const OtherType &amp;lhs, const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;rhs)</td></tr>
<tr class="memdesc:afc88a73a3d47bd5bce68ae97e4c12607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than or equal to with lhs value.  <a href="#afc88a73a3d47bd5bce68ae97e4c12607"></a><br/></td></tr>
<tr class="separator:afc88a73a3d47bd5bce68ae97e4c12607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15482f99cfecbb2bb4fde496fb28b436"><td class="memTemplParams" colspan="2">template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, SelfType&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:a15482f99cfecbb2bb4fde496fb28b436"><td class="memTemplItemLeft" align="right" valign="top">SelfCrtp&lt; bool, SelfParameters...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemagrathea.html#a15482f99cfecbb2bb4fde496fb28b436">operator&lt;=</a> (const OtherType &amp;lhs, const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;rhs)</td></tr>
<tr class="memdesc:a15482f99cfecbb2bb4fde496fb28b436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than or equal to with lhs value.  <a href="#a15482f99cfecbb2bb4fde496fb28b436"></a><br/></td></tr>
<tr class="separator:a15482f99cfecbb2bb4fde496fb28b436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7963bfb5650026fb34b911f986aa8cc"><td class="memTemplParams" colspan="2">template&lt;typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters&gt; </td></tr>
<tr class="memitem:ac7963bfb5650026fb34b911f986aa8cc"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemagrathea.html#ac7963bfb5650026fb34b911f986aa8cc">operator&lt;&lt;</a> (std::ostream &amp;lhs, const <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;rhs)</td></tr>
<tr class="memdesc:ac7963bfb5650026fb34b911f986aa8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream operator.  <a href="#ac7963bfb5650026fb34b911f986aa8cc"></a><br/></td></tr>
<tr class="separator:ac7963bfb5650026fb34b911f986aa8cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3f911d40a31500423871397fb4f8d7"><td class="memTemplParams" colspan="2">template&lt;typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters&gt; </td></tr>
<tr class="memitem:aac3f911d40a31500423871397fb4f8d7"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemagrathea.html#aac3f911d40a31500423871397fb4f8d7">operator&gt;&gt;</a> (std::istream &amp;lhs, <a class="el" href="classmagrathea_1_1StaticVectorizer.html">StaticVectorizer</a>&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;rhs)</td></tr>
<tr class="memdesc:aac3f911d40a31500423871397fb4f8d7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="exceptionInput.html" title="Input utilities for raytracing.">Input</a> stream operator.  <a href="#aac3f911d40a31500423871397fb4f8d7"></a><br/></td></tr>
<tr class="separator:aac3f911d40a31500423871397fb4f8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a7bc77fcc95cd8f09daf739ade2e42"><td class="memTemplParams" colspan="2">template&lt;typename SelfType , class SelfPeriod , class SelfClock &gt; </td></tr>
<tr class="memitem:a03a7bc77fcc95cd8f09daf739ade2e42"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemagrathea.html#a03a7bc77fcc95cd8f09daf739ade2e42">operator&lt;&lt;</a> (std::ostream &amp;lhs, const <a class="el" href="exceptionmagrathea_1_1Timer.html">Timer</a>&lt; SelfType, SelfPeriod, SelfClock &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a03a7bc77fcc95cd8f09daf739ade2e42"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream operator.  <a href="#a03a7bc77fcc95cd8f09daf739ade2e42"></a><br/></td></tr>
<tr class="separator:a03a7bc77fcc95cd8f09daf739ade2e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83721b57d33887543111d35a80d1783f"><td class="memTemplParams" colspan="2">template&lt;typename SelfType , unsigned int SelfSize&gt; </td></tr>
<tr class="memitem:a83721b57d33887543111d35a80d1783f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemagrathea.html#a83721b57d33887543111d35a80d1783f">operator&lt;&lt;</a> (std::ostream &amp;lhs, const <a class="el" href="exceptionmagrathea_1_1Vectorized.html">Vectorized</a>&lt; SelfType, SelfSize &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a83721b57d33887543111d35a80d1783f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream operator.  <a href="#a83721b57d33887543111d35a80d1783f"></a><br/></td></tr>
<tr class="separator:a83721b57d33887543111d35a80d1783f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Locate immutable element from position.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Locates the most refined cell at the provided position and returns an immutable iterator to it. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>(Iterator type.) </td></tr>
    <tr><td class="paramname">Types</td><td>(Scalar position types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iposs</td><td>Real positions along each dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Immutable iterator to the element found at the specified position. </dd></dl>
</div></td></tr>
<tr class="memitem:a12a69d1a8bde8372169732229b6bd7c9"><td class="memTemplParams" colspan="2">template&lt;typename SelfType , class SelfIndex , class SelfData , unsigned int SelfDimension, class SelfPosition , class SelfExtent , class SelfElement , class SelfContainer &gt; </td></tr>
<tr class="memitem:a12a69d1a8bde8372169732229b6bd7c9"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemagrathea.html#a12a69d1a8bde8372169732229b6bd7c9">operator&lt;&lt;</a> (std::ostream &amp;lhs, const <a class="el" href="exceptionmagrathea_1_1SimpleHyperOctree.html">SimpleHyperOctree</a>&lt; SelfType, SelfIndex, SelfData, SelfDimension, SelfPosition, SelfExtent, SelfElement, SelfContainer &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a12a69d1a8bde8372169732229b6bd7c9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream operator.  <a href="#a12a69d1a8bde8372169732229b6bd7c9"></a><br/></td></tr>
<tr class="separator:a12a69d1a8bde8372169732229b6bd7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a42bbc042bee09e9a3e95f80e412029ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, SelfType&gt;::value)&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SelfCrtp&lt;bool, SelfParameters...&gt; magrathea::operator!= </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StaticVectorizer&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Not equal to with lhs value. </p>
<p>Applies the not equal to operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
    <tr><td class="paramname">SelfKind</td><td>(Kind of arguments.) </td></tr>
    <tr><td class="paramname">SelfSize</td><td>(Number of elements.) </td></tr>
    <tr><td class="paramname">SelfCrtp</td><td>(Derived CRTP class.) </td></tr>
    <tr><td class="paramname">SelfType</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">SelfParameters</td><td>(List of parameters.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean copy. </dd></dl>

</div>
</div>
<a class="anchor" id="aa101299f75a0597451ac95a02f5031e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, SelfType&gt;::value)&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SelfCrtp&lt;typename std::common_type&lt;SelfType, OtherType&gt;::type, SelfParameters...&gt; magrathea::operator% </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StaticVectorizer&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modulo with lhs value. </p>
<p>Applies the modulo operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
    <tr><td class="paramname">SelfKind</td><td>(Kind of arguments.) </td></tr>
    <tr><td class="paramname">SelfSize</td><td>(Number of elements.) </td></tr>
    <tr><td class="paramname">SelfCrtp</td><td>(Derived CRTP class.) </td></tr>
    <tr><td class="paramname">SelfType</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">SelfParameters</td><td>(List of parameters.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Common type copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a4fd24aa869c1cae4d82bea7d72e79381"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, SelfType&gt;::value)&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SelfCrtp&lt;typename std::common_type&lt;SelfType, OtherType&gt;::type, SelfParameters...&gt; magrathea::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StaticVectorizer&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise AND with lhs value. </p>
<p>Applies the bitwise AND operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
    <tr><td class="paramname">SelfKind</td><td>(Kind of arguments.) </td></tr>
    <tr><td class="paramname">SelfSize</td><td>(Number of elements.) </td></tr>
    <tr><td class="paramname">SelfCrtp</td><td>(Derived CRTP class.) </td></tr>
    <tr><td class="paramname">SelfType</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">SelfParameters</td><td>(List of parameters.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Common type copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a9461803b62888f1cee4f5391c2c3d01f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, SelfType&gt;::value)&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SelfCrtp&lt;bool, SelfParameters...&gt; magrathea::operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StaticVectorizer&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Logical AND with lhs value. </p>
<p>Applies the logical AND operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
    <tr><td class="paramname">SelfKind</td><td>(Kind of arguments.) </td></tr>
    <tr><td class="paramname">SelfSize</td><td>(Number of elements.) </td></tr>
    <tr><td class="paramname">SelfCrtp</td><td>(Derived CRTP class.) </td></tr>
    <tr><td class="paramname">SelfType</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">SelfParameters</td><td>(List of parameters.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean copy. </dd></dl>

</div>
</div>
<a class="anchor" id="ab6ac48b0d4f57eff39cd9e0053b98a47"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, SelfType&gt;::value)&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SelfCrtp&lt;typename std::common_type&lt;SelfType, OtherType&gt;::type, SelfParameters...&gt; magrathea::operator* </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StaticVectorizer&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication with lhs value. </p>
<p>Applies the multiplication operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
    <tr><td class="paramname">SelfKind</td><td>(Kind of arguments.) </td></tr>
    <tr><td class="paramname">SelfSize</td><td>(Number of elements.) </td></tr>
    <tr><td class="paramname">SelfCrtp</td><td>(Derived CRTP class.) </td></tr>
    <tr><td class="paramname">SelfType</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">SelfParameters</td><td>(List of parameters.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Common type copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a953954bed141f42a1bcd833198395f41"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, SelfType&gt;::value)&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SelfCrtp&lt;typename std::common_type&lt;SelfType, OtherType&gt;::type, SelfParameters...&gt; magrathea::operator+ </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StaticVectorizer&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition with lhs value. </p>
<p>Applies the addition operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
    <tr><td class="paramname">SelfKind</td><td>(Kind of arguments.) </td></tr>
    <tr><td class="paramname">SelfSize</td><td>(Number of elements.) </td></tr>
    <tr><td class="paramname">SelfCrtp</td><td>(Derived CRTP class.) </td></tr>
    <tr><td class="paramname">SelfType</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">SelfParameters</td><td>(List of parameters.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Common type copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a56a366b62738a6fa7747b6144b1b3702"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, SelfType&gt;::value)&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SelfCrtp&lt;typename std::common_type&lt;SelfType, OtherType&gt;::type, SelfParameters...&gt; magrathea::operator- </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StaticVectorizer&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substraction with lhs value. </p>
<p>Applies the substraction operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
    <tr><td class="paramname">SelfKind</td><td>(Kind of arguments.) </td></tr>
    <tr><td class="paramname">SelfSize</td><td>(Number of elements.) </td></tr>
    <tr><td class="paramname">SelfCrtp</td><td>(Derived CRTP class.) </td></tr>
    <tr><td class="paramname">SelfType</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">SelfParameters</td><td>(List of parameters.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Common type copy. </dd></dl>

</div>
</div>
<a class="anchor" id="ade4a187c4aa140e2690c28b2e00575cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, SelfType&gt;::value)&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SelfCrtp&lt;typename std::common_type&lt;SelfType, OtherType&gt;::type, SelfParameters...&gt; magrathea::operator/ </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StaticVectorizer&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division with lhs value. </p>
<p>Applies the division operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
    <tr><td class="paramname">SelfKind</td><td>(Kind of arguments.) </td></tr>
    <tr><td class="paramname">SelfSize</td><td>(Number of elements.) </td></tr>
    <tr><td class="paramname">SelfCrtp</td><td>(Derived CRTP class.) </td></tr>
    <tr><td class="paramname">SelfType</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">SelfParameters</td><td>(List of parameters.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Common type copy. </dd></dl>

</div>
</div>
<a class="anchor" id="aedb6a548d2625b43ca0a0eda0a1fc6dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, SelfType&gt;::value)&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SelfCrtp&lt;bool, SelfParameters...&gt; magrathea::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StaticVectorizer&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less than with lhs value. </p>
<p>Applies the less than operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
    <tr><td class="paramname">SelfKind</td><td>(Kind of arguments.) </td></tr>
    <tr><td class="paramname">SelfSize</td><td>(Number of elements.) </td></tr>
    <tr><td class="paramname">SelfCrtp</td><td>(Derived CRTP class.) </td></tr>
    <tr><td class="paramname">SelfType</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">SelfParameters</td><td>(List of parameters.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a83721b57d33887543111d35a80d1783f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SelfType , unsigned int SelfSize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; magrathea::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vectorized&lt; SelfType, SelfSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream operator. </p>
<p>Adds each element to the stream using the fill character to separate the elements. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SelfType</td><td>Data type. </td></tr>
    <tr><td class="paramname">SelfSize</td><td>Number of elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lhs</td><td>Left-hand side stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream. </dd></dl>

</div>
</div>
<a class="anchor" id="a03a7bc77fcc95cd8f09daf739ade2e42"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SelfType , class SelfPeriod , class SelfClock &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; magrathea::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Timer&lt; SelfType, SelfPeriod, SelfClock &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream operator. </p>
<p>Prints out the total duration. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SelfType</td><td>(Duration representation type.) </td></tr>
    <tr><td class="paramname">SelfPeriod</td><td>(Standard ratio representing the tick period.) </td></tr>
    <tr><td class="paramname">SelfClock</td><td>(Internal clock type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lhs</td><td>Left-hand side stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side timer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream. </dd></dl>

</div>
</div>
<a class="anchor" id="a7589507913b63d5bf438e636ea48d3b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; magrathea::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataModel &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream operator. </p>
<p>Prints out the data model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lhs</td><td>Left-hand side stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side data model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream. </dd></dl>

</div>
</div>
<a class="anchor" id="a6c5460d574f739b0b0af990e0e390a5f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SelfCrtp , class... SelfTypes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; magrathea::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AbstractSubstance&lt; SelfCrtp, SelfTypes...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream operator. </p>
<p>Adds each element to the stream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SelfCrtp</td><td>(Derived CRTP class.) </td></tr>
    <tr><td class="paramname">SelfTypes</td><td>(Variadic list of components types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lhs</td><td>Left-hand side stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream. </dd></dl>

</div>
</div>
<a class="anchor" id="a2ab2e7c5105b8d9de8fba009b17f7fa7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SelfCrtp , class... SelfTypes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; magrathea::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AbstractAboutObject&lt; SelfCrtp, SelfTypes...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream operator. </p>
<p>Adds each element to the stream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SelfCrtp</td><td>(Derived CRTP class.) </td></tr>
    <tr><td class="paramname">SelfTypes</td><td>(Variadic list of components types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lhs</td><td>Left-hand side stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream. </dd></dl>

</div>
</div>
<a class="anchor" id="a8035a6dc27a898c793469300734394c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SelfCrtp , class SelfCategory , class... SelfTypes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; magrathea::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AbstractContents&lt; SelfCrtp, SelfCategory, SelfTypes...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream operator. </p>
<p>Adds each element to the stream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SelfCrtp</td><td>(Derived CRTP class.) </td></tr>
    <tr><td class="paramname">SelfCategory</td><td>(<a class="el" href="exceptionmagrathea_1_1Contents.html" title="Basic implementation of numerical simulation contents.">Contents</a> category (Lagrangian, Eulerian, Grid...).) </td></tr>
    <tr><td class="paramname">SelfTypes</td><td>(Variadic list of components types.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lhs</td><td>Left-hand side stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream. </dd></dl>

</div>
</div>
<a class="anchor" id="afb66b9e9208594fe09e39845df8c0f73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; magrathea::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataSize &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream operator. </p>
<p>Prints out the data size in the most convenient binary unit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lhs</td><td>Left-hand side stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side data size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream. </dd></dl>

</div>
</div>
<a class="anchor" id="a0290637ad3695043958a42c80bd79519"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SelfType , class SelfContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; magrathea::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Evolution&lt; SelfType, SelfContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream operator. </p>
<p>Adds each element to the stream using the <code>fill()</code> character as a separator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SelfType</td><td>(<a class="el" href="exceptionmagrathea_1_1Step.html" title="Basic implementation of an evolution step.">Step</a> type.) </td></tr>
    <tr><td class="paramname">SelfContainer</td><td>(Container type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lhs</td><td>Left-hand side stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream. </dd></dl>

</div>
</div>
<a class="anchor" id="a13c4fa7b8129853d9400181732330c75"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SelfType , unsigned int SelfDimension, unsigned int SelfBits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; magrathea::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SimpleHyperOctreeIndex&lt; SelfType, SelfDimension, SelfBits &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream operator. </p>
<p>Displays the bits of the index. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SelfType</td><td>(Unsigned integer type.) </td></tr>
    <tr><td class="paramname">SelfDimension</td><td>(Number of dimensions.) </td></tr>
    <tr><td class="paramname">SelfBits</td><td>(Size of the type in bits.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lhs</td><td>Left-hand side stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream. </dd></dl>

</div>
</div>
<a class="anchor" id="ad8f44f282dd621e72f37ef2284bab7c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SelfType , unsigned int SelfSize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; magrathea::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Constant&lt; SelfType, SelfSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream operator. </p>
<p>Adds each element to the stream using the <code>fill()</code> character as a separator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SelfType</td><td>(Numerical type of the constant.) </td></tr>
    <tr><td class="paramname">SelfSize</td><td>(Size of the set of constants.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lhs</td><td>Left-hand side stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side constant. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream. </dd></dl>

</div>
</div>
<a class="anchor" id="a679190b0b2facf29e17c19f9b2133f96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; magrathea::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FileList &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream operator. </p>
<p>Adds each file name to the stream using the filling character as a separator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lhs</td><td>Left-hand side stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side file list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream. </dd></dl>

</div>
</div>
<a class="anchor" id="afe50847f844046c38c7530a7ae7ff7a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, SelfType&gt;::value)&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SelfCrtp&lt;OtherType, SelfParameters...&gt; magrathea::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StaticVectorizer&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise left shift with lhs value. </p>
<p>Applies the bitwise left shift operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
    <tr><td class="paramname">SelfKind</td><td>(Kind of arguments.) </td></tr>
    <tr><td class="paramname">SelfSize</td><td>(Number of elements.) </td></tr>
    <tr><td class="paramname">SelfCrtp</td><td>(Derived CRTP class.) </td></tr>
    <tr><td class="paramname">SelfType</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">SelfParameters</td><td>(List of parameters.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a12a69d1a8bde8372169732229b6bd7c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SelfType , class SelfIndex , class SelfData , unsigned int SelfDimension, class SelfPosition , class SelfExtent , class SelfElement , class SelfContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; magrathea::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SimpleHyperOctree&lt; SelfType, SelfIndex, SelfData, SelfDimension, SelfPosition, SelfExtent, SelfElement, SelfContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream operator. </p>
<p>Displays the whole structure of the octree. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SelfType</td><td>(Scalar position type.) </td></tr>
    <tr><td class="paramname">SelfIndex</td><td>(Index type.) </td></tr>
    <tr><td class="paramname">SelfData</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">SelfDimension</td><td>(Number of dimensions.) </td></tr>
    <tr><td class="paramname">SelfPosition</td><td>(Position of the hyperoctree center.) </td></tr>
    <tr><td class="paramname">SelfExtent</td><td>(Extent of the hyperoctree.) </td></tr>
    <tr><td class="paramname">SelfElement</td><td>(Underlying element type.) </td></tr>
    <tr><td class="paramname">SelfContainer</td><td>(Underlying container type.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lhs</td><td>Left-hand side stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream. </dd></dl>

</div>
</div>
<a class="anchor" id="a9249ef80a0176ab456b2129ed6b0f715"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SelfCrtp , class SelfScalar , class SelfArray , class SelfTuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; magrathea::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AbstractStep&lt; SelfCrtp, SelfScalar, SelfArray, SelfTuple &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream operator. </p>
<p>Adds each element to the stream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SelfCrtp</td><td>(Derived CRTP class.) </td></tr>
    <tr><td class="paramname">SelfScalar</td><td>(Scalar type of id.) </td></tr>
    <tr><td class="paramname">SelfArray</td><td>(Array type of core quantities.) </td></tr>
    <tr><td class="paramname">SelfTuple</td><td>(Tuple type of extra quantities.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lhs</td><td>Left-hand side stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream. </dd></dl>

</div>
</div>
<a class="anchor" id="ac7963bfb5650026fb34b911f986aa8cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; magrathea::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StaticVectorizer&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream operator. </p>
<p>Adds each element to the stream using the <code>fill()</code> character as a separator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SelfKind</td><td>(Kind of arguments.) </td></tr>
    <tr><td class="paramname">SelfSize</td><td>(Number of elements.) </td></tr>
    <tr><td class="paramname">SelfCrtp</td><td>(Derived CRTP class.) </td></tr>
    <tr><td class="paramname">SelfType</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">SelfParameters</td><td>(List of parameters.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lhs</td><td>Left-hand side stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="exceptionOutput.html" title="Output utilities for raytracing.">Output</a> stream. </dd></dl>

</div>
</div>
<a class="anchor" id="a15482f99cfecbb2bb4fde496fb28b436"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, SelfType&gt;::value)&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SelfCrtp&lt;bool, SelfParameters...&gt; magrathea::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StaticVectorizer&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less than or equal to with lhs value. </p>
<p>Applies the less than or equal to operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
    <tr><td class="paramname">SelfKind</td><td>(Kind of arguments.) </td></tr>
    <tr><td class="paramname">SelfSize</td><td>(Number of elements.) </td></tr>
    <tr><td class="paramname">SelfCrtp</td><td>(Derived CRTP class.) </td></tr>
    <tr><td class="paramname">SelfType</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">SelfParameters</td><td>(List of parameters.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a60ce4ee32f8e91922a525e7cd21c0670"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, SelfType&gt;::value)&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SelfCrtp&lt;bool, SelfParameters...&gt; magrathea::operator== </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StaticVectorizer&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equal to with lhs value. </p>
<p>Applies the equal to operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
    <tr><td class="paramname">SelfKind</td><td>(Kind of arguments.) </td></tr>
    <tr><td class="paramname">SelfSize</td><td>(Number of elements.) </td></tr>
    <tr><td class="paramname">SelfCrtp</td><td>(Derived CRTP class.) </td></tr>
    <tr><td class="paramname">SelfType</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">SelfParameters</td><td>(List of parameters.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a359833aecc50754be7c7b221283a2138"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, SelfType&gt;::value)&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SelfCrtp&lt;bool, SelfParameters...&gt; magrathea::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StaticVectorizer&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater than with lhs value. </p>
<p>Applies the greater than operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
    <tr><td class="paramname">SelfKind</td><td>(Kind of arguments.) </td></tr>
    <tr><td class="paramname">SelfSize</td><td>(Number of elements.) </td></tr>
    <tr><td class="paramname">SelfCrtp</td><td>(Derived CRTP class.) </td></tr>
    <tr><td class="paramname">SelfType</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">SelfParameters</td><td>(List of parameters.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean copy. </dd></dl>

</div>
</div>
<a class="anchor" id="afc88a73a3d47bd5bce68ae97e4c12607"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, SelfType&gt;::value)&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SelfCrtp&lt;bool, SelfParameters...&gt; magrathea::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StaticVectorizer&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater than or equal to with lhs value. </p>
<p>Applies the greater than or equal to operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
    <tr><td class="paramname">SelfKind</td><td>(Kind of arguments.) </td></tr>
    <tr><td class="paramname">SelfSize</td><td>(Number of elements.) </td></tr>
    <tr><td class="paramname">SelfCrtp</td><td>(Derived CRTP class.) </td></tr>
    <tr><td class="paramname">SelfType</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">SelfParameters</td><td>(List of parameters.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a055bad44e7477b054c6756cfff0d7918"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, SelfType&gt;::value)&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SelfCrtp&lt;OtherType, SelfParameters...&gt; magrathea::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StaticVectorizer&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise right shift with lhs value. </p>
<p>Applies the bitwise right shift operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
    <tr><td class="paramname">SelfKind</td><td>(Kind of arguments.) </td></tr>
    <tr><td class="paramname">SelfSize</td><td>(Number of elements.) </td></tr>
    <tr><td class="paramname">SelfCrtp</td><td>(Derived CRTP class.) </td></tr>
    <tr><td class="paramname">SelfType</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">SelfParameters</td><td>(List of parameters.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Copy. </dd></dl>

</div>
</div>
<a class="anchor" id="aac3f911d40a31500423871397fb4f8d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; magrathea::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StaticVectorizer&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="exceptionInput.html" title="Input utilities for raytracing.">Input</a> stream operator. </p>
<p>Fills each element from the stream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SelfKind</td><td>(Kind of arguments.) </td></tr>
    <tr><td class="paramname">SelfSize</td><td>(Number of elements.) </td></tr>
    <tr><td class="paramname">SelfCrtp</td><td>(Derived CRTP class.) </td></tr>
    <tr><td class="paramname">SelfType</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">SelfParameters</td><td>(List of parameters.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lhs</td><td>Left-hand side stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="exceptionInput.html" title="Input utilities for raytracing.">Input</a> stream. </dd></dl>

</div>
</div>
<a class="anchor" id="a722f2644135e162e6775db15c084bf00"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, SelfType&gt;::value)&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SelfCrtp&lt;typename std::common_type&lt;SelfType, OtherType&gt;::type, SelfParameters...&gt; magrathea::operator^ </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StaticVectorizer&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise XOR with lhs value. </p>
<p>Applies the bitwise XOR operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
    <tr><td class="paramname">SelfKind</td><td>(Kind of arguments.) </td></tr>
    <tr><td class="paramname">SelfSize</td><td>(Number of elements.) </td></tr>
    <tr><td class="paramname">SelfCrtp</td><td>(Derived CRTP class.) </td></tr>
    <tr><td class="paramname">SelfType</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">SelfParameters</td><td>(List of parameters.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Common type copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a509316d7acef6deb88f2ec89bdcc9d70"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, SelfType&gt;::value)&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SelfCrtp&lt;typename std::common_type&lt;SelfType, OtherType&gt;::type, SelfParameters...&gt; magrathea::operator| </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StaticVectorizer&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise OR with lhs value. </p>
<p>Applies the bitwise OR operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
    <tr><td class="paramname">SelfKind</td><td>(Kind of arguments.) </td></tr>
    <tr><td class="paramname">SelfSize</td><td>(Number of elements.) </td></tr>
    <tr><td class="paramname">SelfCrtp</td><td>(Derived CRTP class.) </td></tr>
    <tr><td class="paramname">SelfType</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">SelfParameters</td><td>(List of parameters.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Common type copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a374ca607affe84170a9ce05bcb5c0bee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherType , typename SelfKind , unsigned int SelfSize, template&lt; typename, SelfKind...&gt; class SelfCrtp, typename SelfType , SelfKind... SelfParameters, class  = typename std::enable_if&lt;(!std::is_base_of&lt;Vectorizer, OtherType&gt;::value) &amp;&amp; (std::is_convertible&lt;OtherType, SelfType&gt;::value)&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SelfCrtp&lt;bool, SelfParameters...&gt; magrathea::operator|| </td>
          <td>(</td>
          <td class="paramtype">const OtherType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StaticVectorizer&lt; SelfKind, SelfSize, SelfCrtp, SelfType, SelfParameters...&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Logical OR with lhs value. </p>
<p>Applies the logical OR operator to each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherType</td><td>(Other data type.) </td></tr>
    <tr><td class="paramname">SelfKind</td><td>(Kind of arguments.) </td></tr>
    <tr><td class="paramname">SelfSize</td><td>(Number of elements.) </td></tr>
    <tr><td class="paramname">SelfCrtp</td><td>(Derived CRTP class.) </td></tr>
    <tr><td class="paramname">SelfType</td><td>(Data type.) </td></tr>
    <tr><td class="paramname">SelfParameters</td><td>(List of parameters.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean copy. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 6 2021 17:41:37 for MAGRATHEA/PATHFINDER by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
